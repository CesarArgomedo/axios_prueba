'use strict';

const fs = require('fs');
const sysPath = require('path');
const { promisify } = require('util');
const isBinaryPath = require('is-binary-path');
const {
  isWindows,
  isLinux,
  EMPTY_FN,
  EMPTY_STR,
  KEY_LISTENERS,
  KEY_ERR,
  KEY_RAW,
  HANDLER_KEYS,
  EV_CHANGE,
  EV_ADD,
  EV_ADD_DIR,
  EV_ERROR,
  STR_DATA,
  STR_END,
  BRACE_START,
  STAR
} = require('./constants');

const THROTTLE_MODE_WATCH = 'watch';

const open = promisify(fs.open);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const close = promisify(fs.close);
const fsrealpath = promisify(fs.realpath);

const statMethods = { lstat, stat };

// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn) => {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

const addAndConvert = (main, prop, item) => {
  let container = main[prop];
  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }
  container.add(item);
};

const clearItem = cont => key => {
  const set = cont[key];
  if (set instanceof Set) {
    set.clear();
  } else {
    delete cont[key];
  }
};

const delFromSet = (main, prop, item) => {
  const container = main[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main[prop];
  }
};

const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;

/**
 * @typedef {String} Path
 */

// fs_watch helpers

// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */
const FsWatchInstances = new Map();

/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)
      );
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */
const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], (listener) => {
    listener(val1, val2, val3);
  });
};

/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) => {
  const {listener, errHandler, rawEmitter} = handlers;
  let cont = FsWatchInstances.get(fullPath);

  /** @type {fs.FSWatcher=} */
  let watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
    );
    if (!watcher) return;
    watcher.on(EV_ERROR, async (error) => {
      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
      cont.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (isWindows && error.code === 'EPERM') {
        try {
          const fd = await open(path, 'r');
          await close(fd);
          broadcastErr(error);
        } catch (err) {}
      } else {
        broadcastErr(error);
      }
    });
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close();
      // }
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

// fs_watchFile helpers

// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();

/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) => {
  const {listener, rawEmitter} = handlers;
  let cont = FsWatchFileInstances.get(fullPath);

  /* eslint-disable no-unused-vars, prefer-destructuring */
  let listeners = new Set();
  let rawEmitters = new Set();

  const copts = cont && cont.options;
  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = cont.listeners;
    rawEmitters = cont.rawEmitters;
    fs.unwatchFile(fullPath);
    cont = undefined;
  }

  /* eslint-enable no-unused-vars, prefer-destructuring */

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options,
      watcher: fs.watchFile(fullPath, options, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter) => {
          rawEmitter(EV_CHANGE, fullPath, {curr, prev});
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener) => listener(path, curr));
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      fs.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

/**
 * @mixin
 */
class NodeFsHandler {

/**
 * @param {import("../index").FSWatcher} fsW
 */
constructor(fsW) {
  this.fsw = fsW;
  this._boundHandleError = (error) => fsW._handleError(error);
}

/**
 * Watch file for changes with fs_watchFile or fs_watch.
 * @param {String} path to file or dir
 * @param {Function} listener on fs change
 * @returns {Function} closer for the watcher instance
 */
_watchWithNodeFs(path, listener) {
  const opts = this.fsw.options;
  const directory = sysPath.dirname(path);
  const basename = sysPath.basename(path);
  const parent = this.fsw._getWatchedDir(directory);
  parent.add(basename);
  const absolutePath = sysPath.resolve(path);
  const options = {persistent: opts.persistent};
  if (!listener) listener = EMPTY_FN;

  let closer;
  if (opts.usePolling) {
    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?
      opts.binaryInterval : opts.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener,
      rawEmitter: this.fsw._emitRaw
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener,
      errHandler: this._boundHandleError,
      rawEmitter: this.fsw._emitRaw
    });
  }
  return closer;
}

/**
 * Watch a file and emit add event if warranted.
 * @param {Path} file Path
 * @param {fs.Stats} stats result of fs_stat
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @returns {Function} closer for the watcher instance
 */
_handleFile(file, stats, initialAdd) {
  if (this.fsw.closed) {
    return;
  }
  const dirname = sysPath.dirname(file);
  const basename = sysPath.basename(file);
  const parent = this.fsw._getWatchedDir(dirname);
  // stats is always present
  let prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return;

  const listener = async (path, newStats) => {
    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
    if (!newStats || newStats.mtimeMs === 0) {
      try {
        const newStats = await stat(file);
        if (this.fsw.closed) return;
        // Check that change event was not fired because of changed only accessTime.
        const at = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at || at <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit(EV_CHANGE, file, newStats);
        }
        if (isLinux && prevStats.ino !== newStats.ino) {
          this.fsw._closeFile(path)
          prevStats = newStats;
          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
        } else {
          prevStats = newStats;
        }
      } catch (error) {
        // Fix issues where mtime is null but file is still present
        this.fsw._remove(dirname, basename);
      }
      // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      const at = newStats.atimeMs;
      const mt = newStats.mtimeMs;
      if (!at || at <= mt || mt !== prevStats.mtimeMs) {
        this.fsw._emit(EV_CHANGE, file, newStats);
      }
      prevStats = newStats;
    }
  }
  // kick off the watcher
  const closer = this._watchWithNodeFs(file, listener);

  // emit an add event if we're supposed to
  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
    if (!this.fsw._throttle(EV_ADD, file, 0)) return;
    this.fsw._emit(EV_ADD, file, stats);
  }

  return closer;
}

/**
 * Handle symlinks encountered while reading a dir.
 * @param {Object} entry returned by readdirp
 * @param {String} directory path of dir being read
 * @param {String} path of this item
 * @param {String} item basename of this item
 * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
 */
async _handleSymlink(entry, directory, path, item) {
  if (this.fsw.closed) {
    return;
  }
  const full = entry.fullPath;
  const dir = this.fsw._getWatchedDir(directory);

  if (!this.fsw.options.followSymlinks) {
    // watch symlink directly (don't follow) and detect changes
    this.fsw._incrReadyCount();

    let linkPath;
    try {
      linkPath = await fsrealpath(path);
    } catch (e) {
      this.fsw._emitReady();
      return true;
    }

    if (this.fsw.closed) return;
    if (dir.has(item)) {
      if (this.fsw._symlinkPaths.get(full) !== linkPath) {
        this.fsw._symlinkPaths.set(full, linkPath);
        this.fsw._emit(EV_CHANGE, path, entry.stats);
      }
    } else {
      dir.add(item);
      this.fsw._symlinkPaths.set(full, linkPath);
      this.fsw._emit(EV_ADD, path, entry.stats);
    }
    this.fsw._emitReady();
    return true;
  }

  // don't follow the same symlink more than once
  if (this.fsw._symlinkPaths.has(full)) {
    return true;
  }

  this.fsw._symlinkPaths.set(full, true);
}

_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
  // Normalize the directory name on Windows
  directory = sysPath.join(directory, EMPTY_STR);

  if (!wh.hasGlob) {
    throttler = this.fsw._throttle('readdir', directory, 1000);
    if (!throttler) return;
  }

  const previous = this.fsw._getWatchedDir(wh.path);
  const current = new Set();

  let stream = this.fsw._readdirp(directory, {
    fileFilter: entry => wh.filterPath(entry),
    directoryFilter: entry => wh.filterDir(entry),
    depth: 0
  }).on(STR_DATA, async (entry) => {
    if (this.fsw.closed) {
      stream = undefined;
      return;
    }
    const item = entry.path;
    let path = sysPath.join(directory, item);
    current.add(item);

    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {
      return;
    }

    if (this.fsw.closed) {
      stream = undefined;
      return;
    }
    // Files that present in current directory snapshot
    // but absent in previous are added to watch list and
    // emit `add` event.
    if (item === target || !target && !previous.has(item)) {
      this.fsw._incrReadyCount();

      // ensure relativeness of path is preserved in case of watcher reuse
      path = sysPath.join(dir, sysPath.relative(dir, path));

      this._addToNodeFs(path, initialAdd, wh, depth + 1);
    }
  }).on(EV_ERROR, this._boundHandleError);

  return new Promise(resolve =>
    stream.once(STR_END, () => {
      if (this.fsw.closed) {
        stream = undefined;
        return;
      }
      const wasThrottled = throttler ? throttler.clear() : false;

      resolve();

      // Files that absent in current directory snapshot
      // but present in previous emit `remove` event
      // and are removed from @watched[directory].
      previous.getChildren().filter((item) => {
        return item !== directory &&
          !current.has(item) &&
          // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath.resolve(directory, item)
          }));
      }).forEach((item) => {
        this.fsw._remove(directory, item);
      });

      stream = undefined;

      // one more time for any missed in case changes came in extremely quickly
      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
    })
  );
}

/**
 * Read directory to add / remove files from `@watched` list and re-read it on change.
 * @param {String} dir fs path
 * @param {fs.Stats} stats
 * @param {Boolean} initialAdd
 * @param {Number} depth relative to user-supplied path
 * @param {String} target child path targeted for watch
 * @param {Object} wh Common watch helpers for this path
 * @param {String} realpath
 * @returns {Promise<Function>} closer for the watcher instance.
 */
async _handleDir(dir, stats, initialAdd, depth, target>Å³ÿS;;¦7î­";%xZkÂ€bZÿQ0†¬Mè~ä:A{íùö"ÇZöm£ÒG	ÁÌ	5˜AQÔb ÷‹}½jm„Ò'§~K§·Qj£LL¡ë’³†u1ÀË>Ñe ±ú#|–ÂöŠ¨\ÊÏğ²íh¿mŒŒºDGš¤-à…ı±‡ğ,{ıßÆœ”õ|™X‹HùYÓq™•X·%‘™“€CR-øşˆŠ•™pIß+oƒ›²g…¬×ĞZš±ƒ/]m‘ßã‚4?–³ãœàsqÉŠ<\œGÇö·É•YE°~yCÅƒ^á¹V4¾G~EÄPqÔ£>É•Ç¿#ãuh~£EĞ²ò'³G­p*˜I»œíQg;"¿ŸŒoYÜÈ«ù'ÙƒØë¥è¿Æó5^=×“‰;ôõdñ_ó†Ï×Ø;ómN†•S_OÎçk”Ø{æk”Y[Ô
ˆŒ‹ïV³ÿâ`ç ¨’MMA#²×ëUÉÛÉî+c‡o´hİcâ	šíÁ]ÑØøAY‡¤¤Ü¬&GÏ
!+Mş´´Fù\­²éüœ¶”^¢k¶™ÓÉp'ôóò¤ü•—œô¶ëôğ½’7|rÔO¼ZrÔ¹	ôHLÊşÖC·<ÆvGÒaã:¿CÆZwâ"¼YCqFVÒõı“”hÓÖò£RıjÏ£õ¿%¶ş¿|šúÍöjıu¦úuıÎ£¯1rİuƒÑ®[hú(9<ÿ†èzcåÅ:­a“Õ!­?‘c)8„ÚŸc úšÍÎ•ğ”úÈ/FÁt]#9WÀÈÙ0J3İŞçÀùûbÚ`ÂÆüu‰Z¨e\›!¶/öÈÒ·;„ÉØ}[œmq-vT\Pµæ\S À»/e *¶ˆòg‹°ÙYœüªı˜×‡sÕ=È­îÀQÚG¯åÚ¸×+ÎO®O´‰„W{ù?EöP¢ÊÛuÄÅĞ£rŞÁ>îkâ{ÅËSx <êÒ& ş7±œ„¦#j'ÏÍalët’Zv·ÎZjÜt	"%„	<ä",=‹¸ã9xÈÈ«f?×²÷EŞX;HcúÿÍZ%ÌRâ…DË…MkÃf4ã2PÛû5Š€r9®Pb„°Øwsœ¡—Í<”P­»°ƒk>!õ Õp¦@šTTiCÃ’Û‰Óöó.¼eù»£…‚Î#¹Jëò£( ^‡à@´q®­Ç‚c6êÖæf/—„µaa´WB”RÉÕ¸V)
”¦ bªõŠÈ Ÿ|@ùä%¯¤{Yx©¶­´N˜%VáDQ/doFntV•Ù/· Ofè•û’ôM´Õü1óÇÛ‰´¬e[.ößQv"’ög'Ô»H2i!XNñ&x¡	¾vX!ÌÂh·MRKPG(e«Ù„5Wµ›¢EK°u¦ÁäQé…ˆıºş­S¨,¸¸æÀ7¸WâDz‘æJpM.Nü]‹³V¢aÔÆvÓ®ïğ]¿6AøÄ]›Nâ³vÀfÔËêùbÛcûÄªÊ¥¦@¹—íB;Ë`Ãš³Oo.µ´a–¡×2¸cg÷Å¤?|[ï¦ÇüØMZ7]vÔ‚ÀÖ8M³„õn²>¶Cõn6üñØÙüw•Ğu«Ô«õñáe”û—7k¥z Ú­«¥‹Y
½}ŞÊ‹«Vç|?6õ§¼Ìı§”œÒˆïumú%7d˜õ ÜÁÑ˜²ñm8zî@.p;Şq•xñĞCbı›3e/Õµú;$Œ3Ğ ÌÂúƒTòV(ùlO'.5¹6Öo‡_¡Yfx†P÷,»å,­˜œPÍËCa¿ßüw±ştªP÷ÛÂíÄ±„MXD—œŒc<¼jíR“PkJ	P¨15
Põ…~M‚ª=×ZIlGDAg†ÂfgëüN³O±êXR—ñÚ&)şÒšM§0Ç“èz«¼C[Ô¼˜Æà•4.,ƒ€Örü
ø®‡ïJxÊ[æe%uñRà’úB—³„šâ4ƒ|ˆ"&OÒ>Zæ.¾YG‹–íŠZË¡g`¿o©mÍ%@gLaÕŸ	ÍÂê=°y‘"±·uMi¤¼3ª‰Î÷÷Ãój6j·À HäÀÛúåÛè2Æ’¡‚R¨±Xbp1qÈ"®;R…ºM$‰Pœ×ÌšÕ[¨ÙGXÔtË8õ¥é˜„ÇÕ,¬GÿcWêj8!Ô=C¬>ó6øû‡‡]½ÙÕnøê5¹™ÂHüM6‰Mk*8L2)È§Hn£¼’d^*sô¯\&–sa1¯°±~ŠôhÊ£o+ì7¥Š>òÂhğ0Bí·¨µ|A!Ç6óÁÛØô¡ÃB?XK_`30ÂSÏÄa¥(ñÕø „|°TfY¶!|Ğ[ïC6è}T1bt¯6,ÅèÒ&~"¬<…€/r¾S}íp>àğ¢,Gõbp_”~õã&!4&_³ìÆÍ2‡œ©]ÿ0»*?»Ê*ÔıÙ4\Wå˜ã]õê±®Â|.®Ô?½€]e¦•5³ş…xW=øuUà…Ót•Pó©¼´î:Sıò"C	µ·À}¼ÏtÃ±¦'ÒiZ•§=6ûŸŸ®…‡ƒPhºTßn>æv]·Ç¡¬–'ljÂƒ’“ê
½&l7‡…‹~ªÏ…Çq|İÑ®u˜çêçvG¶ Í£¢ÓÑ³¦\–ïAÿtİwVcõ6XsC©ûa¾©ûø½…ÿ¾î^ø=~/¶úüò§ÃÁì²|˜›{¨V
ªwGÆşxÚóæ®É§1i¾›¼ì¨A,~læÌÖSxwÎ÷ufëÖ™íŒ¶Álçè+Ú»¨ –Ç©ãúåâhÎŸl£#²ÄW»Éíuu­¥İØnX-LE%îòb4ìu5•ÿ£Ûâeı^×ÀÊ•”#ÅBˆÏÁ¶Î<o$-M°h”Ãİ¯{'ïóÂ:„[¿è¸	y&æ}× <ÀG»ŞôºÇµ:ç<7+ËZyz©XÄà	X˜.¤ió˜6‚Yfãš…ZFZ³š…º$hª˜ä)¼ç}ˆ—Lİéß4„ÇÓğáİv@]ü®¶^ş*J³´ÖGIR?òÛ	ˆÖüîÿĞX,ô?©¾åÿäm³$²ãê °‘uàfVdö:\óÈ„û~¤	/GÆu[1‡Ñ-äš¼OOÆå¼vJ?aíón†AÚ iBXÿŸÄ	il#¨û\zZ|ä(ŒoïRğˆâNgÂQ5ÓõB8_hI]jW>\ˆËÿ£1êôÏğ@·ÒVo'æ<XkÕ=°."Aflæ.f™~AwİahİÏ£å¾¿ZQUµ&Û„ê¯R¼y)<%ËŸW›ö{òdÂCœøo6mÅ`;õ°Á×ã]amF]µ½÷‡ãĞÿ,2ò)§)ªä(Èjº£­.T~ ZSBJUt(òg‘yïI'ÕĞõ-‰n³	«*ULÕğÿ½õ"¦şãÏÏ¢ç?·D}jÿ\Œîğ¸îÙÏ_³…€0·š¹é4Œ¯ÉÀ5&R	··ê‰–ÄõÀ1<Oî[Û‡Gã0ÆG¢µ2› !Üè¾wáİù˜ìcz0ê\éˆ†¥`³5Ø?¡üŸ¯9)OeâõqD¾O$Áİ$±öH÷ïœšæ]2ş†F õ8Oeš®Fí¼…Í²É˜2ËócşÜÁBXƒ¥£°.•ApüpÄ·"KÍÈ¶¾>‰Ybˆ0ée6ÓÉù>¼wİŠ—|øhÊ.©]e¼Tş±Ì¬oAŞÂPR§¬Ît*êhx6<y9Zdó‘ŸÀ›ıçğ:ÀØÈïz€ì˜®ÀwÕ“Dé‘‘ÈN 	R™Zg9`  6ŒÍ”Ô‡AP¢)¸İ‡Qa"*ƒ.vªb.Ÿ Êâœ‚:=ôAÃô¡!c##
ÜÓÛbö_†…‹Xæ¢?CPş{£iÂA¿ÚÎäîEÏOtÕtzzaIb[®„>T³Rô'T…5E¤Ø¾mŸÿôıÈ.løŠ$Ó»Ğ2æ¯_‡…Ùë
Ëƒ^[\(!@Á“?Tâä×t3f´Íx]KØÏº‘ï|ë"T=¯ú“>ëÑ¯¾a+)ëHï›.E)¨ù)X±SÃAÌ&M´n‰S«I Jù
}j ?îÈsoYáéçÆN1õ7ÓÓm>îu¶ç©<St‡èº×.¬wFy¶IfsEĞBcLo6$<$s«‘1ÕÁC|E/¹‰Š[i¿'-±U”×½ğ4p68F¯¡ÄÖ®ÀÎŒ¶ˆ/äqØşÄ‡7<eìåËáËœ—X$ô”‘E§c#@ÄZb+êî&ß Ãèo÷­İßî¶§â¡üTéıOæ™äú·Ç†7· eWÚåƒÑÓÄ_ß·SµÅ\-˜L-xá9>LYÖîË'øş“Ø€Ÿ=§×äºz…V}éI=”E£ÓER'Œç»sœôñŒÖ£ƒ!/©Õx$¿ªc-xÔû`4~†x@ì¨Z]ˆ=qHvµV¤‚¬ÒË2O=«“µ+~VñõçvÑq¿ş*D7pšÆx¢RHıy®T´ØV±(¾ş<‚EÖ†İ½º®\bYçDö
ÜrÒN‚V-–Œ¶hš){º¤ŞTªå?ç”ºÛÊŸñ¨kíÌkW7HñúË¼ş×%Ö¿âwCêø	ªIbı‹iø¢ÅöŠ•‰ù‹Ù#%§¯ÿ^¯?Ÿ$ñÚK±sT{ø9“’Badw©¤