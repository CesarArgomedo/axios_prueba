'use strict';

const fs = require('fs');
const sysPath = require('path');
const { promisify } = require('util');

let fsevents;
try {
  fsevents = require('fsevents');
} catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  const mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    const maj = Number.parseInt(mtch[1], 10);
    const min = Number.parseInt(mtch[2], 10);
    if (maj === 8 && min < 16) {
      fsevents = undefined;
    }
  }
}

const {
  EV_ADD,
  EV_CHANGE,
  EV_ADD_DIR,
  EV_UNLINK,
  EV_ERROR,
  STR_DATA,
  STR_END,
  FSEVENT_CREATED,
  FSEVENT_MODIFIED,
  FSEVENT_DELETED,
  FSEVENT_MOVED,
  // FSEVENT_CLONED,
  FSEVENT_UNKNOWN,
  FSEVENT_TYPE_FILE,
  FSEVENT_TYPE_DIRECTORY,
  FSEVENT_TYPE_SYMLINK,

  ROOT_GLOBSTAR,
  DIR_SUFFIX,
  DOT_SLASH,
  FUNCTION_TYPE,
  EMPTY_FN,
  IDENTITY_FN
} = require('./constants');

const Depth = (value) => isNaN(value) ? {} : {depth: value};

const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const realpath = promisify(fs.realpath);

const statMethods = { stat, lstat };

/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */

// fsevents instance helper functions
/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */
const FSEventsWatchers = new Map();

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
const consolidateThreshhold = 10;

const wrongEventFlags = new Set([
  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
]);

/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */
const createFSEventsInstance = (path, callback) => {
  const stop = fsevents.watch(path, callback);
  return {stop};
};

/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;

  const parentPath = sysPath.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  const resolvedPath = sysPath.resolve(path);
  const hasSymlink = resolvedPath !== realPath;

  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath.sep)
    ) listener(fullPath, flags, info);
  };

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size) return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(list => {
          list(fullPath, flags, info);
        });

        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return () => {
    const lst = cont.listeners;

    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher) return cont.watcher.stop().then(() => {
        cont.rawEmitter = cont.watcher = undefined;
        Object.freeze(cont);
      });
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
const couldConsolidate = (path) => {
  let count = 0;
  for (const watchPath of FSEventsWatchers.keys()) {
    if (watchPath.indexOf(path) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }

  return false;
};

// returns boolean indicating whether fsevents can be used
const canUse = () => fsevents && FSEventsWatchers.size < 128;

// determines subdirectory traversal levels from root to path
const calcDepth = (path, root) => {
  let i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
  return i;
};

// returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat
const sameTypes = (info, stats) => (
  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||
  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||
  info.type === FSEVENT_TYPE_FILE && stats.isFile()
)

/**
 * @mixin
 */
class FsEventsHandler {

/**
 * @param {import('../index').FSWatcher} fsw
 */
constructor(fsw) {
  this.fsw = fsw;
}
checkIgnored(path, stats) {
  const ipaths = this.fsw._ignoredPaths;
  if (this.fsw._isIgnored(path, stats)) {
    ipaths.add(path);
    if (stats && stats.isDirectory()) {
      ipaths.add(path + ROOT_GLOBSTAR);
    }
    return true;
  }

  ipaths.delete(path);
  ipaths.delete(path + ROOT_GLOBSTAR);
}

addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
}

async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  try {
    const stats = await stat(path)
    if (this.fsw.closed) return;
    if (sameTypes(info, stats)) {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  } catch (error) {
    if (error.code === 'EACCES') {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }
}

handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  if (this.fsw.closed || this.checkIgnored(path)) return;

  if (event === EV_UNLINK) {
    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY
    // suppress unlink events on never before seen files
    if (isDirectory || watchedDir.has(item)) {
      this.fsw._remove(parent, item, isDirectory);
    }
  } else {
    if (event === EV_ADD) {
      // track new directories
      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
        // push symlinks back to the top of the stack to get handled
        const curDepth = opts.depth === undefined ?
          undefined : calcDepth(fullPath, realPath) + 1;
        return this._addToFsEvents(path, false, true, curDepth);
      }

      // track new paths
      // (other than symlinks being followed, which will be tracked soon)
      this.fsw._getWatchedDir(parent).add(item);
    }
    /**
     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
     */
    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
    this.fsw._emit(eventName, path);
    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);
  }
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} watchPath  - file/dir path to be watched with fsevents
 * @param {String} realPath   - real path (in case of symlinks)
 * @param {Function} transform  - path transformer
 * @param {Function} globFilter - path filter in case a glob pattern was provided
 * @returns {Function} closer for the watcher instance
*/
_watchWithFsEvents(watchPath, realPath, transform, globFilter) {
  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
  const opts = this.fsw.options;
  const watchCallback = async (fullPath, flags, info) => {
    if (this.fsw.closed) return;
    if (
      opts.depth !== undefined &&
      calcDepth(fullPath, realPath) > opts.depth
    ) return;
    const path = transform(sysPath.join(
      watchPath, sysPath.relative(watchPath, fullPath)
    ));
    if (globFilter && !globFilter(path)) return;
    // ensure directories are tracked
    const parent = sysPath.dirname(path);
    const item = sysPath.basename(path);
    const watchedDir = this.fsw._getWatchedDir(
      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent
    );

    // correct for wrong events emitted
    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
      if (typeof opts.ignored === FUNCTION_TYPE) {
        let stats;
        try {
          stats = await stat(path);
        } catch (error) {}
        if (this.fsw.closed) return;
        if (this.checkIgnored(path, stats)) return;
        if (sameTypes(info, stats)) {
          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
        } else {
          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      } else {
        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    } else {
      switch (info.event) {
      case FSEVENT_CREATED:
      case FSEVENT_MODIFIED:
        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      case FSEVENT_DELETED:
      case FSEVENT_MOVED:
        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    }
  };

  const closer = setFSEventsListener(
    watchPath,
    realPath,
    watchCallback,
    this.fsw._emitRaw
  );

  this.fsw._emitReady();
  return closer;
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} linkPath path to symlink
 * @param {String} fullPath absolute path to the symlink
 * @param {Function} transform pre-existing path transformer
 * @param {Number} curDepth level of subdirectories traversed to where symlink is
 * @returns {Promise<void>}
 */
async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
  // don't follow the same symlink more than once
  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;

  this.fsw._symlinkPaths.set(fullPath, true);
  this.fsw._incrReadyCount();

  try {
    const linkTarget = await realpath(linkPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(linkTarget)) {
      return this.fsw._emitReady();
    }

    this.fsw._incrReadyCount();

    // add the linkTarget for watching with a wrapper for transform
    // that causes emitted paths to incorporate the link's path
    this._addToFsEvents(linkTarget || linkPath, (path) => {
      let aliasedPath = linkPath;
      if (linkTarget && linkTarget !== DOT_SLASH) {
        aliasedPath = path.replace(linkTarget, linkPath);
      } else if (path !== DOT_SLASH) {
        aliasedPath = sysPath.join(linkPath, path);
      }
      return transform(aliasedPath);
    }, false, curDepth);
  } catch(error) {
    if (this.fsw._handleError(error)) {
      return thiU¯<je)¬¸QÄœ*~D`=­WB!1[àŞq¬VO˜GäĞt ŠHLÀFÑşØË"ƒW’6m¨“3®hwH…5FdV¬*	9€DXƒšâZdV¯\Éİ'ƒàfFÜ{4¦Ø~„r"f«šÕŞ#4wïšÈÇHlÁZZ^¼ÏJ4!«Ğ4Š¯I&lÚPÓ×"ÓLşì“³sßá!!ZØ]r5‰ôlğ&&!
ş6uù&õ&–],¤&´%mi0ëøl­	kÊ}=p™…&„£¨3ZbÍ<´*ŞĞÀá)¾Lp–"?%{r>|<ÌDM!˜†÷œjFQ0dCë#dUï#"ĞÂ$Uµ{ Ì<zääüëz&Ü
&ì+n„ÈÆíGtZiE™¬8ìàq¡“gÔØCC§móC9tâÆC2”H®¾ÂgGnD:AÖ!C§ÆEeXä×¡éNœÜˆtşîG„—Ü:E*¯óáß±±S1÷*€ôø®Ñ¹ˆ¯œiÑÊõhÉ;Ó„\”®ÄSã?²9"U‘¢ÜGvòÜGvYTÙhóTs¤|bµ±¿!^ÉgDŸ›OÑ·_&Ùn?$JèÂî…ú=BÒwceüçK@¼Ÿh5,I+ÀÉ²¦Ñô&ÁaøŸo	Œ›y:ÂX±î’ñ‘ßÓø8g}*”¾ÁÂx~“º¸QHø<¢7ßÖ1<ø$ÑË°ƒ+ıÒÓ[¡Øáø–£¿È©şÆ‘áqiç˜‚4b‡‡îÛ»),[Ø«,U ÅÔí%<:ÖÓ¬±xIK¼x»bô2.S¦ ƒÕJ¿äM5±ˆÍ\˜y|‰°dÏc#Nó0NèÎH•ØEÃ/LìòÈ7;ãmfzvCßCÊrÎrÙ÷ğ 	}\@®°>*{ê)Mäm€ayŸ7v[úRcBí†!!ıÓì-\‘¤0d­°QœhÌˆº±Šf™1²_ÿYÃ…çœÈêU^†}{æ°Ş¬ï2fO´ˆãOô!©ûÜ‰L„H¦£C;ğ|1«L"X&fò£°D±VŞMf2!o3 ¹šüV
Ç4R„dœ:¬gë÷YíA²òò°£ÿ¼ÄLdx‡”y]ÛÖäTÄ/YMFU+'.ÈÈXØÊÁ²«HI#b¥FÙˆˆjxà@bi¾ã³¬œ3Ìçxc”"aÚ¢¸cUô3#ÂZæšÍ;T*óTP¥2F•1œ·‚ÅÅ¥´ø£Áğïv«˜ç¤Á}Ø™ÖbŞôÊ¹ÂQ*„íi	|¶°Ò8-ËDLÄRR?)TB>*•FL••=OXTêhC‘yUå<èV.<;VVÊÉ<†Œô“ÇĞßC4Ğd‰zËÀĞÇ=ÜwŒNÓQTŞ±¬Ì¦|nŞqïÑ˜[ÏcŸ)"AïøêXÁ²‚å]'5Ó×õ 1–Bì´$z´XÎfäîŠôÈT"èŸQÚÌ°ŞH„ÆÉË±_GÊi¥…à€ƒĞùH+1¼n¡’ì^È©4K´(Hkúœ<\§Í`(#Xt‡‰¸L}Üˆ`•²Œ¥ )q™AÈd×ˆ"P÷î0ï ™gÒ®ãÅå™ÊìâYÔôpp<ûz¸¸¼õ}5§Of@p^È*ã>Ó—âÍúM©]ı|ù‹ËÍP¼çFf‘¬K¦¨¨Ã¿L‡’e‡Lö±†í¡+ôˆ‡(ŒÇğQ¹cºğ`ÛND"¸³gÖ!c&æÃÎccæ&ÔØcc&fÒÌƒàŞÑıjR¯×<£^SêæAAS	ôú ØäÌ†õ"NSB4Ø«ƒ‰ˆ½	æ#7hkpLÖÜ<l§q*ÁMºXˆäfBnEqÛ£Ü$x±I3{ÍÌ¾k<šP¸GÍå
ÚØ;B~;lnÆ"<>nÎöjĞş'®\ïé&bö¶f#“F#8jz#«7ÇÍ4™Eåì‘s
‚{ªÊr+ğôŞEİÒJn÷.É´çÍìF9÷xˆ# z-*PzªÈ½Ì('ÔLr¢KD$'ıD(4È§S9©÷ÉÉ3¹,#T„Y‚v&>dn„ô°˜¹Şö†Š‚©$W×£»Ÿ9$Œ>ù†ÜÎGÿÍÜÑú:®Îu‡ú’ì@êM­LcØ®Ÿn&GUúÉÓ£ùBûâQh¨Ê¤£7Ó-üV)]¾Eÿß¡Qr+ÿa8\·ænSr$ò•“á4Ëjµ‡'U1I0u?9À™×$å¸ O×bè011Ğ–Ì3yˆ®²D9¢ ¸,%()·8ZÂ‡~#'èå`º™;_U÷ÀÀRiä²€(ç²>ÃµÔ
55@Ÿ[‘<V“BT,ùl¸JòëjX
–™ùF0Ir_Ø*İÀªÅ4Ï—aÎ’Y-c±=	¦X™Ú	®›¹põ[½<&Dó-˜xoHVæ¾p@(âPŞ–—pQşK4šIÙ_ïG6!ÀmmçÍ7íÕmëşôxdŠ-ıÿÌİ'ŞT´)ŸTĞü²˜¡¾"†¨Ñ¦Ó`Ô UŠÒÒ%=£Ô+º Œÿv(ãøùĞSÒÄÍùsİ¸›şÈíÆÖ¿=´â4Ôw‚–ªQÈaó:³Á¹Eª4E‡
ñêIÒl+·‚ *Ë`4€ÒÜÕœ«é«©\²s¾¬9[åòëë¥â‚Á”İmÓÃµ,ôÈZHR]b§uÂÕ#Ÿ´õ‚§wyÓ‰ øÕ¨
]Œ
j[¨İ£¬õÿÕ;¥i?)§_^™LŞÙYGşxÙLàÍÇ"@Lu"¯k75æ¹üĞÙìwÕgrˆğvêI"ƒøt¬î)Íåœ™³fC>@¢”íêÌNÃë
­°	d¥ğ0Š
[q`È¸K÷ªÂÙñĞ(=-h3`È·Pç
93¾F¡úQ'` Ö59WY%B’KjŸOıkİN¸Káˆƒ<J	Õ°S¶ ­²7iı.¯Où„±Èg\ÊÿÄÂ·?fg½ßTX8€ÕsPm%Iòbª#R”K•ªNYÁuØƒRìKîí§ÜwŠ‚ğË ‹Âjõ, /÷(ŠG»ÜV?’ú¶ü¥ú
Çƒ
Cæl˜S‚	Ägq˜èbsÛ~\m· ß WÈÂ¡­Ö•Ó†`Ò)kíªYÈÛvxhËê9lTâ(×½d¥¤‡Õ)%`§è€T¯Åê@ø!nºZ½Úå‘«ÆÆpaoë/TQgC¾5ì	>‡©.ıTJ…$`GóÓ%ü%7 U/N“Òóê­mYt#\6åi1^ëÕ> >8”¨óbÑ¶hÑ7¨vV_h…UP#T®A ¯nTQ©dHrü¥ÿKäLø66?knZQ`k‹mÚ¢pø%W qŒªÊY­3°Øò¡…ô'¤½•R‰ımÄ3İZtƒµü¨
S\¿µ/[”œoâ¹ 
ZÛÔ	ØrHĞı±ºíVË×ãŒ9‡º€×êºï—rvê
¶°Ò¶@ÎTÄ]¨'{ Œ]ºv±öÊa0Õ/äÔÜå·éÑ”œ’—em¹>Ï«U!«Y0"Â]¸5„Õ@€ÃÛ-OgkÉÌŒÒCâ‡/v1xİSÕµúûßÔ6 åÁÀ²¨[6èr²”Ht¢œı"‚˜Û.ëu”òCrßg·mNæ¡•!÷mSìÿl)ıEw[—Ã&£™§Aì”7çpñÁ!t†Quu—Å…Éú‘rdh7 uº=å~ÀÒ©Í³¯çr¯Z{×êz< *¢øò—rE!¹6ªŒPgÎeãlYW³ÛJ­˜
ÂªR·Uz#Tà¹+tş'7úŒâæ]—Å¶Ôé$|ná^ÊÿZrr«ú™rH5PùÖ™?ØÎÀa¡¥r!.Î¥Zs:ò…œL.¾ÕJtˆ¢nV½´©³uÏÎÇ×,ºÛŒUpªná?QNY<Zfµ¢³n†hÆ„Æ uuå’åÒş ‚çÎ7e&³‰F—*î©äû9F@ $:§Y$ºJ®äW+¡!{×WÇİvJ-/ü*âÄ¹-G›ÑÂ¯å¸‡ğcƒ	),ìœìœ…ÿ6;\WU Ë6…cFÏş³Ñ ?õjùJÁ¥:<…İ-ºV²®Cd7ä«^"§sÄ‡Ê(.£È7béSdršD•Bnt‰ÂD,ÔÜÀYrJÜv7º'nĞ[Wr«TÔãéHâ(*hb«äqe!RêÎ¯­l«¡‹ÆÓ7>ğu@Zõ>-˜‡"Š·C¸ti´(šAäNâ~YÎ‘C*¹å{Å™:ACŞ%;Ó¶»¹…rá@éhA !3şiM Ô86GëIˆ©ÁPƒP:TAô…¿'ºíÒdH­	nú:u©ä[ˆyaª¸cV"<N·]zGèTÕıH-Rı©:P…·3Ö(
x‚ËGB½_" &2RÄù)E3§/‰­ß×•\áPt#6/ĞîŞÂ}C ò¶[_Ü­ÿê>•>G¡rá,º6G²0‹é¾Q5Y˜hC›h]#¬ˆ¾Hæ`ÅØM9oÇUGKu¨hJŞ š/“:¨„©<™æíÀX27_/Ê¦]|³\-TJ‡£nğ­à7"~ègº­K·1¸Aàº0B¥m?['UXB.»²¥˜ÏÌ:Â’Lç,9´…i1Gcìë:»´Ó‡œ.w‘Ï]¡QufÛ¶·Îòp§<Î¿\•Rå2ÚÒÃÿ
FLfºe°qĞ¨j-œNFƒm\(°T-©<ÛÏÍgo_…r#Ù—Èf-ÆòÑ5€Æbœ§:Öä‰|<h¬á€è.]Ç×:á4¥g!êÕ5§òª"S¼ùº*5í¾›âşÄª@5ÎÛ“áäHDÏíxœ'r–ê.Ü,dA7ÜŸx{•µÁ×€©Nğ…£€ôàâKLÂöSWÑºní|xº²£„æ‡~•›gN´u ¡7•P©”‡7ÛÚrBĞd˜Na»ç(.%ĞÍÇ Qé¬Ö.CL 6ˆæúµ§&ò¸¦†8tj”{‰'òÌsô`›øèÓøğ$=ëêfEJ0ÙƒÌDU¬70›t\}ìÙ¿Ê+}'	@’#'J‚    †áŞn»ÖØ’daÃûl&³Akù–VyT(6'­[öE^J¾A©Y›²ÏN³éÆÙEËÿ¦