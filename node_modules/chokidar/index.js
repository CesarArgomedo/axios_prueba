'use strict';

const { EventEmitter } = require('events');
const fs = require('fs');
const sysPath = require('path');
const { promisify } = require('util');
const readdirp = require('readdirp');
const anymatch = require('anymatch').default;
const globParent = require('glob-parent');
const isGlob = require('is-glob');
const braces = require('braces');
const normalizePath = require('normalize-path');

const NodeFsHandler = require('./lib/nodefs-handler');
const FsEventsHandler = require('./lib/fsevents-handler');
const {
  EV_ALL,
  EV_READY,
  EV_ADD,
  EV_CHANGE,
  EV_UNLINK,
  EV_ADD_DIR,
  EV_UNLINK_DIR,
  EV_RAW,
  EV_ERROR,

  STR_CLOSE,
  STR_END,

  BACK_SLASH_RE,
  DOUBLE_SLASH_RE,
  SLASH_OR_BACK_SLASH_RE,
  DOT_RE,
  REPLACER_RE,

  SLASH,
  SLASH_SLASH,
  BRACE_START,
  BANG,
  ONE_DOT,
  TWO_DOTS,
  GLOBSTAR,
  SLASH_GLOBSTAR,
  ANYMATCH_OPTS,
  STRING_TYPE,
  FUNCTION_TYPE,
  EMPTY_STR,
  EMPTY_FN,

  isWindows,
  isMacos,
  isIBMi
} = require('./lib/constants');

const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);

/**
 * @typedef {String} Path
 * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
 * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
 */

/**
 *
 * @typedef {Object} WatchHelpers
 * @property {Boolean} followSymlinks
 * @property {'stat'|'lstat'} statMethod
 * @property {Path} path
 * @property {Path} watchPath
 * @property {Function} entryPath
 * @property {Boolean} hasGlob
 * @property {Object} globFilter
 * @property {Function} filterPath
 * @property {Function} filterDir
 */

const arrify = (value = []) => Array.isArray(value) ? value : [value];
const flatten = (list, result = []) => {
  list.forEach(item => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

const unifyPaths = (paths_) => {
  /**
   * @type {Array<String>}
   */
  const paths = flatten(arrify(paths_));
  if (!paths.every(p => typeof p === STRING_TYPE)) {
    throw new TypeError(`Non-string provided as watch path: ${paths}`);
  }
  return paths.map(normalizePathToUnix);
};

// If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path
const toUnix = (string) => {
  let str = string.replace(BACK_SLASH_RE, SLASH);
  let prepend = false;
  if (str.startsWith(SLASH_SLASH)) {
    prepend = true;
  }
  while (str.match(DOUBLE_SLASH_RE)) {
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
  }
  if (prepend) {
    str = SLASH + str;
  }
  return str;
};

// Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why
const normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));

const normalizeIgnored = (cwd = EMPTY_STR) => (path) => {
  if (typeof path !== STRING_TYPE) return path;
  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
};

const getAbsolutePath = (path, cwd) => {
  if (sysPath.isAbsolute(path)) {
    return path;
  }
  if (path.startsWith(BANG)) {
    return BANG + sysPath.join(cwd, path.slice(1));
  }
  return sysPath.join(cwd, path);
};

const undef = (opts, key) => opts[key] === undefined;

/**
 * Directory entry.
 * @property {Path} path
 * @property {Set<Path>} items
 */
class DirEntry {
  /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */
  constructor(dir, removeWatcher) {
    this.path = dir;
    this._removeWatcher = removeWatcher;
    /** @type {Set<Path>} */
    this.items = new Set();
  }

  add(item) {
    const {items} = this;
    if (!items) return;
    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
  }

  async remove(item) {
    const {items} = this;
    if (!items) return;
    items.delete(item);
    if (items.size > 0) return;

    const dir = this.path;
    try {
      await readdir(dir);
    } catch (err) {
      if (this._removeWatcher) {
        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
      }
    }
  }

  has(item) {
    const {items} = this;
    if (!items) return;
    return items.has(item);
  }

  /**
   * @returns {Array<String>}
   */
  getChildren() {
    const {items} = this;
    if (!items) return;
    return [...items.values()];
  }

  dispose() {
    this.items.clear();
    delete this.path;
    delete this._removeWatcher;
    delete this.items;
    Object.freeze(this);
  }
}

const STAT_METHOD_F = 'stat';
const STAT_METHOD_L = 'lstat';
class WatchHelper {
  constructor(path, watchPath, follow, fsw) {
    this.fsw = fsw;
    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path;
    /** @type {object|boolean} */
    if (path === EMPTY_STR) this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? undefined : false;
    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path);
    this.dirParts.forEach((parts) => {
      if (parts.length > 1) parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }

  checkGlobSymlink(entry) {
    // only need to resolve once
    // first entry should always have entry.parentDir === EMPTY_STR
    if (this.globSymlink === undefined) {
      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?
        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};
    }

    if (this.globSymlink) {
      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
    }

    return entry.fullPath;
  }

  entryPath(entry) {
    return sysPath.join(this.watchPath,
      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
    );
  }

  filterPath(entry) {
    const {stats} = entry;
    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
    const resolvedPath = this.entryPath(entry);
    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?
      this.globFilter(resolvedPath) : true;
    return matchesGlob &&
      this.fsw._isntIgnored(resolvedPath, stats) &&
      this.fsw._hasReadPermissions(stats);
  }

  getDirParts(path) {
    if (!this.hasGlob) return [];
    const parts = [];
    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
    expandedPath.forEach((path) => {
      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
    });
    return parts;
  }

  filterDir(entry) {
    if (this.hasGlob) {
      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
      let globstar = false;
      this.unmatchedGlob = !this.dirParts.some((parts) => {
        return parts.every((part, i) => {
          if (part === GLOBSTAR) globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
        });
      });
    }
    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
  }
}

/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */
class FSWatcher extends EventEmitter {
// Not indenting methods for history sake; for now.
constructor(_opts) {
  super();

  const opts = {};
  if (_opts) Object.assign(opts, _opts); // for frozen objects

  /** @type {Map<String, DirEntry>} */
  this._watched = new Map();
  /** @type {Map<String, Array>} */
  this._closers = new Map();
  /** @type {Set<String>} */
  this._ignoredPaths = new Set();

  /** @type {Map<ThrottleType, Map>} */
  this._throttled = new Map();

  /** @type {Map<Path, String|Boolean>} */
  this._symlinkPaths = new Map();

  this._streams = new Set();
  this.closed = false;

  // Set up default options.
  if (undef(opts, 'persistent')) opts.persistent = true;
  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef(opts, 'interval')) opts.interval = 100;
  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  const canUseFsEvents = FsEventsHandler.canUse();
  if (!canUseFsEvents) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs_watch.
  if (undef(opts, 'usePolling') && !opts.useFsEvents) {
    opts.usePolling = isMacos;
  }

  // Always default to polling on IBM i because fs.watch() is not available on IBM i.
  if(isIBMi) {
    opts.usePolling = true;
  }

  // Global override (useful for end-developers that need to force polling for all
  // instances of chokidar, regardless of usage/dependency depth)
  const envPoll = process.env.CHOKIDAR_USEPOLLING;
  if (envPoll !== undefined) {
    const envLower = envPoll.toLowerCase();

    if (envLower === 'false' || envLower === '0') {
      opts.usePolling = false;
    } else if (envLower === 'true' || envLower === '1') {
      opts.usePolling = true;
    } else {
      opts.usePolling = !!envLower;
    }
  }
  const envInterval = process.env.CHOKIDAR_INTERVAL;
  if (envInterval) {
    opts.interval = Number.parseInt(envInterval, 10);
  }

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = new Map();

  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;

  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
  const awf = opts.awaitWriteFinish;
  if (awf) {
    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
    if (!awf.pollInterval) awf.pollInterval = 100;
    this._pendingWrites = new Map();
  }
  if (opts.ignored) opts.ignored = arrify(opts.ignored);

  let readyCalls = 0;
  this._emitReady = () => {
    readyCalls++;
    if (readyCalls >= this._readyCount) {
      this._emitReady = EMPTY_FN;
      this._readyEmitted = true;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(() => this.emit(EV_READY));
    }
  };
  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
  this._readyEmitted = false;
  this.options = opts;

  // Initialize with proper watcher.
  if (opts.useFsEvents) {
    this._fsEventsHandler = new FsEventsHandler(this);
  } else {
    this._nodeFsHandler = new NodeFsHandler(this);
  }

  // Youâ€™re frozen when your heartâ€™s not open.
  Object.freeze(opts);
}

// Public methods

/**
 * Adds paths to be watched on an existing FSWatcher instance
 * @param {Path|Array<Path>} paths_
 * @param {String=} _origAdd private; for handling non-existent paths to be watched
 * @param {Boolean=} _internal private; indicates a non-user add
 * @returns {FSWatcher} for chaining
 */
add(paths_, _origAdd, _internal) {
  const {cwd, disableGlobbing} = this.options;
  this.closed = false;
  let paths = unifyPaths(paths_);
  if (cwd) {
    paths = paths.map((path) => {
      const absPath = getAbsolutePath(path, cwd);

      // Check `path` instead of `absPath` because the cwd portion can't be a glob
      if (disableGlobbing || !isGlob(path)) {
        return absPath;
      }
      return normalizePath(absPath);
    });
  }

  // set aside negated glob strings
  paths = paths.filter((path) => {
    if (path.startsWith(BANG)) {
      this._ignoredPaths.add(path.slice(1));
      return false;
    }

    // if a path is being added that was previously ignored, stop ignoring it
    this._ignoredPaths.delete(path);
    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);

    // reset the cached userIgnored anymzGÙĞs%ß’p³â^a/±U«_»¯lJ‘òrí§%Pòli·A[Ò-ğ¶˜[X˜]îj2ÍìÊ°ìÚÚµÎZWíëĞbÈ„.ã—rÒ]Å{bœ˜œ­ª`êKÃ¿ÇLÓèV>íe° ìËj@µ—ñËrIÛ—ì¥)ºáŸ„¦L´fÙf´ÍÚ
Î¬3¯·i3zvæŸkZJ³Ğô©v\«®×:Ÿã™×dĞêUšÕ&µY±Â¬6‡ÍÍ²Ï¬ls¹ÙóèO(~¦	ÂÍ8©Îªé:PæWšgkDXœfA6œ,Nnà7œİ‚ó8Oh¹µOËÓğyR%´	¸N´]›Ó¬Ç¦É¢²:ºÎÓÚ®;ëÎ±Ósì!»S.p»³*¼ÊªóÙµÏç½¦”ú¶&ã¹Ñ‹XIÖÏªäjO¸`mi¬Uz(•î^|z>ÕvƒÓ|®>ŸÏ—®ÒYlÇìÒÍî[úH„Í¦Ï®ÀëŸm·?Ï´Óf	Óp`-Ğ«+„bb›X [ÁZÓÑtôÚÛº,™m·ÙnMäšê}UÀ9½Ù¥N¯‚°§Ë€Y§ÛE7ŠÆYŸ‡±OÛ·§Í&¡ê³@uV€µXXuşg8›±ÜØíxl¡Ğ4f‡YÔõWl*î¹¡pŞZê†xõ¦:=¦ÑŸ=ZRS7ÔkãÌÔU_ÜwmÿÏGƒ6 ÷#ƒ%c{ÉöF¢%ÛG«ÅõXìa½šW—Cë±fÖg-(ÄEJbº=ËI’ªíÖ¤në²Kym]–¤n½­ÃŞX¹!×¥YR6#°Ø®×õ]»zlÔ-Zæöxsº;´	óúE³¶>KÈ=ô ÷õVæz½n%Y^³‚³¯É@YPÍ¨gå[¯âµjÍUk²
µÖñµRaï½İ¦3p­Ö«DèA/òõ¶!Öwñ›.Ö]n~¼¬«ÚãmT;JØvÕæÙUÖÊÕ"íén©i©à±»±6VµBaŸğÈjºY·©Âº€O¨§Ïì"³Ëù•àô-Ìa6`öİ6Ş-”ÃÕwÕJ`ªNu;«V¨í
®¬M.›VØ¶Í]˜ô½†m÷[+ú<az`ÏnSòğGJÓÇBqzÇVf?°í){mÖÆˆ›Ş-eËı¸	Z®>`=eí¨§{šÓ@•¹î®×wÃnÇîQwŒı­[ìö?9R”;=tĞæğ'njŸÃİµ/.›W@]“¼¼uw¶GÛæ-'Ğ÷çğÇÚ°õeY@½}å–+vµÃ­ÜÕNŒ7înKğì0àãÄÇzóüyrØË€Â¥ká¨õ vnU½šlÖÎÀuY{jÖ\ÿùê‘5Ú‡Ø±ú–kÃçví!íÇ¸cyŞv¸ÜñôĞ)Ò’»z±qcÚ:p;BùÖCíqÜÕ¸7ï.²`6İ­k^ë¨õHîÑB»[PuUõ¯öîØ=ºo/\´nÚw;l³¬§¶Ãñ^ÁÂVŠÀ¥ëë¾‡[ßeÕ â¾ßkI±ß7KUè%ûÊÂæ9R©VIêeí˜ztÖñÛÑ¸äŸuëşfÉ
ƒæáµÚ¸:k;Úßw öOUÎUGØ±jë¬ö`¶sìQÁÃf~
àû³P²|tù\¹Ã-)áÀ,{t!îØïì98%î!p³çí¶k-8`,³;ldvÊÁ©YãÁà<^uÔz¤äèƒğƒğ™ğu!{Û!÷ ³yœ{°Û=üªZ)
ÇÏÔWÃhœõçHŞ #ñêÉºÙtn·kY3³Š…Øºì9õƒ{œö8Yp›îÖE³vØ;ÖÖ‰Üñ³òr
²Ì uÙzÀÚ‘õ‹òHşH~sÖyÛë+­ÚÚ”=hyĞ³?¼l¤aßl§9*±ì*Ïæ9Ïqu9ºE
áÊyíº¶Õ­Ò -åhû.á#åºÇ\Î\·±œÃ-·´Û"ª5°­vÒ=ªí\»§ÇÛmpŒ!{EÛ´Á˜íËvS+˜‰UU',G¬ÃkµpuÖv´µãâ–­TØnş»?‘_#‘Fwà s‰G`)h8´×‚#O©á
0ehş¾©‚‡í/0­R÷ëH*Îm¨ûÁ¸i
ü\˜_ƒI•3\Ä©xæâ–\l¨2=w2tq«‚*.ØL}T*ÓĞ@’öW–Ne,0‰ó:%6¡
ÙºC¤§-43Ğ¾\»AÊİÀŠbh+”Z¤UmL:¨¾ª(»Exî@HßøÅñoÍ áéUqãJG[Ú•Å"‡¤wN´T~5
/hîÚIå2Ln‘‹ˆÙİ^
=ÆË¥YL° SSL!=wÔ9(mĞ4ÂZƒÁÇ»¹ÅÌVP!*ª¦Pˆ®„¨XºEZVä:h¹x4L²)D‡—wZ	úÑ­°jS€0<µGÕ°€Kì¯ ïKõ¡ ¯•ØÒCCÒàÌ¨À8­rr×¬¸}4pç¯]Óş0ŒJü£ÈõBˆçîï¨¯‚†¼LÕ°3W í7&hŠXl6”Å]r±´bâ©‚@.€Ul@5‚òÇ^Ö°ƒ*ŸøƒSàÊOÃ›»¨Ò„X)°§˜áW
©°A#LÕATÅW'¶`EÓA8QTuâ,Q-ÎPmP;Õ¸Ö0£Ep¤°LÌ 1ïâ­…k…¹!Òƒ•ë¡´@b Zi4Ty¥hâ"TĞVÃİÆ:Éà$[3hPªh¼›@'?¿ƒ–ZÑ0©·‘†'wã¯—°ä$V÷«}ºkúL˜”s««i¿~8İÔ2TLüBwDTp@U«S‡xº\y°0LIlæğu¯èá%¥İ‚v¸™Ê°•<L²ü%ÔLÅ_A9øìñ®t‡@åá«”¢Ÿƒ‡¦áÑJœy·­È¡*…Ú»<ø›…·Ú@l…V{—Zà¤¬
`aı24|NQæî$¼•O'ƒÔ@®ø] 2éÙ2áIïw(÷1:Y;»ÈòHÀ*‰€ÅŸ[´hGµóàV¢“»I±½E†©.l`U˜:8·iĞç¢mĞ4(4‘y‹V©8Z3z0EBíıĞ÷j
YdƒX+D°B¢°Ji	Å9¬`üª€FÁ‘ JôM€*‰7F
Ü<¬ï§Ñãó“çƒK§¹—‡«&wXì!eŒŞÌ„3ÌÀôVÙGC,0ùcj^;ÂÉ$æ'õ!ÊÒY»ÃÁ`îB)8+Nßm¯0`Xó“˜À2°ô(¯Ç‡«IiòDù@‚4ÍY5P½&+H{`˜Qµ¬ƒabŸdH†H–º'~pÊtÛD^ğ0üƒM'³X
]˜ÕœJƒH.+&`í6ãÈ¾¾•W—2
2€£lígP &L8CÃÒ7#rŸÅ3
P|™B£q\
qU·T‹Pú¬…$B<Ã[M¼aå)DÉ&½FÄÔ4-…ài[dZ„q6‡N!„l.Û‡ÄÓ*„H“‹ëR…ûâ²¨BTuq.&N/!4t!wXY‹a„un|Ä#r;…x6¶xˆ¦‘Q-„æ&çüåR‡<79ñPhµDGÈô…8Æë7››!.ÊLHˆKı–Âx¶!Œ…q'‚ºĞÀ…NQ’-ÄØpÁ…ˆ¨•Qº¦ÏSN)ÄÂØuBB³%>>Ä‡Éµx.õ©q¢”z!G(°„p‡NJ£wx;Å!0.‘_İ„^qt‘Ñm!0UJ+~Á4\o!bi‘t0ËÑ
#n\³&6éÂR“p‡¢4'!%æÑ«ñ8À†İ­®ÑÈ¥
#¬cƒÏK—Ôbó\êÒß.„j_ÑI¨¥âÀĞT„„Ø¯µû[ã.J-!”X¸…G2-´&.õÎQ\¨AÑºtD&Ò&7—IOx©.ğÅ!ê†T\x„ÑlˆÑ„»	ø&Ô8^a„¸&…G‡Sñq€'ÄRCá¨ªLˆpPB\é(Pâ¾…¨kZÓ«C
;)³&'õæäï0˜H1ÜBD“"-!0‹LKˆ:„RÍâãÍ¡‘^
òêØ¢gÁLëRˆ‚Ó!p‡œ›­‹£È‘Ğšæˆ‹éMb©'Os!(£&MB	™ùÕGˆ„E…Ğ¤§/Ğ;ûdNĞB¸|Ÿoµ~=S„µ˜NFÔşîsı‰owÈ,å‰ì5‚‡šxìnA?ä|O¬Ø)OH¯4Ÿ?Õö±ø1‰üLö‡ı‘€ø8SzÈÃÎg=İ[©{¿½Ó[xµ¿ÛotwÅæa0èË™¢'GéñENÚĞß#X{¸A~!QĞ—rĞfÃŸvb¢™f±52/öçş­'Éz÷‰\LõÃğ;&şÚÃ¶.@èäK›ĞÔ²Y›ğbšØØK¡‡ŞZÚáÚDİ^Œ ì< 1ç‰­ji<tK„mb?-N‰aÓ‹÷uQpË:4'ù÷Ü»ai‚şñØöO'yĞœJ”Ìı·O|±Œ/>S*<ì­ü‰³rø¹o*.‰UÚéÂ1ñÏ*„|"QeØ!ÈS”˜ßû2G”'7¨©0Í6p\ühé›ÈbJÀCüxtOø£òlŸä¤Œ;‰åÊ÷¡3,õ‰ş”îèV<~„Œ2¨BmbÙ"j³X¦9'r‡”6S}brŸèËıÇÂDñó‡L#šOôß8ğ°61j/³1º
ºW@‘unWDŒtÄ&~†#¤ÃìéübWmö-µ‹lO=´ûÜ°ı4î }àæÄæ¸ş?ä˜Ö‰ÿ8½GÑÚD8Rè›÷ PfÊÅ‹‹!øa¢¸Dîcü!U©èbl™£M±3¨|¼œùø·s5:±FşÄ¿HtXDC¥
ùïqÿs¶OR&ÊÄ²‰òî-4ÉÊtSDöÄ‘ı! úâ¨~|”^¹MK4Îî#¯oëÄï¤‰wAßAñ•À3¶ŠĞ/Ÿj¡ä¢´^\S‚æƒ/¹œäv†,hM¬¡‡ôUCLtG.f•İƒ¯ù÷?‘+4O,¶ùÁĞ;p¥9#œ>jÄDX#ä}‘}¡<s#Sşò‰…Îy#´L:¿Ùx’Û¿#E±Zß¹§—ø”* €u¸å'™À_<…ÿQ®ôÕ'‚	
K:MàÌ‹xş§VßĞ^¼î‹Ç¢şâ,ª':àKÌMx/$â~Øªt(/é1¢u¼î‰BøÏ¿ét/u1ë¢üÄk!º§—t˜ÀÑºñcz~ó,¹9‰!ú`yt¾/é1.dŸ¡0‘.")Íûê}4½	ò£D¬Û'Ï³´Ç†/¾9æE¼Qø…‡=D’*)_aJ”ı…=Æw?ÎF§ÏéûÌÜqf×±´—
ÎÊÊ2ŒHî¼ ˜NeÖßHK;_Ó^„\ÔÊœkh¢.AºŒPí.ínú^İS>ÚŸÁœ_u˜ª¿ur¹vôóáÔÙ
#Q—nÚg®ûİô#ØÙH~‡¶´Wçğ¯».PTMr	¸Ys·Zú³?û:HñÖìÍpĞSŸr–\Óü’ïT¼&‘öø\`^Á2¨J€Íÿ/GŞÿû….6¾P5Ö€º¸ğƒ#­Û²ñúB‹LgvÁq!õÌÔGnúMv__… Ö°5b Ó¹~OD›ˆBDööa.0l‚V2ÄÈM+úÛLCuÒúÛgàšçó„.EJ3Î–çË2oŠµ²ÀÉT"¨"ÌjA³ÅÎÓ§˜eÀ‰5ePY[
àÈç£dà~¹VLô^ğ´BŸ°µ»ĞË8Ã,¾>P¾­r,¥Ñ½ìÿ*¾•vÏ)ËğÅ~€’;P«¤B)Œ39B_gAZ$-lÄ÷NY\·a Ih~¤­Å8Í¿‡ Nr
/æ.2ªpPÎr™ğ€Ã#O$(ê’Á›  é³„{>Œ‚V ÙBã2&*L-äåÈªÉa1Pê!Úd,àøF¢¯HdÆ€Q’µ•ÃZº6'G
\`BÖŠ‹*ÖıT7•Ã 	º¬ŠkT„¯ªÌqĞDÛ=è}KCvİˆk[ç†¹ª+gÂxƒ„,>.eV°PÖ7B¾æ)îDÊ1Ë²ÆovdBŒQÑ¿*´ ´ì	ffI-]`{‰õó|S
.û!É|Çz|ùñÈ…<?®Ô~#q=¿D)¹¨Ÿ Êã'S`İõÕ+dÏ2ğ/‰0"”'ë‰‚O?(1å’×EÎÒüFV ‚Óê¹ ŞNVyã±^õÜ)ÓLå%s1HA¾®‘nû/6ú6P%ÁÆÙ"zDŞ÷g*Ô1Í½,<AÊÈó`t'cŠ#693&ŒHÃ¥‚dH+Æ3L•Ğe,ë|ÜçXeÆ×,FßE)m”ˆ 0¡†ED
¦”ØEBdŸqŸkŒÆùd’Œş}x 2×B‰Ğ]ßaöQZDªğ|×
9ü•ƒ«ù ·ÏiJ:J^LZ·v-æİ±’Ìa‰‚ù°J‘?+,NÉÑ†¯X SknÇQ!ób~wÆ­²uœc¤¬&îeœnw1Û¹“V2‰>Bî€
àŞ‡‰äoàabÈ‡Y(§®ŒáL‰8T›Jäù;9$©ÌdÀnCyRZ0³%æéØS{~Lb_–8x«¨i¤m5èG5»Ç8<ÃbÒ`[¨ÉcñÇQoúª!à#=«ÛÈğ%
ÿÈ„‘¥K-#ù^:¸›²é9_ÒÏ÷¨Ş§À öÆQ*dD!¢à˜ks1ŠÓõÕ=©=ßa¼únœ»è,eŠXæŞÁÖ~¯òj¿ÓœrD`0ğÌÎìğÙ¹ÀÓÕ—cív%U1ÕÊôÍ/0,ÜÃñ„ 4JCŒZ&ô¯ÍF'#J*#}ÿùß%ÿ²JÉûF ˆÇKïò©FZ‹”@É‹ì)W·â?_½£ô¬9`Îô³›VÓ
Eú¡	¨Mêo‡¸Ÿ—<Q‡LAX8Ÿ›PÔ¾Ã1¥yC”Ö ºøsE Dÿğ(5v…pñ÷4ûâ"?ôˆ	ıa“43JOuBñ¾q$¡g2eÀOf	ØÕ2¦Á0Ôï¶KUáùf”èk.ÿH'Nq+š¢Í;Ëgùg
úL??	Òx¡è‘×€Åîœ¦øœØÄ€Ó»ß“x¨Æ×‡{`¡,‰$Äâî²Ä'ĞÆ/€Ğ¯·ºp9„'·bè4U”<Ôw9	øÃîBÆèŸHDx\£>É‡.@~ê®MAøwF1
3Ö·Â>ÍHá¢İ%¹hÅ— ©ñoñÚw"^°sŠ—%j¶ø Yâà_Hş|·Ï__…ñ@¾I&ĞÃ	°o¯ç‹l¯´%;4€<FI@vÒø^ï —øz!Õó!úÇ|=îl­½Â˜d—8H€\”¼(«¹8Äì]ñë.5¿?¼®Q¬}	„»Û2¾KbA/•} Ø	3„¼ØF×ÁÅ^ Qa®iÑÕ.<ËÜ£Ô0 9š‘zşÖøŸ±ÌnÃ€ˆ·Rß/o ¾Ùqõí„W=N uÉvÆµ@ÊÜ1Š{vM
G=ò<ÌQKjî'ñŒ¯ ı*^2—Wé@ÅŠºÌÉVƒ†/†¯ãÃ‰ª'ñŒ¯ õ'^2÷Cé&ÊS	ÚKÄ¶Ä½À&d$@vëøıùN¿,¾½®o™K­tõºÅÕ Y&À£@ ZŸv¤k¥‚AÃ°ë¡˜(‰ˆÄn¢,¿m¼c7’3$Ü‚d¡şÌ®`ÁiˆG’.ˆÔâgnÿÀÄq€~K7:E¾ 4u¤ÿN®.Ââx û”ÅRçğW]¹X›¾W˜5SiÅºUP3rú¬ÀıŠ„lÿ$çºÇØ°,ÏŠ§sÑW‘p·Şá\ı$k‹Oşş:rW$qnIsnFÑa×1á­æZ]|İĞxt¤K¾fù)â	‡Ë€£Ä@,¾¨‚‡HÏ¹éºKÄÒOCÒ;ÇqƒÊ_ Ãø_kù‹ÇÁÃ•dTlh„ì0˜ÿ"hÀ¡k)üw”ñpUñ	$k245]„:ÕñÀö‹aˆ†î×al")ô)®ÈN†ÊD€>>+A„øÉg“ãëh­äoè~…5ã;ÊŞ~Á3ìÖé].zß9‰áôGß–IÏOÑàŸ!tß¶P|ÛĞ@CŒËõÎU\	Ğjñ@kÄ=€l|İ°ÙdßD“)‰¯ˆ½(îí2şŠÍ?áúL 9ÖqC+x†]ß² ±pÃ8Wë½.ïN#‹©³Ç¿ V¾Nˆ3¬Bê_,š$uv‰:½°úTÛ.€j|˜°ñrğ*¯a^ .+tÂ†hë&ÌDp»À?wKŒMhV½‹h,Í×bk’–ÄB]õúlÎ†Ğº 'Üºzü+¸ñJ§sG“º°Î(´²iÅlé]Â"+¥uı%×)Öó3a9ƒli^ûO0n»‘m§Iİè]•‘BusX“°¬W…ºÅë~£*ığ_tbt‹<®b’*át¡û8÷ bñõ ¤âğR÷ä©Æ‡"aÁDÒbë˜""ìwwÃ>Ã¼ø)gçSèìÆ(Ègm}Z|‹¡FÇh¸Ù@J %¾ãoäú"ìÒÉh»@˜!àCŸ&8Õ*OÌº×qvÔŠ Œ8êùuG‹u¤§éä·ª	»jñÆ–ÎpşËèÃeğPí”{ ‹x‰$]ñ@ç…:a]KÆpÊA¡ívzsDÙ)hæ]6NrÈ‹¯ºCY¬N]hò1/!57!NŒ,äU¹hwOê‰4¬Ç†:»¥‰ŒüÎÜ´ªsa‘gq¦p Û9¦àHe!ªÎøZÂ¨¥ß•=7åôü„[Úk×“œ$€¨ğDê cÂn¥OÕÓæUW% ›_ŒNÎV—Ê\‘…,!K†#v68HG÷¾·w¾ ›ªÎ2ZñƒQµÄjóë6< 8¸YdQÚ—çÕs¥Êà‘$­LR5½_%—m¾äD	›{şX†;·f:òÅ§*;²]›¯6QôWlºŒÚ&Ôã°¨eçÙ™°T³Ğ”ª-›¢ÃÕç¿>ëô¯DLr˜ìúîë ğôˆ'½½ïT0ë“ëìÕé“{p™€¾/Ñ`m¾$QÍ¹ M`H5ÉÉ„e¸g›*zó{ï|(Má¤ú©œÊ:Óìôîü 5ÖÙTvJÚæSİy¥Ô€5"r‡´åòSòŒÀ(UÄ¼%©çRA ô/HúrìıÙGÉY/‚Àõ$€Ş¿dÙ‹h€&¿’Ğü0€¶ÙË»¨F@Ç^˜PóÒ'0ÒÀÑ_@¶¾ û‹ ´záèµËT½Å
 ù—+µ_4¢|Á/Y¾ĞK¤ËËĞ/2Eÿ•/˜!‘¡³Ša×—öKªSÎeÖ®;—¾e;w.z•¥+çqäåÜ%ı~£Œ£#”£»˜$@Ò¾d¢ë‹4 ”]8	â×‹R`úF#ï÷âÏXÇ&xÒq›’1Èéäçª$ĞªÀt^b˜ú¿øã´ÕÄ¸¨%á˜~Ò íç.Àhò ê/Z#yá$xçE]ÀD/Œ4½Ğ&Møu'—ö…ã; ƒÁ3¶[0nÆuìàŒAuì  ëİA !	íí  !:ëİA µğî˜ì_i0~Ø	'	=Ğ%ÕÉÄ#OÈÂÂIpó—)c6¦•¸\¬’²^)<|m6ñÄC	Úµ¹ˆ²N@¢]—ÃÄL¾‘	`zb4Hûe&ğö0MKÉ*~±ê`—}zŞœwTXÕÑG#WÑšB;v4h”Æîïh4¥vww44ŠÄuØÑHÊå:Kİßy`ŸÉÊBL%ÏèzS`=j9n”€Ù›?eÅƒ»‡6Òà>Ö£ş9ŞÌ†øµq,Pjb;tÄ¶Îìq’ª‘ ŠêŞ`—Ô¥±	¼#2jª7ƒQeÀ¹M•ÆJ’¥;9VüTSÄ»Tsst:È9İnårGç!=ÎÑèˆm|pÇÅ_f\kWö–‹ñÔÛr.Ş£[ËÅx}p¹oÇ&—‹ñ0çr.ŞFIîİJ%‹çŠ–rñ<œ˜\.Ş³ZËÅx]l¹oË*ÄÅémÙÀíùm<ò7 Máéñ¦-TSâá±$™(H”&ğtñÚï>ÀåŒm³”†§ôÜÓ\¼k<t˜5®‘†'Éåfğ€İy;À)Şi5à:®N=pãI7~‰Ë½á))Àq'pWZá®«†‡ÉŞ½O€›QÜ£1†§­ ©ß§á£«rèI•1FÇ¦4Ûó¨â•£FnÏæÍÛ–Ú*5x/5«ø«ªëUø¤¡}¸¬”	Ñ«ŒÜ jª5ø¼ƒ1[ãÍÍ¿¹Åûßƒ$Ãü€,õÅ}“(qú£4ö§dÂÓW­r#^yÏÑ:Õ¶99:]ÚúG'Q3„gó´ZÁ‡Wí¼9có“Ì§˜ş¨O:tTH?üöM?}'~:ñ´ŞqdïÎÙ®Ÿ¨§¢Qˆ@v‘ïÒÎ7sÌGzŠ‹’:ñ‹‡›Šø¡¡û!ù=—5a§$é}ÖqŸÉØ­â$Ü¤|~œûOÍß·Òsd_D™z>i-ïÉU™¹åû2s}]Øöt‚®c™{i::×.ñÀI°sªsYL–K8»šİ´Pc.®Úù|290×ôæˆ—×ë8ÊÅñR\r@W*ç¹x<+˜\x£Tµç€Æ¤îİ{TsÄº¨ú9G7Í=ÏÑ’Ôª¢>špPÚv	¹tr®÷sPÙç:“³(ÉÏtxbs3ÿÜw3üü_¸Ëelã]xÖË-t€ãs’	ÀÆç?ŠOœ]Øèè$ JSsÇUæ²‰c§Ë“ÜÄÍëÛ*¼˜‚1Ñ¦œò)gH@Ë_èÌ	4+ˆMg˜ê'UY
U07iU£)•±×M^¡Çu²à>  ~INSILR“ÔHÃí^é”µ&­÷÷I7Rî®n¦=–/m=ÑlC#ö­ì'“®½¢èsc‘{Ï¥‚y7¦î«´İª×Õy#Ş¥qMmO	X¤QJo£ô1–»ÉZ$ÀAß€ÌÖŒƒ‹}ßæÆmŸ¦Ÿ•÷=J¯í¦8åşPQÚÜ¦ÇôºØÌu»Ôo‚)ÅñÈ9ÿß°Úc‚ËpÃ A&ö­uj-ˆy§ƒÓ`)¯I“%/Ï©§Æ±ÏÊÒìS;ª#èT|AÊL¯ûñË”ÆÉLWÌ}’EÀÇÅ|ÉÌ°ÂLÚ°§E{•tH´2¨¡x=~ë²6Ãğ EÍÊ…r²¶±¶!Ã/Ò–Í}˜òtyö˜b6÷¸rO”ÏóÌ¤‹@ÑtdMÑNgïÁıÒûc7<U©¯ãtu‰é0½¯eÊoSÉ¦åöİL'(Â´{uÚÑÃi:xé©‡šõaÑA8”mĞp ®mŠšÛ¸¯HÛà¥ëXnúp‘%ã¬S‡éÜ-ªm,ƒ‹'#š?è"/ÊªÑğÃñ_ERh8ÌGL4ZpôÌêEYmM9Yåï™ÓñMSCÚl‹—[Ë—¯d¡fÙÂ§ŠtªqãäA8.èns|œzKGX>=!!DN÷ˆEØhäáƒ¦I¢4tpÀsò´ñÃ‘1Ê@< «¸ÚmáÖ§ZP–¢×êz’Z=“q8|—Ş+ñ=e>·ú_İÇÛ=HyVÉî¶ïU8h1IÚ{SŞû’«JWÊ@xø}š7ñHŸï˜óæ‡N7úéC*œ?t' ÄİÊ¸]=Ì	¿Œî“øtC¢£2ƒ½æìĞãõS¼ÎÉG½×|ÃÇìg7Ï|´Úk\y½_?¸xıØ¿OñÌ×±ıúĞŠBñC÷—òóCC'Súö¡CG·ôûC¡#©ışĞèŞø†íSÓ›ÇöSš%±U&=µ™ÓÜ r’Ö`œq~”œ";äşƒ#7™ŞØÂù-‘¶f¶§zÂÂ6¦veLNó©n¸İÆ¹´Á1Î0uİäFİÆ5¿ò¦…—·rºãTµóŒåÆÏAàSø®ë“˜D	ée4~<KYê÷–ª¦©77àÍÁÓ{Â<
ógû"‘!½•Üáä>S}2†'dêÀ8€`}#eöXZàËcï!Şl”îàºúÓˆá·D1N5¾à`Õ¬·!Ë‡fŠŒ<À^47£.ö©Œl †Ø5¡œ4«Û9fùš½£Ú#›ë5¢_|ÈÄ˜ÁÓó¾éÜ3»ÍµÌ›æé#ƒƒhµ†’ŠNj î¼Úà,xkg#kàjï×qg_é–0¹Q>ZÄ6#´ä±²#&ˆULBi8Cì3$¬Ô‡¹FÏ‡àéb¥º¾gWÅ=5VjŸeÅ¯'Ü«Ô9É4ogœwmƒC±Ì¯Ç*“6®Ô;P¼©³”l*G,WÛ!H¼+m–‘¿ª™v‘›ÖÚ?4 k¿¶ïß·jßv3¦?lùµSJúob'v:Ï)ÉJéT·\ç/q:ÑæÒ{*ñ15®Àé¡~©»Í©&Ì|F€TXÄ2÷	LärÕáŞ–>FãX…±ŠlGíŸ¿íÆ®a3J,Ö€šè)¨©]#-Ks×£+õ8—â^Ã¯„ı¶ë¿±â®N“‚rKµi­ÛèÜÎa}ÚTé£&ë½š8rfK!Å÷´7«BŞŒì„`ÈŒPÚ^8–€j§YGè3¸ï¤£»œ3
ƒ’ÏoÎvtv¢dS3Ş0gXnhÄºTnÌ5¼…ªCQaÀUaIdË×2`˜2:;ã³`h;À©.ÙÇ[eP»yñ²–İ¶á=|N>ÈĞŞ6«¬Æ±yW^¥•macm^F°í¤ÿ`±ã%²m%¶Ñâfì~¦”Õ
mœÚ›ƒ›ºo™„@¢v7qùØ‰»ñõÙ±Ÿ·Ã%§ıòYU(ˆcÂ{~dPêÓ×L]¬%ëà„å‘Dÿ¡W®ßI‡¬£vufÃbX7 8ûPû;¼_i‡$5íy"øLù¬Òé±)1{»'Pà§¡(&#j=2vºİ
 HKÛÜóÌ½Qş`ëÅq
 Ûó6pº0õ¯vyºÈœ†yÓÜfƒ|U0”å†S¤+5¤ë¼¯êt]¾²«şË•–ºÃ7h¦½Zìfáœv;¤ånÆ ¾`ë1/oó<¯æ8»«, Ğ»ÅêŠGÂ¨TÔUT=š&ßTX} Ru•½Ó‰ş•ÍÔdRõïêŒ¦Ë	¡Ö'¦(4FJ~¡l7¿³¾úZª‘†ÃŠ[º{hºg²od8Xf#C…F^1Bf8ÌLİmˆp0óèµAÃaN¤Ø†‡~æŞ6g8cLpx†7È8*tb`ËÒQÆ:(ScË|†4Îp¼ué¨Q†Xb(üë¹V¿ÉsE§fÊ”H?=—Q+Á¥Ï§§W}TÒåRƒæŞ²Ã#3 nçÉß=¥édRÒ¸¥x”ÃÊcr/ä“I÷,:ïöõİ7ãH˜Š{k{–Šm×ÙVjô–·cº{ŒfcW¹lfÙA†İë¬÷›çD·ÚÒóÜ1¨)N2)Û)…‰WE>ÒªëØ7yÄ¤í–ÀòÇ&†/eDÙYAietç¨Ñåe$]¤|F†”.,*‹“Çú}¶«†-°ìWÒàNMLí›ZKÁ)K¯™zúg0¨áÓö‰éq€àÆÛä©Û6‚k°2:=5Hér2şû­î?(ª:sŒÏK~ÊñÏíK0n»©sd†ãÜÂf~J#fóëgß¸Óê¨äàUó¥B›9È§R0+—l·óãÓU£c¯´9›¹ÜhşÑ¼»Şn5®Ó£'K†úZAÛıO:›^`ïy²ş'ÏŸm¢û=—¦şiæÕÔyßk3ğä ëk>a×-LàØ.,¯»Ş¦õOöÑëŸş3'® çu_¦OD¯’(Ûèú48lğ¥ãâ;9³õ»[âì9ĞäQ°9q¸ÖºiÛàñvF&ğsİİÚh°ñ-ÊÜ7üãS~4^FğUqšYî~X˜ª¶ã¾ÇkBı4äÙ<­¾Å*OÆ÷Ó°•ŞM7ïıV:NôÒ‘õ³]móÓ©‡Cü¦Íø#C</¼÷îFÏ<í’Ùöÿ<ÎÜi/ÅÉE³WF­äF¢£Ææ¸óp¼†­O§¬kL8ØÜysŠÂa´›Ä xuuöH8±|,¹´{Rûß-‘¡Èï—,Sº<ò=1,;›ì±Ç;õsÄİÕéN{£èÊ¶ç9:®îvG7@>CönR'&¹i;Ïdw1^Ü\*Ş.X‡÷Í=ì!Ğdç’gÿX~r–s#^ËœÂ¯‡rps›<©‰Ô?¾O”•á·0`ñãØÑî;ƒ²SiÑX†ø~&¯9yééa‘AšJJŒÜI·™™vä¤•Í0>™PÄ±¿– zÇ™ùŠ;¶ÑÄñÏš9B®-Ÿ“×\G'mb‰•~>‚á)CSU˜’÷x<l=ç”*I9¿ ÈŠL¬stù9Ç?3¾l—ÿbq~ğroAİ}Ùg¬ŞbªnÉ Ãní X6òÁ˜¸ñ¿`Ëd+/Á‘lÆÂ·Ó1æcã—šù<ÎS[F–†çæLÚÃo¾¶kÃœ|LÒd0™˜­éY€uø.wõæôØje¥ •È§»VG“Ij¾—ÀùÙ·=ˆÃı€’4Ã¥G¶d˜Íi¨jÁø¤ÔÈĞË/¶{%¸•Öpİƒßè¾±~ìc8„/zïë!éÇ$¶yEá^-ÍêP³¨¹ôƒ´[Rmh©Ğ2]ÿ°™ş7ê‹ìáô±tÓÿÍâ]äN>Ç@SrIyÀs$æM¯õ|p¸’Üe§1Õ™õ 	ÎWì|Ü/X^“Äm|ÂFö|Å,FsGzu¦"ÙÛ/"å_>A{Œ–§„H˜¶®6W8Q³êÛÈá(-’Z¸yumx
ÔdçÌ€oÓà¾À5ÄŒPŠ0%kkwgpâ„râe¼øoc'ä¦_ªH ŞâÅÅ4·¦Ãïå¬ k5™vÜ-ÎL’Bã‡$@ImMî ïÇ#t^»…­ŠoI€7îyw+}låé>î&.UøÍ¾3Wf|:i“ëd> Am“Ğïj>üBn¸NæøŸ®Ä7Ü;¶M“qiÏ7‰ßeóòñ6“>Í;m·Ú|æÓ¶IÜæ“¸æ\3GÌ°ÔØæq·Ê3$½Ú|xSkfİsO&şÍQ?NŸùéïeŞO¦¾ÃÜ»Ë$Œ€Ğ•º•ÒĞM÷}¼õğßÖO–òç»Á‘à¶§ 5à±â£AoNn·2ƒYÿUnûı \¾Ó™KôN¿Í½Ä¯iÍ¾¬K5BíûÉhÛ¨ÒãdŒ}Ä¤öMeë${¹©tºÇş4øœ‘=ì©‘Is{¶qGÆõ¢šé<¶—Æ¯ìdJ7ƒ5ŞáU&ºÜ÷8ä'»_>—¾4yúÖXõò*RDùÌ¹¼Ùú[ÍÀØàFz¦z7Ü86v´ú„Ö‘-nÀ«sZèÆÀÙq!|¥ÓØÂBjT:
Œ©G½UğmÉG
ÚH,yd»ÓNñßÆë?=jÀš*_İD4çÁ*Kgzj=ìGÈëò7¨Şu¹§;T'¾/;ŞtVğ{ŞòøùGuk3}Kõùz(‘Rz‹68Ì‘‡ÖŞÛF¿Ö$²6şMBxÎ¡CZÜ	\á­d.has(path) || this._watched.has(fullPath);

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;

  // if the only watched file is removed, watch for its return
  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
    this.add(directory, item, true);
  }

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
  const wp = this._getWatchedDir(path);
  const nestedDirectoryChildren = wp.getChildren();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));

  // Check if item was on the watched list and remove it
  const parent = this._getWatchedDir(directory);
  const wasTracked = parent.has(item);
  parent.remove(item);

  // Fixes issue #1042 -> Relative paths were detected and added as symlinks
  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
  // but never removed from the map in case the path was deleted.
  // This leads to an incorrect state if the path was recreated:
  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
  if (this._symlinkPaths.has(fullPath)) {
    this._symlinkPaths.delete(fullPath);
  }

  // If we wait for this file to be fully written, cancel the wait.
  let relPath = path;
  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
    const event = this._pendingWrites.get(relPath).cancelWait();
    if (event === EV_ADD) return;
  }

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
  this._watched.delete(path);
  this._watched.delete(fullPath);
  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

  // Avoid conflicts if we later create another file with the same name
  if (!this.options.useFsEvents) {
    this._closePath(path);
  }
}

/**
 * Closes all watchers for a path
 * @param {Path} path
 */
_closePath(path) {
  this._closeFile(path)
  const dir = sysPath.dirname(path);
  this._getWatchedDir(dir).remove(sysPath.basename(path));
}

/**
 * Closes only file-specific watchers
 * @param {Path} path
 */
_closeFile(path) {
  const closers = this._closers.get(path);
  if (!closers) return;
  closers.forEach(closer => closer());
  this._closers.delete(path);
}

/**
 *
 * @param {Path} path
 * @param {Function} closer
 */
_addPathCloser(path, closer) {
  if (!closer) return;
  let list = this._closers.get(path);
  if (!list) {
    list = [];
    this._closers.set(path, list);
  }
  list.push(closer);
}

_readdirp(root, opts) {
  if (this.closed) return;
  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};
  let stream = readdirp(root, options);
  this._streams.add(stream);
  stream.once(STR_CLOSE, () => {
    stream = undefined;
  });
  stream.once(STR_END, () => {
    if (stream) {
      this._streams.delete(stream);
      stream = undefined;
    }
  });
  return stream;
}

}

// Export FSWatcher class
exports.FSWatcher = FSWatcher;

/**
 * Instantiates watcher with paths to be tracked.
 * @param {String|Array<String>} paths file/directory paths and/or globs
 * @param {Object=} options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */
const watch = (paths, options) => {
  const watcher = new FSWatcher(options);
  watcher.add(paths);
  return watcher;
};

exports.watch = watch;
