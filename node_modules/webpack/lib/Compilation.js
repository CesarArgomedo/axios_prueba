/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const asyncLib = require("neo-async");
const {
	HookMap,
	SyncHook,
	SyncBailHook,
	SyncWaterfallHook,
	AsyncSeriesHook,
	AsyncSeriesBailHook,
	AsyncParallelHook
} = require("tapable");
const util = require("util");
const { CachedSource } = require("webpack-sources");
const { MultiItemCache } = require("./CacheFacade");
const Chunk = require("./Chunk");
const ChunkGraph = require("./ChunkGraph");
const ChunkGroup = require("./ChunkGroup");
const ChunkRenderError = require("./ChunkRenderError");
const ChunkTemplate = require("./ChunkTemplate");
const CodeGenerationError = require("./CodeGenerationError");
const CodeGenerationResults = require("./CodeGenerationResults");
const Dependency = require("./Dependency");
const DependencyTemplates = require("./DependencyTemplates");
const Entrypoint = require("./Entrypoint");
const ErrorHelpers = require("./ErrorHelpers");
const FileSystemInfo = require("./FileSystemInfo");
const {
	connectChunkGroupAndChunk,
	connectChunkGroupParentAndChild
} = require("./GraphHelpers");
const {
	makeWebpackError,
	tryRunOrWebpackError
} = require("./HookWebpackError");
const MainTemplate = require("./MainTemplate");
const Module = require("./Module");
const ModuleDependencyError = require("./ModuleDependencyError");
const ModuleDependencyWarning = require("./ModuleDependencyWarning");
const ModuleGraph = require("./ModuleGraph");
const ModuleHashingError = require("./ModuleHashingError");
const ModuleNotFoundError = require("./ModuleNotFoundError");
const ModuleProfile = require("./ModuleProfile");
const ModuleRestoreError = require("./ModuleRestoreError");
const ModuleStoreError = require("./ModuleStoreError");
const ModuleTemplate = require("./ModuleTemplate");
const RuntimeGlobals = require("./RuntimeGlobals");
const RuntimeTemplate = require("./RuntimeTemplate");
const Stats = require("./Stats");
const WebpackError = require("./WebpackError");
const buildChunkGraph = require("./buildChunkGraph");
const BuildCycleError = require("./errors/BuildCycleError");
const { Logger, LogType } = require("./logging/Logger");
const StatsFactory = require("./stats/StatsFactory");
const StatsPrinter = require("./stats/StatsPrinter");
const { equals: arrayEquals } = require("./util/ArrayHelpers");
const AsyncQueue = require("./util/AsyncQueue");
const LazySet = require("./util/LazySet");
const { getOrInsert } = require("./util/MapHelpers");
const WeakTupleMap = require("./util/WeakTupleMap");
const { cachedCleverMerge } = require("./util/cleverMerge");
const {
	compareLocations,
	concatComparators,
	compareSelect,
	compareIds,
	compareStringsNumeric,
	compareModulesByIdentifier
} = require("./util/comparators");
const createHash = require("./util/createHash");
const {
	arrayToSetDeprecation,
	soonFrozenObjectDeprecation,
	createFakeHook
} = require("./util/deprecation");
const processAsyncTree = require("./util/processAsyncTree");
const { getRuntimeKey } = require("./util/runtime");
const { isSourceEqual } = require("./util/source");

/** @template T @typedef {import("tapable").AsArray<T>} AsArray<T> */
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../declarations/WebpackOptions").EntryDescriptionNormalized} EntryDescription */
/** @typedef {import("../declarations/WebpackOptions").OutputNormalized} OutputOptions */
/** @typedef {import("../declarations/WebpackOptions").StatsOptions} StatsOptions */
/** @typedef {import("../declarations/WebpackOptions").WebpackPluginFunction} WebpackPluginFunction */
/** @typedef {import("../declarations/WebpackOptions").WebpackPluginInstance} WebpackPluginInstance */
/** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("./Cache")} Cache */
/** @typedef {import("./CacheFacade")} CacheFacade */
/** @typedef {import("./ChunkGroup").ChunkGroupOptions} ChunkGroupOptions */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Compiler").CompilationParams} CompilationParams */
/** @typedef {import("./DependenciesBlock")} DependenciesBlock */
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("./DependencyTemplate")} DependencyTemplate */
/** @typedef {import("./Entrypoint").EntryOptions} EntryOptions */
/** @typedef {import("./Module").CodeGenerationResult} CodeGenerationResult */
/** @typedef {import("./ModuleFactory")} ModuleFactory */
/** @typedef {import("./ModuleFactory").ModuleFactoryCreateDataContextInfo} ModuleFactoryCreateDataContextInfo */
/** @typedef {import("./ModuleFactory").ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import("./RequestShortener")} RequestShortener */
/** @typedef {import("./RuntimeModule")} RuntimeModule */
/** @typedef {import("./Template").RenderManifestEntry} RenderManifestEntry */
/** @typedef {import("./Template").RenderManifestOptions} RenderManifestOptions */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsAsset} StatsAsset */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsError} StatsError */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsModule} StatsModule */
/** @typedef {import("./util/Hash")} Hash */
/** @template T @typedef {import("./util/deprecation").FakeHook<T>} FakeHook<T> */
/** @typedef {import("./util/runtime").RuntimeSpec} RuntimeSpec */

/**
 * @callback Callback
 * @param {(WebpackError | null)=} err
 * @returns {void}
 */

/**
 * @callback ModuleCallback
 * @param {(WebpackError | null)=} err
 * @param {Module=} result
 * @returns {void}
 */

/**
 * @callback ModuleFactoryResultCallback
 * @param {(WebpackError | null)=} err
 * @param {ModuleFactoryResult=} result
 * @returns {void}
 */

/**
 * @callback ModuleOrFactoryResultCallback
 * @param {(WebpackError | null)=} err
 * @param {Module | ModuleFactoryResult=} result
 * @returns {void}
 */

/**
 * @callback ExecuteModuleCallback
 * @param {(WebpackError | null)=} err
 * @param {ExecuteModuleResult=} result
 * @returns {void}
 */

/**
 * @callback DepBlockVarDependenciesCallback
 * @param {Dependency} dependency
 * @returns {any}
 */

/** @typedef {new (...args: any[]) => Dependency} DepConstructor */
/** @typedef {Record<string, Source>} CompilationAssets */

/**
 * @typedef {Object} AvailableModulesChunkGroupMapping
 * @property {ChunkGroup} chunkGroup
 * @property {Set<Module>} availableModules
 * @property {boolean} needCopy
 */

/**
 * @typedef {Object} DependenciesBlockLike
 * @property {Dependency[]} dependencies
 * @property {AsyncDependenciesBlock[]} blocks
 */

/**
 * @typedef {Object} ChunkPathData
 * @property {string|number} id
 * @property {string=} name
 * @property {string} hash
 * @property {function(number): string=} hashWithLength
 * @property {(Record<string, string>)=} contentHash
 * @property {(Record<string, (length: number) => string>)=} contentHashWithLength
 */

/**
 * @typedef {Object} ChunkHashContext
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 */

/**
 * @typedef {Object} RuntimeRequirementsContext
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults the code generation results
 */

/**
 * @typedef {Object} ExecuteModuleOptions
 * @property {EntryOptions=} entryOptions
 */

/**
 * @typedef {Object} ExecuteModuleResult
 * @property {any} exports
 * @property {boolean} cacheable
 * @property {Map<string, { source: Source, info: AssetInfo }>} assets
 * @property {LazySet<string>} fileDependencies
 * @property {LazySet<string>} contextDependencies
 * @property {LazySet<string>} missingDependencies
 * @property {LazySet<string>} buildDependencies
 */

/**
 * @typedef {Object} ExecuteModuleArgument
 * @property {Module} module
 * @property {{ id: string, exports: any, loaded: boolean }=} moduleObject
 * @property {any} preparedInfo
 * @property {CodeGenerationResult} codeGenerationResult
 */

/**
 * @typedef {Object} ExecuteModuleContext
 * @property {Map<string, { source: Source, info: AssetInfo }>} assets
 * @property {Chunk} chunk
 * @property {ChunkGraph} chunkGraph
 * @property {function(string): any=} __webpack_require__
 */

/**
 * @typedef {Object} EntryData
 * @property {Dependency[]} dependencies dependencies of the entrypoint that should be evaluated at startup
 * @property {Dependency[]} includeDependencies dependencies of the entrypoint that should be included but not evaluated
 * @property {EntryOptions} options options of the entrypoint
 */

/**
 * @typedef {Object} LogEntry
 * @property {string} type
 * @property {any[]} args
 * @property {number} time
 * @property {string[]=} trace
 */

/**
 * @typedef {Object} KnownAssetInfo
 * @property {boolean=} immutable true, if the asset can be long term cached forever (contains a hash)
 * @property {boolean=} minimized whether the asset is minimized
 * @property {string | string[]=} fullhash the value(s) of the full hash used for this asset
 * @property {string | string[]=} chunkhash the value(s) of the chunk hash used for this asset
 * @property {string | string[]=} modulehash the value(s) of the module hash used for this asset
 * @property {string | string[]=} contenthash the value(s) of the content hash used for this asset
 * @property {string=} sourceFilename when asset was created from a source file (potentially transformed), the original filename relative to compilation context
 * @property {number=} size size in bytes, only set after asset has been emitted
 * @property {boolean=} development true, when asset is only used for development and doesn't count towards user-facing assets
 * @property {boolean=} hotModuleReplacement true, when asset ships data for updating an existing application (HMR)
 * @property {boolean=} javascriptModule true, when asset is javascript and an ESM
 * @property {Record<string, string | string[]>=} related object of pointers to other assets, keyed by type of relation (only points from parent to child)
 */

/** @typedef {KnownAssetInfo & Record<string, any>} AssetInfo */

/**
 * @typedef {Object} Asset
 * @property {string} name the filename of the asset
 * @property {Source} source source of the asset
 * @property {AssetInfo} info info about the asset
 */

/**
 * @typedef {Object} ModulePathData
 * @property {string|number} id
 * @property {string} hash
 * @property {function(number): string=} hashWithLength
 */

/**
 * @typedef {Object} PathData
 * @property {ChunkGraph=} chunkGraph
 * @property {string=} hash
 * @property {function(number): string=} hashWithLength
 * @property {(Chunk|ChunkPathData)=} chunk
 * @property {(Module|ModulePathData)=} module
 * @property {RuntimeSpec=} runtime
 * @property {string=} filename
 * @property {string=} basename
 * @property {string=} query
 * @property {string=} contentHashType
 * @property {string=} contentHash
 * @property {function(number): string=} contentHashWithLength
 * @property {boolean=} noChunkHash
 * @property {string=} url
 */

/**
 * @typedef {Object} KnownNormalizedStatsOptions
 * @property {string} context
 * @property {RequestShortener} requestShortener
 * @property {string} chunksSort
 * @property {string} modulesSort
 * @property {string} chunkModulesSort
 * @property {string} nestedModulesSort
 * @property {string} assetsSort
 * @property {boolean} ids
 * @property {boolean} cachedAssets
 * @property {boolean} groupAssetsByEmitStatus
 * @property {boolean} groupAssetsByPath
 * @property {boolean} groupAssetsByExtension
 * @property {number} assetsSpace
 * @property {((value: string, asset: StatsAsset) => boolean)[]} excludeAssets
 * @property {((name: string, module: StatsModule, type: "module" | "chunk" | "root-of-chunk" | "nested") => boolean)[]} excludeModules
 * @property {((warning: StatsError, textValue: string) => boolean)[]} warningsFilter
 * @property {boolean} cachedModules
 * @property {boolean} orphanModules
 * @property {boolean} dependentModules
 * @property {boolean} runtimeModules
 * @property {boolean} groupModulesByCacheStatus
 * @property {boolean} groupModulesByLayer
 * @property {boolean} groupModulesByAttributes
 * @property {boolean} groupModulesByPath
 * @property {boolean} groupModulesByExtension
 * @property {boolean} groupModulesByType
 * @property {boolean | "auto"} entrypoints
 * @property {boolean} chunkGroups
 * @property {boolean} chunkGroupAuxiliary
 * @property {boolean} chunkGroupChildren
 * @property {number} chunkGroupMaxAssets
 * @property {number} modulesSpace
 * @property {number} chunkModulesSpace
 * @property {number} nestedModulesSpace
 * @property {false|"none"|"error"|"warn"|"info"|"log"|"verbose"} logging
 * @property {((value: string) => boolean)[]} loggingDebug
 * @property {boolean} loggingTrace
 * @property {any} _env
 */

/** @typedef {KnownNormalizedStatsOptions & Omit<StatsOptions, keyof KnownNormalizedStatsOptions> & Record<string, any>} NormalizedStatsOptions */

/**
 * @typedef {Object} KnownCreateStatsOptionsContext
 * @property {boolean=} forToString
 */

/** @typedef {KnownCreateStatsOptionsContext & Record<string, any>} CreateStatsOptionsContext */

/** @type {AssetInfo} */
const EMPTY_ASSET_INFO = Object.freeze({});

const esmDependencyCategory = "esm";
// TODO webpack 6: remove
const deprecatedNormalModuleLoaderHook = util.deprecate(
	compilation => {
		return require("./NormalModule").getCompilationHooks(compilation).loader;
	},
	"Compilation.hooks.normalModuleLoader was moved to NormalModule.getCompilationHooks(compilation).loader",
	"DEP_WEBPACK_COMPILATION_NORMAL_MODULE_LOADER_HOOK"
);

// TODO webpack 6: remove
const defineRemovedModuleTemplates = moduleTemplates => {
	Object.defineProperties(moduleTemplates, {
		asset: {
			enumerable: false,
			configurable: false,
			get: () => {
				throw new WebpackError(
					"Compilation.moduleTemplates.asset has been removed"
				);
			}
		},
		webassembly: {
			enumerable: false,
			configurable: false,
			get: () => {
				throw new WebpackError(
					"Compilation.moduleTemplates.webassembly has been removed"
				);
			}
		}
	});
	moduleTemplates = undefined;
};

const byId = compareSelect(
	/**
	 * @param {Chunk} c chunk
	 * @returns {number | string} id
	 */ c => c.id,
	compareIds
);

const byNameOrHash = concatComparators(
	compareSelect(
		/**
		 * @param {Compilation} c compilation
		 * @returns {string} name
		 */
		c => c.name,
		compareIds
	),
	compareSelect(
		/**
		 * @param {Compilation} c compilation
		 * @returns {string} hash
		 */ c => c.fullHash,
		compareIds
	)
);

const byMessage = compareSelect(err => `${err.message}`, compareStringsNumeric);

const byModule = compareSelect(
	err => (err.module && err.module.identifier()) || "",
	compareStringsNumeric
);

const byLocation = compareSelect(err => err.loc, compareLocations);

const compareErrors = concatComparators(byModule, byLocation, byMessage);

/** @type {WeakMap<Dependency, Module & { restoreFromUnsafeCache: Function } | null>} */
const unsafeCacheDependencies = new WeakMap();

/** @type {WeakMap<Module & { restoreFromUnsafeCache: Function }, object>} */
const unsafeCacheData = new WeakMap();

class Compilation {
	/**
	 * Creates an instance of Compilation.
	 * @param {Compiler} compiler the compiler which created the compilation
	 * @param {CompilationParams} params the compilation parameters
	 */
	constructor(compiler, params) {
		this._backCompat = compiler._backCompat;

		const getNormalModuleLoader = () => deprecatedNormalModuleLoaderHook(this);
		/** @typedef {{ additionalAssets?: true | Function }} ProcessAssetsAdditionalOptions */
		/** @type {AsyncSeriesHook<[CompilationAssets], ProcessAssetsAdditionalOptions>} */
		const processAssetsHook = new AsyncSeriesHook(["assets"]);

		let savedAssets = new Set();
		const popNewAssets = assets => {
			let newAssets = undefined;
			for (const file of Object.keys(assets)) {
				if (savedAssets.has(file)) continue;
				if (newAssets === undefined) {
					newAssets = Object.create(null);
				}
				newAssets[file] = assets[file];
				savedAssets.add(file);
			}
			return newAssets;
		};
		processAssetsHook.intercept({
			name: "Compilation",
			call: () => {
				savedAssets = new Set(Object.keys(this.assets));
			},
			register: tap => {
				const { type, name } = tap;
				const { fn, additionalAssets, ...remainingTap } = tap;
				const additionalAssetsFn =
					additionalAssets === true ? fn : additionalAssets;
				const processedAssets = additionalAssetsFn ? new WeakSet() : undefined;
				switch (type) {
					case "sync":
						if (additionalAssetsFn) {
							this.hooks.processAdditionalAssets.tap(name, assets => {
								if (processedAssets.has(this.assets))
									additionalAssetsFn(assets);
							});
						}
						return {
							...remainingTap,
							type: "async",
							fn: (assets, callback) => {
								try {
									fn(assets);
								} catch (e) {
									return callback(e);
								}
								if (processedAssets !== undefined)
									processedAssets.add(this.assets);
								const newAssets = popNewAssets(assets);
								if (newAssets !== undefined) {
									this.hooks.processAdditionalAssets.callAsync(
										newAssets,
										callback
									);
									return;
								}
								callback();
							}
						};
					case "async":
						if (additionalAssetsFn) {
							this.hooks.processAdditionalAssets.tapAsync(
								name,
								(assets, callback) => {
									if (processedAssets.has(this.assets))
										return additionalAssetsFn(assets, callback);
									callback();
								}
							);
						}
						return {
							...remainingTap,
							fn: (assets, callback) => {
								fn(assets, err => {
									if (err) return callback(err);
									if (processedAssets !== undefined)
										processedAssets.add(this.assets);
									const newAssets = popNewAssets(assets);
									if (newAssets !== undefined) {
										this.hooks.processAdditionalAssets.callAsync(
											newAssets,
											callback
										);
										return;
									}
									callback();
								});
							}
						};
					case "promise":
						if (additionalAssetsFn) {
							this.hooks.processAdditionalAssets.tapPromise(name, assets => {
								if (processedAssets.has(this.assets))
									return additionalAssetsFn(assets);
								return Promise.resolve();
							});
						}
						return {
							...remainingTap,
							fn: assets => {
								const p = fn(assets);
								if (!p || !p.then) return p;
								return p.then(() => {
									if (processedAssets !== undefined)
										processedAssets.add(this.assets);
									const newAssets = popNewAssets(assets);
									if (newAssets !== undefined) {
										return this.hooks.processAdditionalAssets.promise(
											newAssets
										);
									}
								});
							}
						};
				}
			}
		});

		/** @type {SyncHook<[CompilationAssets]>} */
		const afterProcessAssetsHook = new SyncHook(["assets"]);

		/**
		 * @template T
		 * @param {string} name name of the hook
		 * @param {number} stage new stage
		 * @param {function(): AsArray<T>} getArgs get old hook function args
		 * @param {string=} code deprecation code (not deprecated when unset)
		 * @returns {FakeHook<Pick<AsyncSeriesHook<T>, "tap" | "tapAsync" | "tapPromise" | "name">>} fake hook which redirects
		 */
		const createProcessAssetsHook = (name, stage, getArgs, code) => {
			if (!this._backCompat && code) return undefined;
			const errorMessage =
				reason => `Can't automatically convert plugin using Compilation.hooks.${name} to Compilation.hooks.processAssets because ${reason}.
BREAKING CHANGE: Asset processing hooks in Compilation has been merged into a single Compilation.hooks.processAssets hook.`;
			const getOptions = options => {
				if (typeof options === "string") options = { name: options };
				if (options.stage) {
					throw new Error(errorMessage("it's using the 'stage' option"));
				}
				return { ...options, stage: stage };
			};
			return createFakeHook(
				{
					name,
					/** @type {AsyncSeriesHook<T>["intercept"]} */
					intercept(interceptor) {
						throw new Error(errorMessage("it's using 'intercept'"));
					},
					/** @type {AsyncSeriesHook<T>["tap"]} */
					tap: (options, fn) => {
						processAssetsHook.tap(getOptions(options), () => fn(...getArgs()));
					},
					/** @type {AsyncSeriesHook<T>["tapAsync"]} */
					tapAsync: (options, fn) => {
						processAssetsHook.tapAsync(
							getOptions(options),
							(assets, callback) =>
								/** @type {any} */ (fn)(...getArgs(), callback)
						);
					},
					/** @type {AsyncSeriesHook<T>["tapPromise"]} */
					tapPromise: (options, fn) => {
						processAssetsHook.tapPromise(getOptions(options), () =>
							fn(...getArgs())
						);
					}
				},
				`${name} is deprecated (use Compilation.hooks.processAssets instead and use one of Compilation.PROCESS_ASSETS_STAGE_* as stage option)`,
				code
			);
		};
		this.hooks = Object.freeze({
			/** @type {SyncHook<[Module]>} */
			buildModule: new SyncHook(["module"]),
			/** @type {SyncHook<[Module]>} */
			rebuildModule: new SyncHook(["module"]),
			/** @type {SyncHook<[Module, WebpackError]>} */
			failedModule: new SyncHook(["module", "error"]),
			/** @type {SyncHook<[Module]>} */
			succeedModule: new SyncHook(["module"]),
			/** @type {SyncHook<[Module]>} */
			stillValidModule: new SyncHook(["module"]),

			/** @type {SyncHook<[Dependency, EntryOptions]>} */
			addEntry: new SyncHook(["entry", "options"]),
			/** @type {SyncHook<[Dependency, EntryOptions, Error]>} */
			failedEntry: new SyncHook(["entry", "options", "error"]),
			/** @type {SyncHook<[Dependency, EntryOptions, Module]>} */
			succeedEntry: new SyncHook(["entry", "options", "module"]),

			/** @type {SyncWaterfallHook<[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]>} */
			dependencyReferencedExports: new SyncWaterfallHook([
				"referencedExports",
				"dependency",
				"runtime"
			]),

			/** @type {SyncHook<[ExecuteModuleArgument, ExecuteModuleContext]>} */
			executeModule: new SyncHook(["options", "context"]),
			/** @type {AsyncParallelHook<[ExecuteModuleArgument, ExecuteModuleContext]>} */
			prepareModuleExecution: new AsyncParallelHook(["options", "context"]),

			/** @type {AsyncSeriesHook<[Iterable<Module>]>} */
			finishModules: new AsyncSeriesHook(["modules"]),
			/** @type {AsyncSeriesHook<[Module]>} */
			finishRebuildingModule: new AsyncSeriesHook(["module"]),
			/** @type {SyncHook<[]>} */
			unseal: new SyncHook([]),
			/** @type {SyncHook<[]>} */
			seal: new SyncHook([]),

			/** @type {SyncHook<[]>} */
			beforeChunks: new SyncHook([]),
			/** @type {SyncHook<[Iterable<Chunk>]>} */
			afterChunks: new SyncHook(["chunks"]),

			/** @type {SyncBailHook<[Iterable<Module>]>} */
			optimizeDependencies: new SyncBailHook(["modules"]),
			/** @type {SyncHook<[Iterable<Module>]>} */
			afterOptimizeDependencies: new SyncHook(["modules"]),

			/** @type {SyncHook<[]>} */
			optimize: new SyncHook([]),
			/** @type {SyncBailHook<[Iterable<Module>]>} */
			optimizeModules: new SyncBailHook(["modules"]),
			/** @type {SyncHook<[Iterable<Module>]>} */
			afterOptimizeModules: new SyncHook(["modules"]),

			/** @type {SyncBailHook<[Iterable<Chunk>, ChunkGroup[]]>} */
			optimizeChunks: new SyncBailHook(["chunks", "chunkGroups"]),
			/** @type {SyncHook<[Iterable<Chunk>, ChunkGroup[]]>} */
			afterOptimizeChunks: new SyncHook(["chunks", "chunkGroups"]),

			/** @type {AsyncSeriesHook<[Iterable<Chunk>, Iterable<Module>]>} */
			optimizeTree: new AsyncSeriesHook(["chunks", "modules"]),
			/** @type {SyncHook<[Iterable<Chunk>, Iterable<Module>]>} */
			afterOptimizeTree: new SyncHook(["chunks", "modules"]),

			/** @type {AsyncSeriesBailHook<[Iterable<Chunk>, Iterable<Module>]>} */
			optimizeChunkModules: new AsyncSeriesBailHook(["chunks", "modules"]),
			/** @type {SyncHook<[Iterable<Chunk>, Iterable<Module>]>} */
			afterOptimizeChunkModules: new SyncHook(["chunks", "modules"]),
			/** @type {SyncBailHook<[], boolean>} */
			shouldRecord: new SyncBailHook([]),

			/** @type {SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>} */
			additionalChunkRuntimeRequirements: new SyncHook([
				"chunk",
				"runtimeRequirements",
				"context"
			]),
			/** @type {HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext]>>} */
			runtimeRequirementInChunk: new HookMap(
				() => new SyncBailHook(["chunk", "runtimeRequirements", "context"])
			),
			/** @type {SyncHook<[Module, Set<string>, RuntimeRequirementsContext]>} */
			additionalModuleRuntimeRequirements: new SyncHook([
				"module",
				"runtimeRequirements",
				"context"
			]),
			/** @type {HookMap<SyncBailHook<[Module, Set<string>, RuntimeRequirementsContext]>>} */
			runtimeRequirementInModule: new HookMap(
				() => new SyncBailHook(["module", "runtimeRequirements", "context"])
			),
			/** @type {SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>} */
			additionalTreeRuntimeRequirements: new SyncHook([
				"chunk",
				"runtimeRequirements",
				"context"
			]),
			/** @type {HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext]>>} */
			runtimeRequirementInTree: new HookMap(
				() => new SyncBailHook(["chunk", "runtimeRequirements", "context"])
			),

			/** @type {SyncHook<[RuntimeModule, Chunk]>} */
			runtimeModule: new SyncHook(["module", "chunk"]),

			/** @type {SyncHook<[Iterable<Module>, any]>} */
			reviveModules: new SyncHook(["modules", "records"]),
			/** @type {SyncHook<[Iterable<Module>]>} */
			beforeModuleIds: new SyncHook(["modules"]),
			/** @type {SyncHook<[Iterable<Module>]>} */
			moduleIds: new SyncHook(["modules"]),
			/** @type {SyncHook<[Iterable<Module>]>} */
			optimizeModuleIds: new SyncHook(["modules"]),
			/** @type {SyncHook<[Iterable<Module>]>} */
			afterOptimizeModuleIds: new SyncHook(["modules"]),

			/** @type {SyncHook<[Iterable<Chunk>, any]>} */
			reviveChunks: new SyncHook(["chunks", "records"]),
			/** @type {SyncHook<[Iterable<Chunk>]>} */
			beforeChunkIds: new SyncHook(["chunks"]),
			/** @type {SyncHook<[Iterable<Chunk>]>} */
			chunkIds: new SyncHook(["chunks"]),
			/** @type {SyncHook<[Iterable<Chunk>]>} */
			optimizeChunkIds: new SyncHook(["chunks"]),
			/** @type {SyncHook<[Iterable<Chunk>]>} */
			afterOptimizeChunkIds: new SyncHook(["chunks"]),

			/** @type {SyncHook<[Iterable<Module>, any]>} */
			recordModules: new SyncHook(["modules", "records"]),
			/** @type {SyncHook<[Iterable<Chunk>, any]>} */
			recordChunks: new SyncHook(["chunks", "records"]),

			/** @type {SyncHook<[Iterable<Module>]>} */
			optimizeCodeGeneration: new SyncHook(["modules"]),

			/** @type {SyncHook<[]>} */
			beforeModuleHash: new SyncHook([]),
			/** @type {SyncHook<[]>} */
			afterModuleHash: new SyncHook([]),

			/** @type {SyncHook<[]>} */
			beforeCodeGeneration: new SyncHook([]),
			/** @type {SyncHook<[]>} */
			afterCodeGeneration: new SyncHook([]),

			/** @type {SyncHook<[]>} */
			beforeRuntimeRequirements: new SyncHook([]),
			/** @type {SyncHook<[]>} */
			afterRuntimeRequirements: new SyncHook([]),

			/** @type {SyncHook<[]>} */
			beforeHash: new SyncHook([]),
			/** @type {SyncHook<[Chunk]>} */
			contentHash: new SyncHook(["chunk"]),
			/** @type {SyncHook<[]>} */
			afterHash: new SyncHook([]),
			/** @type {SyncHook<[any]>} */
			recordHash: new SyncHook(["records"]),
			/** @type {SyncHook<[Compilation, any]>} */
			record: new SyncHook(["compilation", "records"]),

			/** @type {SyncHook<[]>} */
			beforeModuleAssets: new SyncHook([]),
			/** @type {SyncBailHook<[], boolean>} */
			shouldGenerateChunkAssets: new SyncBailHook([]),
			/** @type {SyncHook<[]>} */
			beforeChunkAssets: new SyncHook([]),
			// TODO webpack 6 remove
			/** @deprecated */
			additionalChunkAssets: createProcessAssetsHook(
				"additionalChunkAssets",
				Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL,
				() => [this.chunks],
				"DEP_WEBPACK_COMPILATION_ADDITIONAL_CHUNK_ASSETS"
			),

			// TODO webpack 6 deprecate
			/** @deprecated */
			additionalAssets: createProcessAssetsHook(
				"additionalAssets",
				Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL,
				() => []
			),
			// TODO webpack 6 remove
			/** @deprecated */
			optimizeChunkAssets: createProcessAssetsHook(
				"optimizeChunkAssets",
				Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE,
				() => [this.chunks],
				"DEP_WEBPACK_COMPILATION_OPTIMIZE_CHUNK_ASSETS"
			),
			// TODO webpack 6 remove
			/** @deprecated */
			afterOptimizeChunkAssets: createProcessAssetsHook(
				"afterOptimizeChunkAssets",
				Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE + 1,
				() => [this.chunks],
				"DEP_WEBPACK_COMPILATION_AFTER_OPTIMIZE_CHUNK_ASSETS"
			),
			// TODO webpack 6 deprecate
			/** @deprecated */
			optimizeAssets: processAssetsHook,
			// TODO webpack 6 deprecate
			/** @deprecated */
			afterOptimizeAssets: afterProcessAssetsHook,

			processAssets: processAssetsHook,
			afterProcessAssets: afterProcessAssetsHook,
			/** @type {AsyncSeriesHook<[CompilationAssets]>} */
			processAdditionalAssets: new AsyncSeriesHook(["assets"]),

			/** @type {SyncBailHook<[], boolean>} */
			needAdditionalSeal: new SyncBailHook([]),
			/** @type {AsyncSeriesHook<[]>} */
			afterSeal: new AsyncSeriesHook([]),

			/** @type {SyncWaterfallHook<[RenderManifestEntry[], RenderManifestOptions]>} */
			renderManifest: new SyncWaterfallHook(["result", "options"]),

			/** @type {SyncHook<[Hash]>} */
			fullHash: new SyncHook(["hash"]),
			/** @type {SyncHook<[Chunk, Hash, ChunkHashContext]>} */
			chunkHash: new SyncHook(["chunk", "chunkHash", "ChunkHashContext"]),

			/** @type {SyncHook<[Module, string]>} */
			moduleAsset: new SyncHook(["module", "filename"]),
			/** @type {SyncHook<[Chunk, string]>} */
			chunkAsset: new SyncHook(["chunk", "filename"]),

			/** @type {SyncWaterfallHook<[string, object, AssetInfo]>} */
			assetPath: new SyncWaterfallHook(["path", "options", "assetInfo"]),

			/** @type {SyncBailHook<[], boolean>} */
			needAdditionalPass: new SyncBailHook([]),

			/** @type {SyncHook<[Compiler, string, number]>} */
			childCompiler: new SyncHook([
				"childCompiler",
				"compilerName",
				"compilerIndex"
			]),

			/** @type {SyncBailHook<[string, LogEntry], true>} */
			log: new SyncBailHook(["origin", "logEntry"]),

			/** @type {SyncWaterfallHook<[WebpackError[]]>} */
			processWarnings: new SyncWaterfallHook(["warnings"]),
			/** @type {SyncWaterfallHook<[WebpackError[]]>} */
			processErrors: new SyncWaterfallHook(["errors"]),

			/** @type {HookMap<SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>>} */
			statsPreset: new HookMap(() => new SyncHook(["options", "context"])),
			/** @type {SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>} */
			statsNormalize: new SyncHook(["options", "context"]),
			/** @type {SyncHook<[StatsFactory, NormalizedStatsOptions]>} */
			statsFactory: new SyncHook(["statsFactory", "options"]),
			/** @type {SyncHook<[StatsPrinter, NormalizedStatsOptions]>} */
			statsPrinter: new SyncHook(["statsPrinter", "options"]),

			get normalModuleLoader() {
				return getNormalModuleLoader();
			}
		});
		/** @type {string=} */
		this.name = undefined;
		this.startTime = undefined;
		this.endTime = undefined;
		/** @type {Compiler} */
		this.compiler = compiler;
		this.resolverFactory = compiler.resolverFactory;
		this.inputFileSystem = compiler.inputFileSystem;
		this.fileSystemInfo = new FileSystemInfo(this.inputFileSystem, {
			managedPaths: compiler.managedPaths,
			immutablePaths: compiler.immutablePaths,
			logger: this.getLogger("webpack.FileSystemInfo"),
			hashFunction: compiler.options.output.hashFunction
		});
		if (compiler.fileTimestamps) {
			this.fileSystemInfo.addFileTimestamps(compiler.fileTimestamps, true);
		}
		if (compiler.contextTimestamps) {
			this.fileSystemInfo.addContextTimestamps(
				compiler.contextTimestamps,
				true
			);
		}
		/** @type {Map<string, string | Set<string>>} */
		this.valueCacheVersions = new Map();
		this.requestShortener = compiler.requestShortener;
		this.compilerPath = compiler.compilerPath;

		this.logger = this.getLogger("webpack.Compilation");

		const options = compiler.options;
		this.options = options;
		this.outputOptions = options && options.output;
		/** @type {boolean} */
		this.bail = (options && options.bail) || false;
		/** @type {boolean} */
		this.profile = (options && options.profile) || false;

		this.params = params;
		this.mainTemplate = new MainTemplate(this.outputOptions, this);
		this.chunkTemplate = new ChunkTemplate(this.outputOptions, this);
		this.runtimeTemplate = new RuntimeTemplate(
			this,
			this.outputOptions,
			this.requestShortener
		);
		/** @type {{javascript: ModuleTemplate}} */
		this.moduleTemplates = {
			javascript: new ModuleTemplate(this.runtimeTemplate, this)
		};
		defineRemovedModuleTemplates(this.moduleTemplates);

		/** @type {Map<Module, WeakTupleMap<any, any>> | undefined} */
		this.moduleMemCaches = undefined;
		/** @type {Map<Module, WeakTupleMap<any, any>> | undefined} */
		this.moduleMemCaches2 = undefined;
		this.moduleGraph = new ModuleGraph();
		/** @type {ChunkGraph} */
		this.chunkGraph = undefined;
		/** @type {CodeGenerationResults} */
		this.codeGenerationResults = undefined;

		/** @type {AsyncQueue<Module, Module, Module>} */
		this.processDependenciesQueue = new AsyncQueue({
			name: "processDependencies",
			parallelism: options.parallelism || 100,
			processor: this._processModuleDependencies.bind(this)
		});
		/** @type {AsyncQueue<Module, string, Module>} */
		this.addModuleQueue = new AsyncQueue({
			name: "addModule",
			parent: this.processDependenciesQueue,
			getKey: module => module.identifier(),
			processor: this._addModule.bind(this)
		});
		/** @type {AsyncQueue<FactorizeModuleOptions, string, Module | ModuleFactoryResult>} */
		this.factorizeQueue = new AsyncQueue({
			name: "factorize",
			parent: this.addModuleQueue,
			processor: this._factorizeModule.bind(this)
		});
		/** @type {AsyncQueue<Module, Module, Module>} */
		this.buildQueue = new AsyncQueue({
			name: "build",
			parent: this.factorizeQueue,
			processor: this._buildModule.bind(this)
		});
		/** @type {AsyncQueue<Module, Module, Module>} */
		this.rebuildQueue = new AsyncQueue({
			name: "rebuild",
			parallelism: options.parallelism || 100,
			processor: this._rebuildModule.bind(this)
		});

		/**
		 * Modules in value are building during the build of Module in key.
		 * Means value blocking key from finishing.
		 * Needed to detect build cycles.
		 * @type {WeakMap<Module, Set<Module>>}
		 */
		this.creatingModuleDuringBuild = new WeakMap();

		/** @type {Map<string, EntryData>} */
		this.entries = new Map();
		/** @type {EntryData} */
		this.globalEntry = {
			dependencies: [],
			includeDependencies: [],
			options: {
				name: undefined
			}
		};
		/** @type {Map<string, Entrypoint>} */
		this.entrypoints = new Map();
		/** @type {Entrypoint[]} */
		this.asyncEntrypoints = [];
		/** @type {Set<Chunk>} */
		this.chunks = new Set();
		/** @type {ChunkGroup[]} */
		this.chunkGroups = [];
		/** @type {Map<string, ChunkGroup>} */
		this.namedChunkGroups = new Map();
		/** @type {Map<string, Chunk>} */
		this.namedChunks = new Map();
		/** @type {Set<Module>} */
		this.modules = new Set();
		if (this._backCompat) {
			arrayToSetDeprecation(this.chunks, "Compilation.chunks");
			arrayToSetDeprecation(this.modules, "Compilation.modules");
		}
		/** @private @type {Map<string, Module>} */
		this._modules = new Map();
		this.records = null;
		/** @type {string[]} */
		this.additionalChunkAssets = [];
		/** @type {CompilationAssets} */
		this.assets = {};
		/** @type {Map<string, AssetInfo>} */
		this.assetsInfo = new Map();
		/** @type {Map<string, Map<string, Set<string>>>} */
		this._assetsRelatedIn = new Map();
		/** @type {WebpackError[]} */
		this.errors = [];
		/** @type {WebpackError[]} */
		this.warnings = [];
		/** @type {Compilation[]} */
		this.children = [];
		/** @type {Map<string, LogEntry[]>} */
		this.logging = new Map();
		/** @type {Map<DepConstructor, ModuleFactory>} */
		this.dependencyFactories = new Map();
		/** @type {DependencyTemplates} */
		this.dependencyTemplates = new DependencyTemplates(
			this.outputOptions.hashFunction
		);
		this.childrenCounters = {};
		/** @type {Set<number|string>} */
		this.usedChunkIds = null;
		/** @type {Set<number>} */
		this.usedModuleIds = null;
		/** @type {boolean} */
		this.needAdditionalPass = false;
		/** @type {Set<Module & { restoreFromUnsafeCache: Function }>} */
		this._restoredUnsafeCacheModuleEntries = new Set();
		/** @type {Map<string, Module & { restoreFromUnsafeCache: Function }>} */
		this._restoredUnsafeCacheEntries = new Map();
		/** @type {WeakSet<Module>} */
		this.builtModules = new WeakSet();
		/** @type {WeakSet<Module>} */
		this.codeGeneratedModules = new WeakSet();
		/** @type {WeakSet<Module>} */
		this.buildTimeExecutedModules = new WeakSet();
		/** @private @type {Map<Module, Callback[]>} */
		this._rebuildingModules = new Map();
		/** @type {Set<string>} */
		this.emittedAssets = new Set();
		/** @type {Set<string>} */
		this.comparedForEmitAssets = new Set();
		/** @type {LazySet<string>} */
		this.fileDependencies = new LazySet();
		/** @type {LazySet<string>} */
		this.contextDependencies = new LazySet();
		/** @type {LazySet<string>} */
		this.missingDependencies = new LazySet();
		/** @type {LazySet<string>} */
		this.buildDependencies = new LazySet();
		// TODO webpack 6 remove
		this.compilationDependencies = {
			add: util.deprecate(
				item => this.fileDependencies.add(item),
				"Compilation.compilationDependencies is deprecated (used Compilation.fileDependencies instead)",
				"DEP_WEBPACK_COMPILATION_COMPILATION_DEPENDENCIES"
			)
		};

		this._modulesCache = this.getCache("Compilation/modules");
		this._assetsCache = this.getCache("Compilation/assets");
		this._codeGenerationCache = this.getCache("Compilation/codeGeneration");

		const unsafeCache = options.module.unsafeCache;
		this._unsafeCache = !!unsafeCache;
		this._unsafeCachePredicate =
			typeof unsafeCache === "function" ? unsafeCache : () => true;
	}

	getStats() {
		return new Stats(this);
	}

	/**
	 * @param {StatsOptions | string} optionsOrPreset stats option value
	 * @param {CreateStatsOptionsContext} context context
	 * @returns {NormalizedStatsOptions} normalized options
	 */
	createStatsOptions(optionsOrPreset, context = {}) {
		if (
			typeof optionsOrPreset === "boolean" ||
			typeof optionsOrPreset === "string"
		) {
			optionsOrPreset = { preset: optionsOrPreset };
		}
		if (typeof optionsOrPreset === "object" && optionsOrPreset !== null) {
			// We use this method of shallow cloning this object to include
			// properties in the prototype chain
			/** @type {Partial<NormalizedStatsOptions>} */
			const options = {};
			for (const key in optionsOrPreset) {
				options[key] = optionsOrPreset[key];
			}
			if (options.preset !== undefined) {
				this.hooks.statsPreset.for(options.preset).call(options, context);
			}
			this.hooks.statsNormalize.call(options, context);
			return /** @type {NormalizedStatsOptions} */ (options);
		} else {
			/** @type {Partial<NormalizedStatsOptions>} */
			const options = {};
			this.hooks.statsNormalize.call(options, context);
			return /** @type {NormalizedStatsOptions} */ (options);
		}
	}

	createStatsFactory(options) {
		const statsFactory = new StatsFactory();
		this.hooks.statsFactory.call(statsFactory, options);
		return statsFactory;
	}

	createStatsPrinter(options) {
		const statsPrinter = new StatsPrinter();
		this.hooks.statsPrinter.call(statsPrinter, options);
		return statsPrinter;
	}

	/**
	 * @param {string} name cache name
	 * @returns {CacheFacade} the cache facade instance
	 */
	getCache(name) {
		return this.compiler.getCache(name);
	}

	/**
	 * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name
	 * @returns {Logger} a logger with that name
	 */
	getLogger(name) {
		if (!name) {
			throw new TypeError("Compilation.getLogger(name) called without a name");
		}
		/** @type {LogEntry[] | undefined} */
		let logEntries;
		return new Logger(
			(type, args) => {
				if (typeof name === "function") {
					name = name();
					if (!name) {
						throw new TypeError(
							"Compilation.getLogger(name) called with a function not returning a name"
						);
					}
				}
				let trace;
				switch (type) {
					case LogType.warn:
					case LogType.error:
					case LogType.trace:
						trace = ErrorHelpers.cutOffLoaderExecution(new Error("Trace").stack)
							.split("\n")
							.slice(3);
						break;
				}
				/** @type {LogEntry} */
				const logEntry = {
					time: Date.now(),
					type,
					args,
					trace
				};
				if (this.hooks.log.call(name, logEntry) === undefined) {
					if (logEntry.type === LogType.profileEnd) {
						// eslint-disable-next-line node/no-unsupported-features/node-builtins
						if (typeof console.profileEnd === "function") {
							// eslint-disable-next-line node/no-unsupported-features/node-builtins
							console.profileEnd(`[${name}] ${logEntry.args[0]}`);
						}
					}
					if (logEntries === undefined) {
						logEntries = this.logging.get(name);
						if (logEntries === undefined) {
							logEntries = [];
							this.logging.set(name, logEntries);
						}
					}
					logEntries.push(logEntry);
					if (logEntry.type === LogType.profile) {
						// eslint-disable-next-line node/no-unsupported-features/node-builtins
						if (typeof console.profile === "function") {
							// eslint-disable-next-line node/no-unsupported-features/node-builtins
							console.profile(`[${name}] ${logEntry.args[0]}`);
						}
					}
				}
			},
			childName => {
				if (typeof name === "function") {
					if (typeof childName === "function") {
						return this.getLogger(() => {
							if (typeof name === "function") {
								name = name();
								if (!name) {
									throw new TypeError(
										"Compilation.getLogger(name) called with a function not returning a name"
									);
								}
							}
							if (typeof childName === "function") {
								childName = childName();
								if (!childName) {
									throw new TypeError(
										"Logger.getChildLogger(name) called with a function not returning a name"
									);
								}
							}
							return `${name}/${childName}`;
						});
					} else {
						return this.getLogger(() => {
							if (typeof name === "function") {
								name = name();
								if (!name) {
									throw new TypeError(
										"Compilation.getLogger(name) called with a function not returning a name"
									);
								}
							}
							return `${name}/${childName}`;
						});
					}
				} else {
					if (typeof childName === "function") {
						return this.getLogger(() => {
							if (typeof childName === "function") {
								childName = childName();
								if (!childName) {
									throw new TypeError(
										"Logger.getChildLogger(name) called with a function not returning a name"
									);
								}
							}
							return `${name}/${childName}`;
						});
					} else {
						return this.getLogger(`${name}/${childName}`);
					}
				}
			}
		);
	}

	/**
	 * @param {Module} module module to be added that was created
	 * @param {ModuleCallback} callback returns the module in the compilation,
	 * it could be the passed one (if new), or an already existing in the compilation
	 * @returns {void}
	 */
	addModule(module, callback) {
		this.addModuleQueue.add(module, callback);
	}

	/**
	 * @param {Module} module module to be added that was created
	 * @param {ModuleCallback} callback returns the module in the compilation,
	 * it could be the passed one (if new), or an already existing in the compilation
	 * @returns {void}
	 */
	_addModule(module, callback) {
		const identifier = module.identifier();
		const alreadyAddedModule = this._modules.get(identifier);
		if (alreadyAddedModule) {
			return callback(null, alreadyAddedModule);
		}

		const currentProfile = this.profile
			? this.moduleGraph.getProfile(module)
			: undefined;
		if (currentProfile !== undefined) {
			currentProfile.markRestoringStart();
		}

		this._modulesCache.get(identifier, null, (err, cacheModule) => {
			if (err) return callback(new ModuleRestoreError(module, err));

			if (currentProfile !== undefined) {
				currentProfile.markRestoringEnd();
				currentProfile.markIntegrationStart();
			}

			if (cacheModule) {
				cacheModule.updateCacheModule(module);

				module = cacheModule;
			}
			this._modules.set(identifier, module);
			this.modules.add(module);
			if (this._backCompat)
				ModuleGraph.setModuleGraphForModule(module, this.moduleGraph);
			if (currentProfile !== undefined) {
				currentProfile.markIntegrationEnd();
			}
			callback(null, module);
		});
	}

	/**
	 * Fetches a module from a compilation by its identifier
	 * @param {Module} module the module provided
	 * @returns {Module} the module requested
	 */
	getModule(module) {
		const identifier = module.identifier();
		return this._modules.get(identifier);
	}

	/**
	 * Attempts to search for a module by its identifier
	 * @param {string} identifier identifier (usually path) for module
	 * @returns {Module|undefined} attempt to search for module and return it, else undefined
	 */
	findModule(identifier) {
		return this._modules.get(identifier);
	}

	/**
	 * Schedules a build of the module object
	 *
	 * @param {Module} module module to be built
	 * @param {ModuleCallback} callback the callback
	 * @returns {void}
	 */
	buildModule(module, callback) {
		this.buildQueue.add(module, callback);
	}

	/**
	 * Builds the module object
	 *
	 * @param {Module} module module to be built
	 * @param {ModuleCallback} callback the callback
	 * @returns {void}
	 */
	_buildModule(module, callback) {
		const currentProfile = this.profile
			? this.moduleGraph.getProfile(module)
			: undefined;
		if (currentProfile !== undefined) {
			currentProfile.markBuildingStart();
		}

		module.needBuild(
			{
				compilation: this,
				fileSystemInfo: this.fileSystemInfo,
				valueCacheVersions: this.valueCacheVersions
			},
			(err, needBuild) => {
				if (err) return callback(err);

				if (!needBuild) {
					if (currentProfile !== undefined) {
						currentProfile.markBuildingEnd();
					}
					this.hooks.stillValidModule.call(module);
					return callback();
				}

				this.hooks.buildModule.call(module);
				this.builtModules.add(module);
				module.build(
					this.options,
					this,
					this.resolverFactory.get("normal", module.resolveOptions),
					this.inputFileSystem,
					err => {
						if (currentProfile !== undefined) {
							currentProfile.markBuildingEnd();
						}
						if (err) {
							this.hooks.failedModule.call(module, err);
							return callback(err);
						}
						if (currentProfile !== undefined) {
							currentProfile.markStoringStart();
						}
						this._modulesCache.store(module.identifier(), null, module, err => {
							if (currentProfile !== undefined) {
								currentProfile.markStoringEnd();
							}
							if (err) {
								this.hooks.failedModule.call(module, err);
								return callback(new ModuleStoreError(module, err));
							}
							this.hooks.succeedModule.call(module);
							return callback();
						});
					}
				);
			}
		);
	}

	/**
	 * @param {Module} module to be processed for deps
	 * @param {ModuleCallback} callback callback to be triggered
	 * @returns {void}
	 */
	processModuleDependencies(module, callback) {
		this.processDependenciesQueue.add(module, callback);
	}

	/**
	 * @param {Module} module to be processed for deps
	 * @returns {void}
	 */
	processModuleDependenciesNonRecursive(module) {
		const processDependenciesBlock = block => {
			if (block.dependencies) {
				let i = 0;
				for (const dep of block.dependencies) {
					this.moduleGraph.setParents(dep, block, module, i++);
				}
			}
			if (block.blocks) {
				for (const b of block.blocks) processDependenciesBlock(b);
			}
		};

		processDependenciesBlock(module);
	}

	/**
	 * @param {Module} module to be processed for deps
	 * @param {ModuleCallback} callback callback to be triggered
	 * @returns {void}
	 */
	_processModuleDependencies(module, callback) {
		/** @type {Array<{factory: ModuleFactory, dependencies: Dependency[], context: string|undefined, originModule: Module|null}>} */
		const sortedDependencies = [];

		/** @type {DependenciesBlock} */
		let currentBlock;

		/** @type {Map<ModuleFactory, Map<string, Dependency[]>>} */
		let dependencies;
		/** @type {DepConstructor} */
		let factoryCacheKey;
		/** @type {ModuleFactory} */
		let factoryCacheKey2;
		/** @type {Map<string, Dependency[]>} */
		let factoryÀÉB.ßÅ¸ojÂ≤ÒzÂbë\ÆÊ⁄É≤˘@»o4}8ílæ,d”.ÌK≤C◊ ‚…Á»ßﬁpùyÒ∫ f"∞U©ÈŒ≥Œù≈ªä7∑¸®ÖÈÈ>≠√}ÄQÏA¶ÇÛKè&∂Àœa◊”õ[fuÊñ3î9∑t%¯∑ ∑≠n;]“œ{Ï⁄Á»yQ†]æÛı˚:¸∑˛[¸ß7É’ ò	¨#§¸›S›“Ω›”¢[ûÆ˝¬˚¶ÿ„⁄]ˇE[Øh/yEÎt≥~Ÿ+õ˝yÖ!Ø¢¥(+u# «u :ˆ?)´·fˆJl&íÂ5éÌ‘›9∂Ù`}Œ:™∂¸G‘ñø≠^˘ájÀˇ∫W˛Nóßµû Ïs‰Üº…
Ä}Ùî◊Í»§Ìø'√Õ˚-â»“Ào„;Ó	7oªBä}mz≠åN≠ïQ{=ΩS+£wkeÙû'£Nó—˜=!ŸÁ	»˘≠€n‚
0˙cπµˇè…Õpy˘ãé≈h≈À"d¯Ç4-”§QÙ‰∏¯¸Z9û_+«qı‰¯Q≠_+«èkÂ¯Oéù.ÛÙiU@˛ƒê?{}™Åwsî?’ëÌ∏ˇ-Ÿ.oa·JQ[F˘Ø?˚‰	;ay=µ˜˛”ÂËïµ≤æ≤V÷„Î…˙oµ≤˛{≠¨ˇQ+Î÷ ˙O÷ùnÅ˛Â	€˛öÄ| êœDi‚<πÚÁ:≤ˇIˆÜÀÁ0ãﬁ´
ÀƒjX*ó+#iyK≤V"ÿœûy}m}‹P[Í’á¢◊‘GLØ©UØ©MØ©]Ø©è∏Ó÷Gß[PCw+ƒ>_@LÜ$t—g'∞ﬂ®¸•NM¯£éóÔ§é

Tôï(ß K˙ïÜ€W›JK˙˝Ó
◊ŸóÎŸcï¥W;Æ=Ü∑:ˇ ≤Ÿ≤I˜ï<Å¯ÜYˇË≥å>≤a&xù´¥Ï∂ÀûÆkçU<f•‡+çû&±}r
—¯€˙xo˝∑xØ5 öÙëç2≈/O◊°µÌ≈}Á∞Æ5VS”J*ñW6©Xï¨◊H§ÌI:•¸}}Â˚üî∑÷0ÀÈÎ7Ã‹Úœ:±∂¸K‹Ú◊≥∆*ÕµÂo©È%*yO ≤uU
^'!ÙWW‡Û˛èı…§Ìø'ì∫ÜY´æ^√Ãï—ˆg◊ »{3∏û5V[+£∂Zµ◊Ù§ïqûêd/TÔu§Eÿb?¶<ˇπ>ôµˇè…l£lÇæ>£Ãï·‚Kjexñ+√zñX•£VÜke8©VÜìkF£ Oà≤7ØLı#Ò∂'œ?Yü\«˝o…uDÉ¨S_üAË”éæ∫V÷ó∏≤ÆgâU∫je=≠V÷v≠¨7™ïu±f‰Øî<aÀ—≥“Ì¸‹?ö•V˛µ>˘èˇø$ˇıe=˙˙ç2∑>Œºµ∂>ÆuÎ£û%Vô^[◊÷«&µı1£∂>zkÎcfç%V˘B‘´l∞ƒƒ€ xñı”ı’—Ñˇ7ÍhΩFŸ¨ıenù]p¥Œtæ/˛≥–˙]»πﬂ[ÀKó&iˆÊÙï…™ˆ]î⁄–tÛjxOã:Âk¶∞∂˜rëÁ◊∏˜ix§µ=v∑¯ıßˆ√ŒÑ¸7Jì5\eJvNVÁ,ISäô=πìÖ’…e˘R]ì !˚È9 Ù»:ç˚ª+D7Ö«ı˚ÿ·88&˝3fÓ:Ê˝h"îŒ∆Ï„¯^ ˙8óëîRYu∏O˜%äY≈&€±Ñ}(,ìﬁå•»óÉÀ§së…}5ÙïÿÁ—9D∂†ˇ–%ºÀÁa6£ﬂ}¿3Â∂ñ‡∑€á∆¯<∆=
(∂ù{È+≠Q&ÃÕ¸_#x?6{ﬁ,*._±œÂk0ƒ◊¡◊‡Î’ _ßRﬁT»¿Í≥nœW]1x˘©üõﬂõ°¸f≈8ø{ê?äv§‘◊ØsÛ∞Árﬂ\.5Ï—p∂ òΩ•®Ëˇ~ËØàá†÷ÁﬂåIY}+&è∂‰3•i¢4d5Ÿ≤±Ñ}!ú‰∑^ôñÈzü©À√VQŒ¿<6¬ÍqÆGyÆfkLdJ;ÈmË≠<ÚÎ€%¡?"”,= ô{*Ü∏gÊ'RÛàTœOÎqYû‰Úáƒ¿∂z†2%´ÀÖ–∞–∑”π<öùå«¬{
/ÛûBù|ÛÁê®%+Fl§>Iw∂á(4”≠ñI—j—Œﬁ`#∂
z_-
˚¸D¢m∆Ç˝íî∫<{Tﬁ2étGì¢›ë·:ZDÿ‹Q>ÎÌã6QJÑ˚"t1nëByóSjØ_hé:Ö4æ=mvo°ô≤_63ƒXW"…=qNØQKRHãæÚÖ¢™;;±yõ5ƒMGiYC¯bÅ"EÔÃFYij≠Zô√˘Mq¬tOºàoôxjÕ£
Œˇ.®ª¡ã‰©qßH‰úA3ëMÿ_5`_hV“ﬁ†T>óv3œ‘Ë¥ï&ÌMŸT6SÀC&»√#C+„2ê	2êM·rJöKJ9;w+∏„#€`oKÄ°∆lb8O(Úa∂?˘=≠ ‹GïÍMU“±≠vå…ÔïÀæ„„¢∞∑i¿VíΩ5®˜<÷	À®	›ŸÛ˘Ëa∂iRÕ‹í´4“ª„ûÓÏ¶˚-9—˚B›yûötvG´r«˝ô«ùCüKJß§¿£P®ìâÛî—ù1ú=–Ÿ¡NF	]ÀòŒû^˙„á∏?ˆÜ∑¶òÒ^≤!ÔçﬂîÜœ}Ÿf_à·~´¶X|8OÚnwˆìòã˘Wû¡Í“ty@´äB€Â9•f˘¨üH∫ˆn>¿•⁄Kêáƒˆ◊qHårk√Ü9ü;PR?øΩös∞«=Nä"∞ áJÏ√|nó	éDèé’”ú•í‡e∂GJ*GyT¿Áó\>ÉÁÿ GK&éëiè≈“ΩìjÂ„ ©wRÌ¯0jä(“	£¬rt)úE≤,;˙B9q=q'çäzüæû≠N◊v.{çY¬W0<ÓúÏŸÍ∫r,˝¶cı˜:oòË~{“Côà Ôú¢„^˘‘ë	E**”á◊ÁíH”ßI¡ú.œêïy&~˜ıÓ∞™Ë|á’2[©∞ö®Ñù˛ö¿\/]¡YjøösñƒD»Eùç–˛2ÍÀ¯s˝Y˛µÕë¿RÆß—oÜ«T^t¸πHL8Œ˘ä.á	ÓÅMYö`:3‹oàqÁ\›}Y£Áï°fÛî	‘û—wuõñÓˆ≤B∆≥ï‚·J≥"y:õ~Ç}©6‹¬Fø€ó^ØÌoP ÌH7ät§	fÉˆy√W—$˝£¬œ’ÌJ˚õ)õW~ø‰ pÒ$˜_ö‡i#•∏ó+3±Ø⁄Xß}úkª¿úÎ"1ÁBﬂ5r&‘ùsA`´ÿ¬1záF∞p\9ÕQlyûzzyZúÃÙµ—ª…n•∏¶e00%Äïê—l#¿⁄‚À≈Kù“BÄ√W•A¶oú+ƒHñ„sC-V\“¥Ãn‹'$lM⁄∫∞	¬$Ä}"MÇX»$Ô8m©Ù:Jã∞&+Á\´4˛ø[%‘¡—:¯ˇ˙ZOVCV¸j3€ÂÛoÙã˝~Òk<[õ-DvÌ[`ºfÚ®⁄ÁÎÆörÎ^P
ÛæëzL≈Î3,sÂ©Òµ5ä>Û0û„HC§Å'd5”Í?gK—öY”ùX±`sqÔÀ}*¢úÂzÊÖÎÆÈ∫Û†mï_π/˝≤+˜ıÍ&K˚\–Æﬁ.8ﬁó3ﬁ®»÷õC÷ìÔ≈0Ù.¨3ùú!≈Îˆ_ûPu_–	,Ú9+¸ÈÂu˜$Ó∫π≤˘©Æ.œÇ.ÛK„0ﬂ.bSº¸iú\Ïöu!∏VæD∆_:*”Óõ£¬˙ñk¨ØœVÌÀ§·¸ÌêΩ~π‡Ô;i•D∫"Ñt•@∫J"}W"}Ôﬂ1‰Àﬂó©¿'÷≥øÖ9’Û‡]Ó|ƒ{>»ª˜/y”ïU∂∏$F^xsÄè÷7–§úà%ïˆ—˚ﬁËê¿å—z·'ÚeöŒBbïΩJGfªAóüŒ’∏S≈uî∞}äP5ÁZù◊`TÖ‘A9I‹ÂÚCπö!NıäS:ˆèÙ@£õ^> Úé∏™Ç}3ø†¨œØ3ØÈ∆EÏ◊	‚·√CoÛuﬂJÛH}{ƒ∑≥UÑ=^Ê+Ï‚˘¶‡Ûp˘nÃ}€W«x•Ö˚Ëø÷ÆùàΩ±]üß¸-ÜÖjÂ∏Ä˚«hó•.ıwD·=<X?·®tü6—€Hpü£ÍŒu◊P⁄B nˇH›m3gÁzÓ,´¸‘õ◊ò˛Lw7<<d˘Ëg£éó} n˜+ﬁ˙¬*˙ÕG÷˛X_≈Msq3¢jPì∫ÛsÓU¬›{‹ÎﬁaÍÄ}wçÅ:uπ}ë3UwìAwn`cä∫wP2ÿΩvàpi˘çb¬&¯üØ,8/‹œÛzóÛ&©Å7˚ [).äπUBi¡æ‚69a˛ÖL{;~6≈(Ö\Ö¯% °DˆØ$ÚÍuHW7çç∞ÙÄPπÛÛ©à¬‹Â#ﬁ-{◊{$'˜˙Q˜…mÂ˚eŸêHF2¢Ùçê!a?<:—©ˆ#¯ùŒàøÊ˛8‘?*±v–ΩGbäRç…∫≥ﬂb#Ó6ó;Ûm3∏,
Õ•hò∫}5€Ó	˙)oNO^?e-~´ˇà·`1À&kÿo`
^}ü¢»ñwß®πÛ)sÜ‰Ù<Æ¶	›π∏Ö4ÑDz≠‘>»mà∑[s˛˙ô(ª›úyéüëQâ@Ç◊=h2p≈˜Ô<h 2¯Âë_Æ6¬O‹Úùÿπ¥eZÜ˝ÑŒ&ƒ≠ =)+)`•æûDl ~ä~⁄‰x`a@∞D—J‚ÓD"w)∆Üß—+	ô$ùgP∑CÍÃ»ö±˚)ª◊pIV‹˘°…æˇÓ;txt™õ$wCÃøoñ¨6Bä'î/Aß˚Å⁄®€l]ƒ Ùæ{Øëx´5Ü{çxÕ¬.Ìo_Õ√Zˇ≥î¬w¥9œ†s≈—ÂÁ16ï_Ä◊úin‡˙ù}!ÏXÍxVvÚıè9£S‹´v-/rõ6çÀ|ªl˜.xvë“v/Htˆ]Â’Ë≥ìﬁgCÇ∫ÆÑÛÃˆ_Ç%d¨"(C9C-Ùø”ùÛ
¨BTåÛ™ËÒ£«≥hd€˙KÎ÷≠Sç˛◊0‘ö˝kìË¬O≤ˇu—Ì±<∫Èw,‰QéûUúµ™õ’&u8œ”ÉÌ!ú7‰∏ºTÏj¸>K˜Ô«a§T+»…»∆ú7ë|ú/@’∞ﬂ¬∏˚∂.Öí6ãw®¢{™ZÅ¥ª«i}Øêû∑9ÔP(ﬂ€†©høFµ—†–Ÿ˙"∆!î´¿GV:Û›W9Ô°˘tiK3?c*û¢	E*?c,}Êö›•:&ŒÃ&Œ˚ÑªJ£œ¨Í|Ä\Òå¢˜ÿUÔ›ÃÇaˇ6ÿ˘Hõz:.dOî«Úì÷v~∆ëÓ xÜ?∂≈å⁄aØ£€á\ÔI◊Œ¶&¬uˇQ`å3{W◊ù¬x>Ÿ[*3NcÏêcËw<˙Gw\§Ûñåf8ø◊Á;ˆre£1}Mµ/àªå≥Z≈U‹ÙÎpûˆrHdöÍ…1Ô2¨’ˆÖaô∞Æn!À©Â{«ãBjDuÖ¨HeXÕ«J±<i∂…p0TSH¨O
I…Gc	∏kÆ∂‘≥ÍEêƒƒu£!Î‚ÀæX(¥}	~ø[¶âPj‡`%Ë(6,/Ö(ác†Xl´NcÄ©ö[{cXWbmv◊ (n_°y ›˛n¥Ô’Å}∞ÖÅ§ˆjâ≠™]–¡™Ω≤
¿Ø©EΩ†È’	4\ãÌ(˝%Tﬂtu’Tìﬂó>îöxπïÕ=M⁄{¡aÉÃºôÓ`∞ ﬁñ≤KØ7:›„>ı®?iﬂ.fNo6a&ö0±ƒªê∆f6›¡&AcMCçæ ˛!ï1Ô|√U\µ‚˝4tËÇÎ6w¯€‹c4dúvéç!g¯∏}cﬂwæN…h∞Æ7ˆ&Îñ-’lmÚ‹;µÆÏ5a…≤ù›/ãØ◊˛G\Ùo£Ëi’J˜OF—∫6¨Ëô∫Eo®[Ù∆∫Eo™[Ù1ÕV∆+zC∞Ëç^—˝¢7°lc"EG2´1˝c.˙Â(∫•ZVˇî⁄Z_ÎùU˚º¢g}‹¿ƒ(W∑ËÕuãﬁR∑Ë˘f+Î=,z≥WÙføË-([>Rt$≥öÉ—?·¢E/®V°øE/u˘Õ¥Œ¥Ã/Jd~∆ÂoU≠÷¡+]£‘i¶˘Ì…ˆOÈ}@zt¶$S´ZcØ
SC∞ø‘Œ∞Çå‘s˝ùKÆ≠Æz∂◊≠çqukc|≥’fµ[„¨Ò‹óDlYœémá¿«A‡„WŸ◊±¨WB÷TkBˇ4·úÆ+BG›"L¨[ÑIuã0πŸÍ∞&Zì¨…¢›™€ôáä0EòÑ"L^e_œE∏Eò¢ZS˙Ì⁄ZxŸo)üSÑ©>nﬂM].[ùuã–U∑”ö≠©Vß’eM[o-t¢](¬¥UˆOπW¢∂jŸ˝’a–[˛™UÀ:Âÿ»O(G±n9JuÀ—›lmd≠í’ΩﬁrQé —Ω ˛ó„*î£Gµz˙ãíß˜›Mîè#¢g≤≠∂Älú˘4ó_51	V˚/‘h•˜Ø†ü¡FóA˚œî¿6^√™Ÿ_∞Fıs¢ÓN(µUŒ|q}‹v∞ˆKj»_∞<èÄ|˛¸>ökmÀ∂˜˜ÿˆÓﬁEU+ﬂgCíåà~≤˙øœñÁ¯Ø¯^Á≈Ñ(øn3ë^s{q§øÏ“5·>®™À…*˝◊0pŒòÍUÆÒ(;O+ÿµœó6íd&Öcd‹3äá6»v· Øb\Àã"¬“WòÎ1Ûº˝√8o˝öˆè‚rc˘«0kÁ©˘ŒT?
[·'¯]v W±_Zs≥ˆaN,√ÔpK/53µE¶#J?•ü¡“yN¡J∆ñ=Î÷≠j %˙>“î≠DπS∞∞‹ÄœKJíŸõpnfhc#ø±%d\\ %’éa¡(3h%Ìü—œPsl⁄?á7og1WÜ˚!Ó˘‹Å™Óä=§òW/VÿÁVYFˇÛäˇèL>ÂÇ]Bˇ«J¸YÇ≤fﬂ‡Æüj /(nÎ…çBOˆR+7q°nÊø∑†<7√è=´ÂÌ[„“ìÈ∂∏∏øÔ˝,z§W˝∑s	~…ö§⁄∑P °≈j–å∫Ïvñ˙fÆ‘o˙v˝^Ezh,’â·Fèà∑ÔÙ§„ÉM˚.QÏ!°¥gM+À¯K.„›nuÖF<e;.„=¢å≥H©ÔµÖ{ôÚ}(,ﬂW&‚JøP˙…Í≤˚]ùW+∞à8mÖ”ﬁJ≈•V∞™¿‰˚X0u¡Eñ˝x6£,√'ﬂiô	f^yà>í‰]1q3Hﬁ~ÿ’˜G‚bø˚◊˛÷,|LMˆ? ≈xb’¯Õ≥“öU¨ˆè≤b/{îÂø/tßE¶":Op*ÊWiŒ]ä3ÇnyâDH⁄oÙmÌ7ÑˆÂÖjﬂQm	¡Cç*U•â:ª«c…2Ì'Qïπ0ÿ~*®ÁG)¸&÷Cz>è˛ß∂S=ˇ¡ú∞û?∆:4(_"ùñÌg(‘øÄ:LöÎoã{ê—Ör[8û2Z»zÇh™áEÙì6:>]B}≠¢SBˇNV¯jíÓˆX≈åØB rEr”æ3·e;—7Wk©b™7d‰ùge->'õ“Û®Õmπ6ôªDˇÆ¯°ûpòŒ™‘Ï~Å}åÛD$i~Ü[6w[‘∂åiøÁÖ•ß—¯≥öæœ4’eª Î∞£y2Í7ﬂøf√{“ÂÎvy™&oˇ&.Ôz).]≠^≈Ì‘ÇÀùeÙÔbœ»2Å“ö"≥á»wÊo´Ü˝ä´ Ï\¥±*ó∫˚Çd«ßq¡K&≈‹0tfﬂZØ\j•†.û˛\"Q+(Ó÷ì—w/ •†qÇ∆†ëøŒ´q^f¡∑∫l!s
ÎAî»~çUt;˙¥RˆhÓûˇ!ùº=çÅÇ(‚3˛a·ú ó{–ewÕêtFŸﬁ”Õé·ô%µÕeû9AÌ¯LÍ¥ØÂ˘~LMïö;>+Ôb∞…¡*›øà›unÅd⁄ØS∫Ó§°ıCJ{6≈‘
ﬁìmäE0/–ß®"§Ÿkë=aHŸº ê^s<Båa~9¯~‹mT‹«(‰bø	y•§Z)WK2ÊmäIão”~áÖôY7¯.ÀÔ±xÕÚ˚q±*â∫(Œ(£¯!§/.î!=ﬁ®€ƒy2Ä›ıπË(÷ûwÙ ‘“kî/VX7Ω"íÏˆÉÏäjAT »%µ¸[ú∆ÿøàÛÿCÙM{qﬂ‘Ωø€œÏÌı3ßS{vC≤ü·∂ˆú;xsO≥˜4{p[÷˚˜a¶ˆ:õ°•!G≠ äæO∏ìŸÉ—‹Nf∂Ìu2‘õqS°fóÃ–`†¡Ï·—∂˚Co0˜¡	˚#.®ÀïÔ˝ÃÀ˜dŸˇﬁóÕÁ1êˆrX,‰pÇ+á%Æ¿Õ›ÿÉÀ$À´0ƒÆπTÙuKF)õ}•lˆgF˜ì≤π≤9T≠Ï/e≥X6˚˙≤ôÎê†›œbï¬ÿ◊#F¬¯É'ú∞ˇà“∫≤∏ÊfO˚±,˛TO'≤8(¢át‚‡Qñ˚ YÓCòßeπÔî:qà,˜!·r∞ù∏©V'hát¬ØG'åÍŒùÌÃr8T»·!áuŸ·û6`Ï§í_ÀÜPæ)EênÏaVf`áR≠0ÊÁŒ2ÑÑe	≈˚ø»ÏÜ¢«˘F˘“PøZSå/≤Ñº)∆°å∆SåÀw)$¯õV3b∫ ÿPûÄºñK@0áz9Y	˚/ûº|p¬˛´ê◊8Òv—ä{]3©Q˘ıãûÏcŸ˝ç;B{û¬ÁÆÊ+¡PâC™∆>BŒﬂ„‚⁄›Ú Vûg≤?Yj‡üàªCï~?ü†ü?öá 6∑¥ŒûLWﬂ_“§_Eoÿˇ%Óãq8	Ÿ¸K∞ Cú)üU¡Ωª`ø°GÕ5y=KÙ^Ss.B
µÇ·”Ò)*g˜ÍQ€gÒ–˛+¶ÀjπÛI	gò¢O>nÿCñ≥%Ê◊[a∑`k˙3§Hä¶≥Ω?Â£båz∏©2„H≈Í£‡	’ãÿ∑ÂuÃ“cÑTVÈœ¿Q\H≠c‚“Øi«√‹g©iKÌÃÿèq1é∏];∂?cË„$`å⁄dd8ìå±˚ƒ©ë∏ÅíÙæucbM±µãêŒÈNF∫„Tæ37Íâ{≥¥)Æ© cÇLZ∆¸Cê⁄9eÄ√Á'!Ëû∫«∫:ﬂÌ±+’v∂“§fî˛íŸ¨b&ûo{iÒ"LJÏ0)vQ€Ë}»äpNK
¢gÇË	™Oﬁ_›-@7üMÕ‰´7Ï∞ª	'NçØÂË}'@1%(ˆÉ¢ä_nä±«2ä#?è¶ﬂAËAY∂¥H4ÄD'"—ëÑë1ºD¯Ù%— ∞œˆI¿û_m¿iëVÍ*˙ ÿäÊe(æﬁ≤*6_˘˜`µpgè⁄UTÖ€…
ÔŒUÔŒ}÷)Ë≥å.ÍåÊ´ï”–8çÜÏïõ1Gcx3=†”LÔLn˘ß¢O°ôﬁC0ºyJYAÕÙŒ‰Œg{∑Û9ÖmÀ¿T≥r:rIîàâÆM]vZø"±˝I»µˆëÿ¬≈]tﬁßxyá:oläŒ[ÙE)e≈Ân_d*?˙π◊ùÓ«„8g≠Ï¡2©∞L∫ß´ï~˙¢´™¢QWÀ™`˘)¨¬Î•@ÙÁ'âµÇ∞ù•‚⁄9É7X=h>êV≠úÖ£Ÿ¿¶kã!&byCL÷Ü∑∂~T≥ˇl.·2»2¶⁄£ø?E≠ JVÈŸ,Ò3‹πuÖ±lb<%¶ÀRöæ4á&4@nLºôK à'Ì6§j´i∑~??G˘Œsælﬂ˙≠2A vÀvú·Ì≈D{ÜÓ˛oè‡0ï—+N‹æMÁ«òíM0ùõ∞°ë7WÆå'rÏŒí6gœ∑”„‰vBòÄ¨é	PˇLu£:È€±@ˆFÓêÒ<ëÍˇJt»Xe{C∆π‹™zè=Oïw√(|HëÙDqÛŒ*Œ≥¨ +–G5õâï…SVJ∑ûLï¶'
ã≈©õw’ yl“¿Û€“+ùv!í4£‡“§ﬁ˜£9ŒsîAóq2›{˜Æïo ∞ﬂ%At/5ú?ê<Û+%îO”í‘´Ø¬ﬂ—π^kk·Ådéò7"∆æDÓ•n¶∏‘M»x"dÏQ-O2B‹œ∆ïül èk˛;<NÒ`b5VŸò¸«a‰ÈÂÀ—ÌûØπß˜ΩU∏ú8È€:Oﬂ¶“á=A˝…>ı Îƒ†€	√Q°Î§˚B ÑP}+\ÓLb‘ÂNÀ=ïÀÕû¶›„}^
Öº≠yÌáëîÍ;î•3:3‰Û∂JhÈ°éÆ 0öxh¢)ΩÍbEìYj4O&/lòÎî	è*GR3ú^æ
‚]o˜FÆx°3èå§3£î·ªˇ›Èç)(£B4R¥Édç^DÃêz˛[Â}Ôø£3]~y)O˚£ıñõë´‘™N° T'™Åv÷%⁄Ÿ*(¬EaE¯äß≤ˇx≥F˛{r˚ÌGO¶çFO¶Öı§P(D#EyØVFË?Í·√ˇN’€aÓÏbÎØA∆g;˙=9æ˙[˘ÃŸ¿%ª<Xﬂ_®^´ã0¯√At‡“pl¢ä˝f8v\8ˆ[·ÿﬁpÏe·ÿ¬±ﬂ«ÓéΩ<€é˝œrõ|è5óyJ∏Ã+ëﬁÉı≠†ÙÖ⁄ãèµ+¬∏«[Î¡Ω2å{còØ´T>O¯¥¶ÔÜ[”E∑5-‘¯
áæ÷ír¢ΩôÊéœÜ≤ã[ñ7bMËÀÁ∏Ëku\Ù]⁄;~.ÌœØwSB:∏‚Ë÷·ò¥1ß˝G0Ô‰òîAq3[ç¸JgòÇæ$YìqQK˝4Öˇ0ÕßJ$Õt…iûù†9qïó4úâ°_YOã‘ *û¿i∑ºëé∫:%ÁØX´ﬂ◊˚Ï2ÒÑwWAöoyƒ#Wìq-¡áÚ≤ƒxË~t\€»˜£ÎΩØÀD∏ó d‡,∫®b‘÷˛kÃç*E£˛ÈEu#Íé˚Ó≠πî‚KSzè?wÄèÈ~ÎÌ˜«¡ëp:èFTs:Æ‘,‡:Õ_„û∫D∑ôëfa±∏,Û≠‚–ﬂòÈgÎ”ﬂ¯?ßø	”o©Oìˇú˛¶ﬂZü˛å(˝v¢è7™√7v,%*ÙìbÈ¸Yiß?NØÅC√ôIß¥ÛM™›	s‡0
˜0ƒù2o—t⁄0ƒ6≠H<â7≈ú∑TH8≥0∑…ÓDR$nNxâ›F¬ø≥ìÁûÌ î≠ƒùù™≤XôRﬂß™ˆ|Cœ⁄˛9∆õµ˝L,¯¥o„[Åñº@Ê!U ÇÃæ® ∫ô°i≥»ˇù ÛÕ≈¿{6•£$ÚE=TkÍ¡Ü——ƒ¯6ÉÚfX¨õmç•⁄:√)HQg≥πŒ&À:ÀÍÃHp§WeoáZﬂcÜ€˙Ê˙êægnƒ¸ñf´OÅKµπhà≥òøwÔ&yV›&RΩUˆú∫@§˙=Ëùr¨ÆÚÅﬁi…Íµ>–; Y˝±ÙŒDVØ˜ÅﬁqÃÍœ}†wh≥z£Ùé2VØÚÅﬁÈ≈Í˜}†w`±zµÙ>VËΩ≥é’ü¯@Ôxcıß>–;YYΩ¡zÁ/´7˘¿›<‡w}‡Ó>pxç‹”˛»ÓÂØÛÅ{{¿ü˘¿≈f8 =(>PΩ	k]÷D‹=r!jm ÄRñ·y˛ª‚h{ÆÅ“à7À:%@ç‹,‹Ã	n$∏Y$∏%ê 4pãHp'∏%ê‡o}Veø
‹á“∑ê,’ﬁ‹û˘oƒ‰=T.):÷Ô≠BJMó“∏≈¨Ïá£ì‚ßÁ#ˇà≤ˇãç˙T±®VÓ·ç≠¯Æw…‹Ø–<Z˙Ô‡¢G©Ωıﬂ≈üÀy∑ [‹˜àı±;›5j‹)≤?˜-wÛZì’Ï«xM'ø≈èxçÙ..®àõπÖ∫å…r®;%~[_*≈⁄Ï«yÎ˘Óbü‡ÌZV3#Z˘∏ÀãdÃ+Ê*¡ã÷æ'‚%oˆì ‰+ì%≥(∞åï≈˝UÕ~ëËvÍ,äŒ∏(≠8á≤?Ë >oxé ˜mÉB€∆”®õjTÕÀåôIAÃ\Y‰ïtÅ’˚ziR(c√~	U%ÚΩ?±≤ÿ,˝∂ß|D>)M_]x%]öeò∆+Ö#Vg‘ƒe…¯‚-9ΩîI∆g≈Ù°ÂqØGM-=ø±ë ](È	Jgò31é$cjjW´‡ØΩ5:«≠:ÜÀÔõTLµˇrç ˜∏¶€œ‚∂ê*5X›^Éœ∏˝~∞˝ﬁäŸ~ÕpÁ©¶ÚMQÇüÂ;“œÚõDØ—h€‚9÷å78tY™^¢aqæ–UΩòwrﬁ¬NŒ<W˚"∆~W¡b4Úì\NÚ∂ü‰“PíåQAûl+6æs∫h\2Ò=¯úÁ∞∫7f√n‘ﬂ—∂P‰ƒäÓVsEO≥¿≠∂©âtÚÙS≤$lﬁFePﬁƒ1y˚då=Ûv#}<nãÖg¡›\æ ,ü3g„≥ k	ÀÏŒ ÆΩ,ºr5‹1ßï‚î”c⁄¥Ãï¢ÓﬁÚ`’_HN‚å =ÂË-VSŒB√%Gò†môÃÙÙvI§ Â/rÁÇöç∫3U‹<ºW‚QÇ≠ÁØ[∑N§H2ô|¢∂ËÔ’)z<üKŒæ>RÙîïÙä«-fÎ+z¬JéPÙ≥ãxYÀ–SÁU√≈".q2Q[b ∂^â˘˛RN∞ıN^âI@G‚ç÷r§§VZïÀx
k•˘áu2◊?ÁÅÉíh™-Øï	t¥âπ“j∞h‰xÕ/jS@z•—jî(≈#Ω.˛^’Û√ª_~x*ﬂÒÇÒF≠‹À˚@ü.)Ã2å¬í¬¶„
M7å÷ÈÍê•5™ˆm±◊‚«≥M')ÍvTp ±•(æ±Ô6#∆é|ív⁄‹NSÑ!Óˆ|ò˛ÁSköÿèO¶VÄç˙b∑ˇ! :>„àŸ(Ïò3±sgÑø¨Ó-”7SeŒp7Ñ˛˚ ,0≠BjÕï†&IÀdŒ+ÿ1<õDÔÃ˝G8˜O•‘•Va€Y¡Ü^BPkï‘ÜˆpÒ$ñx◊X»äÀGƒò)~»Eò;nÅ,Hä8ü2U{»/?5]Æ#ÿ1Òﬂî·\Å1¡Ó¥$ìΩÿÁïåŸA‰#^$Y `æÿ&ú¶zEp˘RUºÌÈæàWg√3idÉ∂ﬂ∑4YLúöMæºF˙π=Hê~T€Ô‚Óú8øÈƒ∫¿7±uÊ˚~÷¢ú∏™≥`äìÒï_É/úV_’Ÿ /9¨Í´.{ôΩ¡!m}7!Å=^SÇ˜·>Ü"∏æz$˙á2ø ’'TˆGIÖÕÒDæH¬BîY!≥SG˝=)¨ôß†Y+ŸFaHÄï4%´®…˛ßŒ3®ˇΩ’
+]}LLÅ#&ó¡“˝B–˜£û¬=.˘\TA†∞ò©äÄ†LSô+IûHO	§ß<û‘+Ì•if˛Û®À«√u˘∏Wó”ÀcUlPÆäVf¶óˇÑ¯Á¬Òy˚yÒ¸ä–]ŸƒÎÇ9›£w5ó‚|ü◊§jÔ∞NπÆÏ7c“OˆÈœ#ˆÈ£¬>}td˚ÙnïW»?w/è»}‡˚2q¬“˛-âÛöÛ¨Jùˇx{¯ûÆ7éˇú{ø˜&!âIƒâà+àëàd!≤˜^í#ÇXi¨$àΩµ¥U¸‘àQTÌj)J´®•ï•≠Ò?œsÓJ€_ˇøˇÏÎ’èÛ>œÛú}œ]ﬂ|øˇˆTÍcDáåhØ¥πfAç«ˇX·Â´#Jˇ°vt¥PpÊó?`”/˙s≈ÔˇÀÛWv 0>'çr˝óg™wÖˇ˝YÌ¬V´]H)æ˜Ñ{V{ø¶ıí›øîÙ@‡œõE≤˝ø<c(¸€”ÏÖ{ö˝H¯∑ÁÛèÖ{∆˛ìoœÿÜvÔΩ8Z≥ÁA{R™ÙÚâ†ﬁÛôgv©…ˆ∞±èC‡ÖÚÊo´¸’#|Vg5|>πÙ‚jmÌïâÚ˜≠.ó·„+ê+L
´°©=µø∏⁄·™˛ö`Éã∏ˇVá/Á‚0ŸhUe∞Å·I/V⁄ ∂Qâ7[.–‡oç±’~à–Â*¥Ë¥Ëóˇª- ˇ_m—◊–¢Î–¢_Yã\º¸≈Ø¸{Ò}Z˙ój˝mÙø˘J~ä%√k¶*πÁ_Knp1_}PÒ∑BoÇ|Ö>„˚a¡s¯æ˝·πíÒõöÒõíÒBÕx°dºT3^÷ÿS≥mÿE{·Ô∆ºÊbz8|óà·+\y∆_ˇıÂˇ∂7””ÄmY<ï2ÓjÍÀóØ´/_•D˛•‘ø2˛;NLØe+ÊˇÚ™¡˚ƒ»øƒ™ˇ÷Â-4¥'ô⁄Ûª÷ûˇvZ˘˚k£ˇœﬁΩ˘ﬂﬁMõ¬Æ^˛È›˘oÔÉ˛˜˜4Í©áè™PPnQF≥§¡8Dƒ°†>á_÷∞˙Õ…«Ï˙4
Ø√l‘ûÒ˛ÜßÖÇxÔ˛◊›cZ3º6l…⁄Í X¢o‰÷pã9ü Ä^¸ÚÕtå·Â5ÇÍ·~Hòb^ßı¢aá∆}Ö·fP∆€+aä¯∫¬wíπ)%Ò,wñ≈ã”cîJ)Ä%okÌFV›·ØøÃkU¬√»Ô‡≈•øãÑ5©‘òÂ∏uR-f≠lØ∞RÏ±N[‘&ÿì¶®Õ†,Bvı¯ø¡åÔf-€+ºøÑ+I¥Ú6Á“åX±πåÜg:›ïg:Æ"˛çIsufß∂˚kF[lÖÉ>‡`ö6çjﬁõÊ®œ~kÑnBA4Ëf°¿
#˜ÄÈ…ü.ÙÇ¥SQ_9€ı_¬z˛◊0Ó.¥”W»_lX!‹∑≠Í[Û{´Õ	|¡€ Î’•.˛2Æu§'à™¥4„€V¨íeô…
¥¿÷B´WíŒZ≤†•ûl•Næ° e	∂Uó`ªø€⁄i∂ˇø€jˇˇ†≠Yˇf¸ÎÕ¬|°¿*¸'Àõ—¢› ˜¶¿ÔA˘o$∆¬ZˆV÷rG›µ=<}ëßx@%£dÂµ–πü∫j¥ ÷f¨Qc°¿C´Ò/ﬂmu«A›ï∫ª¢gC›]˛R∑œ?’aùÙ∫5
∫¸≠nı_O°†ªwMPøÀñ]ëxhœ•=Ω`àS{bQ=†TOhœh•=Ü<π ú“«Ë-˙∑ñ‚=cñré
†plÇ-6¡ê!`a._’Ãù÷
‘˚¯zfKAc≠1Çﬁ¸£ÖÙ˙5PµØ	–◊J_˚Úæˆ¡¯ﬁPT∑ö}’Ú‰Ç>ÈÎ»ˇ≥æB·^⁄p2,LÈ´ñkÏ´û…˚ä¨5F–Û}˝Q‰!ˆPn+µK	˛Zµ±®|jJ(ÜRb· +7ú˝DÂ≤,£øö—_4~Ô≤ˆ‰eÄà‚Áí¿ i‡(„2sâC
‚ó’2*Ö˙®òÄ„"éçŸ=xÆÄ¡Àk∏√Å/tï]˝l”É·_#≥szÙ,º,[#*´E∏(xSÛ<û(¸™âkˆQ˘ , €‰´6¡Wi” 5cêí·ßf`¢Hp∑µy”«AﬂxG”«+˝¨FVä¢fQäQä¿0∏úlßáÈJ≈¡ PÆ´•°B¸ñ(x®Z0&&.„`øn ¿t¿óÆ•3Ü9x>ﬂâÌ»∆7ë™„k¡|ÂÙ∞‡p≠ò	.a¸2z>oÇõw¥uÅ{!•ü
¸Õ%“ËÇ∞Wq±üÙPYy°“Nú∂÷4ÔaËœﬂΩÉﬁ6ÒÊœ°"‘„{Í¨Ù|§ˆ\qß+>WToã‰˝=@¯√≈ﬁı¯√E}¯··‚]Wı·b6; ‰…⁄Ç/Mxî¥∑c	x ”ﬁ ƒüƒ¿JŸ∂k–Ÿ·ÊiòàBõÈ·bÕ© Nw#¨q5>jk≠~¥´]vzû ã´'KÑ±Ñ);◊öX°¸	ˇÇ_$,ƒvû,ù=MÇÖﬂWnÇª—mŸò%¡{ƒÙL3˛ÀéÏ∫oz;9}44-NLOÅXWLUnÂ∆Ò[πÁ1a7Ò$>s’cKâÌ
p˙JèÜÔ{%È—∞tmÑÇpÃå‰ôŒp-=…îÆÔn]‰tmÇ‡ib#W…e=åjc≈ o‚å76‹ºÑVÌÕZõ“aaXfÕlO2ÑÇHÿ–`Ç≥‹öê3˛KM¯1ª/L¶àﬁ Sz4≤æ±Âl?dy∂ ^ŒÆyS`¨.ÍøAÛ4ŒFºT3øiv‚*∂ˆ¨jµo NúA‡'ØÍôz¬tá´ÁZ.˛ç¥BA´–≠A-~C˘ºΩrC	∂Z¸P±¨≈Ç⁄BA4ÛÕÜ˛÷JOÑÃ∏tÔ&BA¨ys≥Ù8Jv’/„WÓπ“FÈ‡j˛WWs≈’‹Ë:VÇk|MÎm¯Í÷vsí Û[¿≤„Ò1/~⁄'∆ê⁄Ú˙î|;%ﬂ≠6KLyE¶F‡∆Î≤Ã≤uWøMSÊÿÌ¨4˛1ú4€◊æûR [Ü–Óv¸˜Â‡|Ô$R·\æó±85œ“†È∏#∞.«äxıøN‡âQ |M~•∫ö˚®∑∞»,˙õ±xQ{3ñ(ÚÁrMîgÿ¸˘78X»Ø›M≤mgØj Õ%ˇlT="ÿËÔΩÍ±êF’8√{/∂_í#¸Ω◊ÇÔΩ∞ÊÇ$ËIbÇ` vŸ#ß˜ÄR)"˛˝>¿È›ïR	"æm õ≠≈∑Â Î-^4:‚;©3ºÕB^Ø«¡Z}j™àÔ;“†xvwÖX Ti%‘‚ÿ)‹Ï¶∂õ{ÿÜ`ZöÿÈ ´í¸Ω÷R≥zØ3b˛ó˜Zz´·’∂^}u≠P_w®®Ω≥J◊∆õø≥Çy‘ﬂYa©¯Œj	ø,`ª¶i*å ^9Ø0´Ò¶4]_ôˇ∏“ˇæ÷¸˚z»†j‹øÆ¨π ´∆z–»≈÷C/X9 zHW÷pzOe=dıê^s=¢såÎa_9|2≥¯zHÜX˘z»U÷bAÆ∫2¯zH◊◊C:/"óØá\Õùá*Îa¢∂V˝œÎAo5¨á„z»®π2j¨áLmº˘z»¨±“µı∞RYŸ∞≤‘ı∞¡Ï/û£} 8ÖˇG*|®Ò7„œ˜M}·ÆÉ\¸¥ﬂ⁄°§˚∑˛^FÂÀ»øg>ô¯£qóëüÚãA™˙R¸®·œÆõ]á‡oŸÍ˛ÊËÔß¯ﬂØ·ˇÄ—0˛{Gö?˛Ω2˛ˆ¯?¨·ˇ##_ó!5¸≥3Oæäˇ£˛èvV√?˝(˛?’ˇô—Pˇ˛ÿûÅäˇì˛’ÿ˛Ä˛Î—ﬂGÒˇEÛ7ºHÑ_Fa≥tÆÀÊØÀä¶-Po ¯&\Ñ3∆ßpB+;!M+©ÈÚ%∏úFóæÊj‹i„9
~S)◊|—øËÉ√k˝°¨PPä«É;ÀmdÈÍ≈Ÿ¨R˘ìì∫iWxbõû.„uëÇ™>«Ü˘/Ì∞„Í∞-ÎÊMËÊBc7Ô]t¨ÒŒ,=Óù©˝‚OÀL˘÷ªVÖ`¡ÔæÉ”1^©¯∏´W*ÏÑú…Ô›≥Ô@Mãç5yä¸#o®ÚôˇK≤·iD'Aˇ¿KM–w€r}∑]&*ØˆqLìÿøqL¡Ö|VÕ>ûlÎÓé/ˆÀ˘6µ∂©ŒÇôÚ!5¿ ©|[Õmlè¥ΩÇAúÕ¯GÙé‡MqEÕ]•B‘?õ	˚JÆ÷æØ,´±ØîÛ}≈¶~∫ˆh2~∆«‰g3ı≥K7y˘È)⁄+±Ó +1˘b›/Ω\≤d˝ñº>ÍÍÚû|ø¬øøa≈ˇór¨ˇµúgPŒs≠úï"ﬁÃ¸
sº 8«ÓŸœ oµ1œW‰Wﬂ›µó)Ÿ/¿k≠—ãÙ3§?ªz∆˝æã>∑ãªá{gèŒ·ÉÈD")L=|)qûF»*ˆÔâ’Ñ8è……JLãáCäD‹•ƒƒv|Á¿1$Ü›¬üU:
ﬂú√8°ÑqˇîÙ(ıëı-¯ªçÆµö3¯ÉvÜøÿÜ⁄ŸH∂∞ˇYÎk&q±¿gsÑça√@ÆSÓ_>VèœﬁGÁ±ˇw˛À∫â∑S•/Ö?Oÿ{¨}m0Ô©Lˆõ&ìî°†!√@c¸ﬁN±!_NÎÜ¡ŸΩ›Tè¡/˝e“w§ùÜÄ^
ÍçÈCòﬁ·∫`®{xÎY2˘a0høW…‰Œ (ˇ‰¸á!2YÍ˚väLÚ˝@É¶É¸◊ÉF≥´twø3ÿ·Ÿr~˙vä…´c_,ì}ÜXêµñê∂µ⁄‰fA∫YŸ◊!ÆL-HÉ∞µf:¿Jxœ◊ó›∑,ı5’Ü¸Kı¡ﬂÀ¥¡⁄£¿”€ê1 Ù˘‰‹JôD◊Ÿ‰&:rnéœe#pkh9##€…‰F¬Oe2Ÿ<rZŸÅÓz"$≤›trc2å‰q?Ë˚oÅbQ}‚`%…‰pƒ˛T<_¶B∫µ~<¶QS∞‰D_9^:,¥ßhÍ˚Œ†¢aÃ£˛2·…LôåäÅtØ˛~”Íì…µ˝¶•È©KÃw≠ ß¥Øﬂ¥`%Áó@hœŸxøiç»M?P◊⁄õ‹:⁄‹[¡J»£cS·õˆf‘ﬂ‰VüÏ≤|áï”mﬁ;Ã'ççF}2`‰Tızáï0éÕT#ÚÀ‹R|~Ë£w÷
 S⁄\	jÛkòL¨ AõçÖü –˚I	lÂ‡∂ãÑæúÙ¿^/ ™0c÷”ıavÙoÀ Ãe=˙[Xü‹âáZ>ıˇ©ÃûCΩŸ]˝$˚6lˆ[ÿlrkNF't+iANÓV"ìN8b·l¨ÏI·`Ô¿Ê‰p|∑íÊdy®%z:ÉNN G{®1ÎùÅÈ˛}°ùÈ˘†ÕjCNuc–Ôq∆=√°µuYõìÌXf[‘ØÁ@iç°ˆ8_c¨@ó[ÇˇÑf†æ8É´Qz?iMNvá(W÷{≤˚U2∆må›±ˆ§˘0»ô<rÚ±m·,∫¿W`0Æ‰˛x§ª·*}ó≠‰v§ìÕ”æª—g∑p<Åêv§>À9ÇÈ#òﬂéµ⁄˜,ÊúUré÷⁄˜*Ê\Ur‹ôœ˜òÛΩí≥í˘<¡ú'JŒ©⁄O˚∂#ØPÎŸÄ±›YÙ3Ãˇì©L÷‡
ÈàÌ,‚£Å´}?_Ì≠@ü∂µr]Å˛S—≥zÓAœ”Ë˘3zö£gûå√&T…Ò"üÔŸ‹Ecz&≥7(œﬂl+ÁŒ¯>‹ÎbÀ`ÆÉ¬AÁ¨Ω8ÙùU®Ë?µ£’ÓπT&_£ZYı\⁄Aôú£nLw+mà¥üM8ÉÔŒü¡¨¡^∞€<õ;’f<:úp5t‡2®—3Ò	€¡B+@œ‚Zrç¡_<
<?à«1ÏJA?˝0ƒù¥ÍÎ·m‰D‚8è Y∏∂KùåÈıAC√±f≠∫9r*B#€Yês3°ÖõZBŒÙ,≈Ù–ØΩ±|ToÏ≈≠ËoY  ›æ-îÊ%øä6g:|&åsáÈ‡ìàiol€lÁ™ŸpÏ,Üñ€%BŒ‚)∞∑¸V
Â¥ô1r%[˛∞sË˚E¨L
ñÅè©¯ò„wfG+º@/Çú>µ—s§_N]7¢∞Õº!ˆz?»øÖ#é˚∆ª>†yÿ™ıÿBÀÇá!-»‹+º∞Æ,∂{€ìÄâpl~íÙ0§É∞~¢ëDœﬁéÏÆÄ5ü\zn%hã†ª0]”—ÅpD|jπ…Ì≠âØì˜quŸ·,∑Fù0˙~>Ì˜2Ún Ô¨Ôcÿ\w"sgÃ+≤'é∏W`_$ÊoOJá@Œ∂“‡:‡¸‘¡ÎjMÍ⁄2J£ÉÉŒÕà$"‹Ì2re◊@ÊHÁq™Ö4“èì)dÙn%î"KV≤5Ÿjπ±h˚∑6⁄ŒM≤'ŒHÈïú⁄±ªjkR»V¸!FÆhÎ?Î…îQƒÖÙ#µπ≈{b‘üÃÄ˚Ô|Ô¿QÃo*k)´=®#yKπô
û]…aåÀçÚ"ê~)ÍCæÇ;4Ú0◊;êoÚ+”öTŒÑRº…∑Ñ:Zì‡Ô¿Y¨∂ÔÒb ,‘;p?ÌO~@  4úxÆäœ ∞±∂ƒc[Ç»}B·w¬–3Çº≈VœÛ[2í5ÈÄ¥åàhio†Âå nﬁà[ÀF¬[∂l¨ß’úLjcµˇál#6h2l€à-Öﬁ~Ç#±õÙ†0._ÖÌ%H≈A@ìiËY¥èç;‘◊:JŸOä±Ã'¡úÊc‹+<L°ÁlŸ)≤…F°˝H[¸9F⁄1Ë49äÙ“FîQœ<ﬂ9£»Uri[.–5rí≤⁄—ˆ59ç£dB€urG©5“r©È[r	KY>Ë6πä∂4,ÂªÜõ≈ †{‰[¥}â∂˚‰⁄‹–ˆ#˘m˚∞ÃG‰ÖπΩÈ;gëËœÿñÕ'—'ËyÎ3£’X å´Eü"}à6˙=ﬂ¡8K˙'“¥Y—7Hgê¨)Ä~Ú≤°&§€Hç®ô ≥Ú=S¥CjF≠®Ô ÷‡DŸÕ≥ÕBr¶ç\KnGëV¥± }¯ÆaT–(‚G[#’w‰‰#¨É{	ª® ¯vV¯-PkbôÃm	Ô1ÕÄ”4lÀ⁄ï@#Ë$,•h–H:m£˚ ˘”ŸhS4Ü.¡∂$ÃÂ¥kXQ	Dó£Ì⁄*†∫
iÔhNõkF·,Óô@è∞"øÈîFOrœô‡ôIœ!(t€íòÃÈg¨Ôæ%P˝[VÎÀ•Ø0nnP}ç‰âîOﬂ"˘$ M¢Ç£õÃJiFKh3§Y
9âP√7u¿≥Ñ∂B™¥ò∫ ˝4ã,ß}E¬é‚ÖQAÔÀ©∑5Ñc}ÀÈ@§á”8˘ Ωßÿâ–£Î•Öè"+®“DFÛEöﬂ8-ºîë?“Î¥%åëz3[£qHÀô≠íQ8Rü∫i·k≈ } h£§V√F)H3X)Ô1 @∫¿J˘ÄQRW∑ãQ>R£Ωå¶ 	ux´ëŒÁU“Yÿ?Î$†ïté»Áhù/¬∫v ºV¥ ©1“j∫©8h]ä¥2h-]Ü¥i]âT=◊”µH7—∂ÅnD∫Ç¥ënEåûõËv§∑h€L?DzÅ¥ÖÓFäGœ≠Ùc§Ih€F"e"ΩKè ˝îÙ=éTÖ∂ÌÙ3§=H;ËY§vXÊ˚Ùs§hÏÌÙ“x§ÈU§˛H;È§ûH—Ôê6a)ªË˜Há”Äv”˚H{ëˆ–GHëÿ≤ˇ–'Hh€Kü"Ö }L_ uCœ}ÙO§Öh€Oﬂ"ÕA:@E–0Ù<HÕê∂†≠äZ"≠A:DÎ"E†ÁajÉ‰á∂#‘…È(mÇ‰âûüP§<¥£ŒHÈH«i§°ËyÇ∫"≈¶}J; M@:I;#ÕGœœh7§·h;E{!˘ ù¶}ë&¢Á: ÈéıY:È“9:îé¸y:ÈñrÅéA∫àÙ9F˙È"è¥ÈéTÖı}I£ë⁄g]¢ÒH≠ê.”d^÷˜MG*«RÆ–lﬁj§´4i3ñyç 	uÅæ¶”ëﬁµ„TÑtºßŸHãú8ÕE∫ÂÃi“çVúJëHNãëÏ]8ï!ΩÆ√i“&•æJ§√J}´ë(ı≠„5(ımD∫¢‘∑Èœ÷úﬁEj®‘∑…Æ>ßëZN‰¥©;“u∫ó∑GÈ=ÄÙ#éÓ7Ù0“(,Â[zi∞Bü"Õ©√Èíe=Ngë÷*t¡4ÉÌu#ú8}Å4üıˆ$˝ñ~ç‘ÉçƒF70Ó*£åæÂ50∫¬ËRoVÊuFwë¢ÿ¸›dÙÈ!£;åû Ω¥æV|è—s§HF?2˙i+ÂgFoëÍ1€ØåD	»÷ÚZÒoåÃê^X\+˛Éë%“!÷€7åÍ"∞„=≤Az∆Hæ•ç$8«(6{§§ÔhsÙt∆qπE["Ω…‰‘©9Œ√mÍäd¬’záv@jã#ˇ=ÌåÙ:áì'Rw÷áv¬]⁄…Éë;£ﬁH•¨æNå˙!Ö0õ'#§Ωåz2åîÕF∞£·‹ìQF£êæc‰À(P*dg˚∑ç°ˆªt⁄b´†°Hk±’˜hÑs˚	Æ›˚4)Å≠Ç ·>MF⁄ƒV¡8F©wùï≈(È2≥≈1 A˙ÖQ£<§(Êô≈® ©£\F”ë|MfTÑÙ%£iåÊ ùfTƒh“ªåä-Dë¡€π©wÜá¥BÇÛÙx<<°´–ˆ⁄™È:>õHø“ç‹Wug•F[ê6’U	è™z‹so“S∫©ŒÌ3˙÷Wâk‚9˝i	“oÙ?º’xƒΩ†˚ë6*TÖûÂÿŒóÙ_≠8–Oëﬁ‚˝IO#]D€+zi÷ö~ÅtÈ˝äè ñ˘ñ~çÙ+ûeà-í+én#˝ÑqÇR]\!¢©Wß«HèpÌöÑj§—hìÑgH≠∞e≤)«≈LxÖdSó”[§{ÿ#sAîÅ¶[síe∏+àÀ‚Tmè±’÷B]§lg=¡FÜÎV©-‹±◊leëç`E)ºÒ¥cTƒ<üÃ[s°Éﬂ¨n1ñ∞˚¡Kû…®k∞9ﬁó6»QË'ãN÷ƒ≈»U»‚ÿ˛iI»!‚&BÍà‘EåÙùPOa(“và Gíe∞ç∆!ıj	$Ñ"π5/Ñ!ç6ä"∞-ˆÿ≤8!
ÈY2PºêÄt1â›;í$!Èã$x>ô,d Ωœ<›Iäêç4öQ'í*‰"ıf‰I“ÑIHﬂ2ÍI“Ö)H'ı!¬t$ﬂB˙ìL°àçí59óµg	≥e+F˚Ç†ùŸB1∂∫´;–DaRÏQÅ∞@fKôDX¡X	Ô‡X_±ÑRäÑ≈ö),¡˙ÂÕñlsÑrÕ*≥2OXf∞Õ*¥@Xi,VlÔkT*¨3x.÷lãÑMZ,l∆ë(åZ"lA™D™∂JY#l√ëÄ_∂b◊Â¬^§HÖ}ÿ€èg‚m⁄$0‘∞I®2–f·êÅ∂á¥U8b†m¬QΩ+|b†˜Ñc⁄.G˙iáp€Ú¢7!'»˚¬ß€¬gÜ∏ÖSÿ€I@;Ö”ÚlF^!@	g±îe´Äˆ∞∑µ%†}¬hªÓ¥_∏Ñ∂o\Äéﬂ ñî«"ü	˜—∂±	ÿN„yQ¯Ÿ@_
øÍª,<√∏z"–5·Ö¡Ûk·wn√ëø#àf≥µ˚^êê¯l>d§=HO3§Ù†j¡‹Í{å∂ÁB-3ΩÜﬂÖ˙fP√k¨°ûËÅtF¿ùHÏÑ‘Àd#vA˙©πËâã˚D[±;“,≈MÙB˙Ÿ»]Ïçt£êáËç‰ÿ®ìÿÈG†.‚@§•XªßËã4∏Pwqíß-POqR ñ‚%C:Ü•ÙG µ∆vzã˛f6∏S*P?q4ímÓnb0éKŒt†a‚D√∏Ûyôÿ£pq“5ÏQú∏)∫Óg‚§/Z•ã+ÕÙUó'n2É˝∫†Ï!˘‚f§·#9ΩãT¶–˚Ü⁄Û≈èÃÙyü'7î2_¸iÅBßqÛ≈ÛfÛWá¿ä|GºÑﬁ∆H[™ª€x¨]•M
]5¨ÇwƒÜäﬂh±x=KpÌñâ? =iT.>¿5xf
Ó/bµ!nï¯ãÅVãO¥V¸ÕÃâúıÿi·DnxÏ±S∏9ÏP£1ÖÁBAo°^Ô˙ã7Ë‡	áu&>æÕÉ∆ŒwG´èèÂò¬3®[ñAé3FÖı<‘hTa…à4Àé$;4yıK'2&§”Â!£ôñÜƒZRRR∂ëÈp‘ÇŒiL◊tˆa˛Ø›[ç*å±]l⁄®9Ëz'–_ú[Qr–Ùâ=hLs–◊N†ôòøÛù1v Ë÷¯VLt9Yóíß¨Æz‰ùŸü‘≠G^V¥ÍH~ÛÍ»Ù>j¬TO¶›gb„RU◊âÜ˙∞∂ÌÌK…¯ﬁ√Y9ÀÀÇôN∆Ù”“8¶—†˝Û<>±£‰UpÀ9Ç˛y≥¡⁄⁄¿”ç;Ê≤ÚªŒô t@è“ YpM≥*LÓø4(®ì˘†sQá/}Ø¥SË‚Q†f#P}A//≈ña∫≠®æ†ëﬁ†ÁGÅûCı	™ƒr*YÔ∂∆ØaöΩkú∞ëµÕß”R¶Ì:UBk;mc˙Q'Ë—πN€Y˙Aßòñu:‘H≠Òf‘n¶AKÉAΩ«ÇˆöøkÕZ	Z∞¥s,ËﬁP–Íw†Ñ?PùcA€£&.ùà∫u
ËG®•¡†©ñaÔPGÄvwj	—tÊºè9übN!Í'†É–Zä÷ıòÛGc˛&Ã?Ç˘ƒt∑Ë}{–ÁN†¡Ë˘zˆ∆t:¶'c‘aLü≈t"¶s0}{zì);"˙|Ã¥ü*ñ#˜œfZÒ¨Åm®Püè5˙˛R–Lı’r⁄*-;‰IN∏û`zë©±I9Õfjø'Ã¨Eó4ÀŒ§W≈Vc˘ÙK,n◊L/u9 Ù<w2jáéﬂ±ú∫@T◊Œ†Ò›N∞ˇ.∞ûÎ§›◊é†·8-º„ËD÷Ãø„ËIñ<
ÍLB;§±#t6k≥Y7tcHuÔØXl◊^PÊÓ^;òvå®bÎ™Í§Uªôﬁtkq ¨∑¥.òæÙÑV˘u¸ƒÆ3)ic
fªç}6€5ΩÊ∫%sÚACßÇNõj*ıƒt®7®¥t} h\V6kÌ≈KO≤≠g≠`–:¡N§›õ‡édŸ¿fò”éÈz∂K@∫C®¬~l?ÏHVTv	ÆGÃ{•al%“ˇŒË9~®√kƒBŒhCT∞≈≠I+6Sº¸é§mºO´é‰L,hxe)õ¡¶≥AsGÜ2œ∑®íôn-Hc2Ùw91t"Ê\¡ú€ò;tΩ7ËÔÀAﬂ≈¸",at~∂Fêﬁ˜l√8‰£u*jë!é÷ãå9%h]¸∑úäøÂ¨¸[Œ∫`J{¿Jh7g3KOûÛ!ÊÔ3x~»fJÍsHiß{LÒU8≥möÂ®¬éÌ@a∫¶ﬂ`z&¶%W–gòs5µZs1Ω”é®ÀQ]P@iCP+,Á
˙ØGÌÅ9ﬂaz'™Ê„e¢∫bŒz,Õ’ﬁfº∫¡gl8ÄﬁƒtGL◊)Å1	û˚¬ëíÓ˛pdÕ∆£ØIÅ‰ƒéµs¶oóûe#pâùSúòÁE6J}Ú∑Òÿ1ÖèF}b7¶0+vÉ£ö3üÉ	WôO∑Ñoÿjèg€R<€˙»€ô.∞›eø=®5y1¸vpk“W^∆“…6†ÀÌAõ5›Ê˙“Ùq+–zm@]]0’ãÄ∫ôÅ.n ∫Ø	®…‘∑≈2÷Á@ËWîø”Ö¡˜ÇqW	Ü^_h˘˜^{bø:≥ÿÁ¡†$ƒxÏ‘#õß[Ö®G–±
X·7∆Ç&ˆ5MùQ#cAÃ«ú= Ò8Í5Ú£¬ë¬∆∞€SW6Ú≈/ôæFµˆ≈¥éø‰FIÉN>≠ÿN7òª)∏oË
z°kÎW†ßm%^ûÕB<I"[√lÓ¯^GX…Œ!ºGêvAmè⁄	µ™j?T_‘°®˛®Å®„P√QcPQ”P≥QÛQß¢°ŒA-A]åZÅ∫uÍf‘˜P?D›É∫ı0Íq‘S®ÁQøDΩä˙Ím‘{®èP´Qü£˛Å˙’4˜j‘:®6®v®ÕP[†∂AuCÌàÍâ⁄’’uÍH‘ ‘±®a®—®	cùHÎJ∏Nû<wq'2mFe»OEkÍ‘cÎë	˘≠{A∫s*Q◊éÌHæöæïï„<™Uo'RT¶ã˚ı`∫5d)¨˘å¸|ÙÛt»˜Ï„DöÂG˜U8) ˆ]¡Á ñ¸)Û¥Õ∏oØ÷≤ŒÎ2Êázı!Íœ®OQ_£öç≠á⁄µj‘®PıÚgÕ>Æ#Y4'òÈßΩ#ô~Äzµw”èà≥w„Ω‡ÂO◊ôŒ2+fö◊b”ç1ıhÈ}òÛsCñ√Ó6≤c9a3ñ≈†‰6û˝£:Ç˙tıPè4ıÑsçÕ6√|,ùIÈ¨ÚqŒ‰¸∏ÕLWé€Àt√¨3Lˇ˜9”S≥Ó0]6˛>”ÿÒ/ô˛<´Œxg‚>æ≈xv¶pÈ:^&W|Ÿ59õêj-ìwŸπC∆k~ô<◊9km·~E”`¶G-f¯Í˛˜lTO≈˝èZT|>Æaï…Î·;-xîZÚ{èAÂ3HèÍ…Z’¨{ﬂÒî¥_öÀÆö™º`Lb9›¡g√åa,ÕÀ¨∆zÁ€¬(µg˘€öB∫⁄6ƒ–ªƒÒ<Joßø¡ö˘Ø÷è-Øˆé∑j≤“íæùŸÏ/c◊<œ∫œÔD∫ÆÜÎ“€ΩÀ∆C˛‘ç®€PﬂG›Ö˙1jÍ'l¶ı¯Ñ›Ö≠JLc%Dt
ˆ≠Ÿ∂Å'ôæIh$ì!a∆CÌW-º9^ù)áƒÔµ^Ï±mûèX˘C&¬
eWŒ}lÿÆ˛§∏öµ9Ø+t+¨ôﬂ∆ˇ5ÁO÷Œö9$‘ò”ô,àñXNja)ªÊ‹÷tË(–ú`– X–_‚@W†nFÈ]Ë?ùyB…°çH>©ÀtÑπ=”¶2û+eÂåil…ˇ™N Uñû√œ™ıHBà{h=“âiD»g¡"i¡vBë]t…vá"íeù`mCNã ÌA`Ö¸ØñjDI´yû°î‹ùÁ≈Ù˜•∞6`^`m{áÚı>ÉY/ô≤;kõ1Lw6=ÀŒÜ^Õ'∞¸ï0≥P¶1÷[2˙_Ü„ÚΩög∞úÛN∞CÆw…e„c#ÑB∫ò•◊ô
B°Ö>≠†Ö–µ˝©≠¯±	ûòÁSR¿‘√tu£ELÖ¶êÈÈW-@ÌZAŒ 6ãXKŒØdÛugm+Œ üªyÖÍ‹u&ù AπèqÆ˘™–WÇ'ŸZz‹tÈj–œª°]—≥î≠[ÀÆÎYOﬂÔ∏ÖÈ9‘Œ]∂cOw≤V˛√¥v≠£LoÈ[òVÙ±¯ËÖß≈)¶„l!gR”KLÔ9B:—“≥[AzYkå•7qΩ=d⁄Zka-–Áµû1˝Å“~5É“6à†£Lßÿ»‹°@◊k´¥uÂñûT&≥¸§íÌ,Ω5æ6KÁ']‘‚Œdº'ôgÎ˚‡˚“àl=ÓCi\∂˜°ï≠ÔÉJ…Z‹œª§lC‹i∫!nè4Gã{ô±G⁄¶≈’ ¸X˙“∑_∫ià€/=–‚Ï2˜Ké9˙>X%≈ÂËqá•¨=Ó∞49GﬂK3µ8ØÃO§Ü∏„“2C‹qi≠Áõy\:™≈gûî~4ƒùí~3ƒùÇ"j˚‡)©˚D}<+Mõ®«ùóÊO‘„ŒKK¥8!Îº¥Rã´ìuQ⁄hà˚R˙–˜•Ù±góı•tMãkõıï$‰ÍqW•:πz‹U….WçÎûuUÚœU„|≤ÆKÜ∏o§Ü∏o§˜¥8ˇ¨o§›Z\h÷w“AC‹mÈ3C‹mÈs-..Î∂T≠≈Âe›ïÏÛÙ∏{RÎ<=Óû‰ëß∆g›ìÚ‘∏•Y•qè§Ü∏G“1-nM÷#È¨˜^÷œ“%C\µÙù!ÆZ∫Ø≈Ì…™ñÃÛ’∏O≥ûJùÚı∏ÁRü|=Óπ‰óØ∆]Œz.jq∑≥^J'qH_‚˛êÆkq”2ˇêæ◊‚Êgæñ‚ﬁJ/qo•∑Z\YÊ[…qí~˛‰!ìÙ8ì4Iè3…aìÙÛüIé◊‚éfö…ÈÜ∏ZrÅ!Æñ<Sã;ìYKﬁ§≈›»¨-_0ƒ’ëØ‚Í»wµ∏3Î»M'ÎÁøzr‘d=ŒFNõ¨«Ÿ»πì’∏«Y6Út-ÓeV#yé!ŒN^jà≥ìWjqB∂ù\•≈Ÿd7ëÔ‚ö…ø‚ö…Ø¥∏ŸÕ‰.j\álGyrÅ◊B..–„Z»•j\œÏÚ2-nPv+y≠!Æçº›◊Fﬁ≠≈çŒn#_÷‚b≤€…oqn≤≈=ŒMn0EçÀ…vì˝ß®qEŸ‰ )z\GyãÊYö›Qæ¨yÆÀÓ"õ
ƒÔÒ<ÂÄ©™ÁŒlOπl™Íy"ªá‹töÓŸKn9Mıºí›K.ú¶z>ŒÓ#7ùÆ{zÀ-ß´û$«[.õÆz⁄ÂêΩuOŸØPıtœÒëœ™û~9~Ú‹∫Áy—’3"gàÏR§zN….?+“=G ØäTœäúëÚ¶ô™Áûú—Ú¨Y∫gÄ\2Kıºò ˚ÕV=´sÇÂÓ≈∫ÁXŸªXı¨3q¨S¨z:NïÔ<√‰«öß«ƒ0ŸqéÍ9pb§ºgéÓ-WÕQ=É&FÀ÷sUœîâqÚûπ∫gÇ\5Wı,úò ∑úßz.üò,_õß{¶ ∑Ê©ûLLïCÊ´ûß&f»MËûYrÀ™Á≠âYÚŒ™Á´âÂπ%∫gûº®Dılîõ'{º£zv…ù,€ïÍûSd«RÌ¸ê;Eæ\™zf‰Nóœ-‘=g»ójÎ3wÜÏ∂Hı\ï;K>±H˜,ñœ-“èÄb˘Ú"5n[n±¸@ã€ü;OnµX?»Îq‰ã’∏Sπdø≈j‹◊π•ÚlC‹"y±!nëºJã{êªHæ•≈ΩÃ]*7[¢«ïÀmóËqÂr«%júúW.˚/Q„lÛñÀÔ‚*ÂögÎºJy∑ÊŸ=oµ|nâ>kÂÀöß_ﬁZπ€R’s\ﬁŸ©ÓπIY™z&Âmíø’<Ú∂ ø<ﬂïﬂhûÛÛﬁï] ¥y»€!áïÈû»	e™Áéº‰öÁ·ºèdˇr›s∑RÆz^»€-;.”Œy{ÂH'ËwKΩ∫ÔÉ íûÂÍæ_£1æQ›htœ=˘ˇ`ÔM‡™™∫>‡}ŒŒŸpÅÀ,Éì¢"¢¢"Ç¢†Çâ‚)&•&ö%ËqFs¿ïLÀä“≥JäJÀ
“Ãåû‘0≠∞æµˆŸ˜ûÉZOÔ˚<œ˜>øÔãﬂÔ˛ˇ{≠Ω÷⁄Û>√ΩúUiì¶$Ãâ™2ö7bÂW´’∆VL¬;êóÊT;hÚﬁ2ve“E2%·˙ú∑åöº£∆ﬁ‹À;jå„ñwÃò≤Qm—ª∆q6À°èækúd≥Ù§q:ó¶$¸<Á}„rçﬂ„Zõ•ê}∆∏’fÈí]g,≥≈»˛»¯ú≠·Ÿü˜i¢ú5‰y_ÆÌü}÷Xcã9"˚úÒ¥- ‰ÏœçŸ¢ÃŒ˛“¯π≠º¬ÏzcΩ&fÉÒ≤-Ê⁄Ï„Mãæ26©≠ΩdÙÿdçπ#˚≤±Õ&kÃäÏoçÌ7©1ØC7YcVg_1ˆŸdçYõ˝ùq†ÕÔ´Ïåâ∂~Ãæjo+A»πn|PÛG„#õ‘ö˝hÃ≤Eq…πiÃ”‘ÛñqÖ∆Ô„:çﬂ/∆g4ñø˜€¢¥Õ!“À?Az]„'H«4~Ècõ_Hé$ù”¯…RÉÕØWé,]±˘…1I◊m~cs•?'È∂∆œI2nV˝\%«ÕVøi9ÓíÛf’œCÚ⁄¨÷”C
ÿ¨÷”[ä¥˘ÕÕÒïzj¸ZK˝6[◊Ê‚ú÷íe≥umn…i'…[TK…º≈Z¬ã9˛R€-÷òÔÂ¥ó:l±ñw%ßÉ‘U„◊QÍiìFıÍ(%3È}zC>È,çR$·≠π¬‹Œ“ÉLR~µ”Yz‘Êóﬂ´≥4è˚}06∑kàTÃ•ºµïˆ]§M< {Öztëû≥≈¥ü*Ω°â*ù›bmmwßP)≥‘⁄Z¡.ô∂™µÓ&πmUwÔníÔV´üÔ‹nRŸV´_ßπ=§»ß’›;Jä}Zıãíü∂˙ıò%>cıãü€G:ÙåÍ◊W™yFıÎ+ùz∆v‹ú€W^fıõ07V∫X¶˙ıóÆñ©-Í/ïmS[4Pª]mQÇîæ]-!Aö∫›vDòõ …;¨~ŸsáH˚w®%$Iï;¨„^47I:∂√:“ÎÊóNÌPK!’i,GHük,GKwXÁÀéπc•Fçﬂ8©…Ê˛Ë8È7õﬂ–Gêú m˚À‹âíKπÍó.yó´~ÈR`πÍó!u∑˘Uœ}Xä“¯Mëbm~µŸS§!6À˜ÊNóímQ~ÃŒî&j¸fJS ≠˚ŸósgJY∂(?Ã}T ∑˘ë‹«•"çﬂR±Õœ1˜	iìÕØMÓì“võ_◊‹π“nç_ût¿Ê◊77OzC”⁄|È=Mk§/mmHŒ] }£âR$]-WG≥HZ˝,Jk…+g˜.íˆ<kùΩ_$ΩÛ¨u$<æT˙ËY5 rÈÛg’(À•Fõ_÷„À•êùVø¬«WJ˘;UøU“¬ù™ﬂ*©dß’o|Ó*…Úú’oJÓZâ∞?<ˆø÷gùM9Ë€>Îm“•–Î}6⁄§)	$z´ª£(«ß•ƒ]÷c«cπOKc4yœHwY{iaÓ3“Éöº2Èë]÷ﬁ-Œ-ìû∞YnÀ}V ﬁeÌÎWswJÀm%ºùªKZªKmÌniã- ı>ª•m~ﬂˆŸ+Ui,˜KÔh €/}®)·Èí≠ÙœrJ∆›™ﬂ!…q∑ÍwHÚ⁄≠˙ëBv[˝æÕ}SÍ™Ò´íz⁄¸~À≠í˙€¸\ÛéIC4ñ«•6ÀÄº„“∂òQyß§tõ_rﬁii nkO<ê˜æÙ®& ié¶ûg§B[î«Ú>íñij˝±¥U„wVzV„wV⁄oÛ[ú˜πÙ≤∆ÔÈmç_ΩÙûÕØ4Ø^˙‘fy Ôk©Qc˘ç‘¥[›øëöw[gduﬁ7R„÷y:ÔäÙÀÍ‹mîZÌQ£4J¡/™˚n£î˛¢∫Ô˛ mcRô8ˇææ◊§3\äÈ∫Dˆ≤òdÈ†«˚˛(Õﬁ´÷ÂÜî∑◊ÂìºíÔ>k	ÚnJÂ˚‘∫¸"Ìﬂß÷ÂiÏKj]~ë¶æ§÷Â∂Ù§&Ôw…¢…Â“ó‘(zYYUo–Rï–RíÀmQÆÂQ9˝ek}æIé¨P£8 —VK˜|G9Ï´e«|g9¯U’“U{’jŸ'ﬂUN;hµûÔ!ÁR-[…Eá‘^j%≤˙MŒo%ó≤˙ÕŒ˜ëK©Ω‘Zﬁ•Òk-Ô∑˘ÂÁ∑ñŸ¸VÂ∑ìèi¸¸ÂZõÂ∂|πŸf˘r~ê‹Î5µf‰8õÙuõÚ◊Tø`9˚5’Ø≥º˚5u∑È"`“z"8öﬂEælÛ´Œìõ*’9ÿMÆxìÕd·ìå˜ÚªÀrïZœ(9¥Zm_î‹£⁄Â\~î[mçr)øè|πZıÎ+7i¸˙ Õ6øk˘}e√[Vø€˘±≤√[™_ŸÎ-’Øø¯ñ’Oö◊_N≥˘πÕ(o◊¯%»{5~	Ú!õ_€y	rª£Vø.ÛÜ»ñ’/I.ÆQ˝í‰í´_ØyIÚé€±jﬁ}Ú~ç_ä\©ÒKëkl~#Á•»˙cVøIÛRÂA«Tø—Úàc™ﬂh9Ìò’o∆º—ÚFõ_Óºq≤Á€™ﬂ˝r¿€™ﬂ˝rÁ∑≠~ãÁ›/~€Í∑nﬁyí∆/]û°ÒKóü∞˘mõó.Øµ˘Ìõ7Y~^„˜ê¸™ÕÚıy…ç6À˜ÁMï3è´ÛÛ9Î∏Z¬#rﬁq´_√ºG‰í„VøÊÕê_8Æñ®|P„˜®\eÛ˚uﬁ£2y«ÍGÁ?&˜{GıÀíáæ£˙e…#ﬂ±ÌÛ≥‰õ_¿¸9r±∆/Gﬁ®ÒÀëÀl~]ÁÁ»56øæÛÛ‰[øy≤˛]´Â‡˘Û‰‡w≠ñ˜œ/êÀﬁU{bÅºÎ]µÑÚ~õ_wßrùÕO0/íı'‘ñ»ÊÍzX"rB]+À‰˙j	+‰À'‘ò+‰ÊjÃU≤”I’rç‹Í§Z¬y…iÂ¯0&n˙¸5Úô”Í^P"ßüQ˜ÇrX≠b˘P‹Û7…´>Tcñ ?T€W*ó}®Œ›R˘ÏáÍ‹}FÓ]ßñæMTß˙mìá◊©ksõ\TßÆÕr˘çﬂN˘
ì»˙íJ˚ùÚu%äÏXb ;Â_yû!™“˛9Y˜ëíÁe œ…¶èîºàRìió∆•∑«yÄ4éK≥¶M∞Kûƒ˝,”∂B^&œk~ªÂ\™Qiø[Æ‡“Js©¨‰H∏¥ª§/¯5riPi™º,|Ã$≤<m´ÈyŸ«&-0Ω áq)?-¬¥GN‰“å“∂ˆ/ g∏Ù5ƒ‹+á}¢H¯4ä}r6ó.=h ˚Âçü(#ñ?Ø&ÊÄ|Íuƒ^ñÎ>Q˚ÛeπôI ≥˚^ñug	ü›˜≤lØH$ÁæÖÛ+‰66iı¸ÉrÑM⁄6ˇuy†Mzq˛Ú8.%ty}˛[Ú.â√OŒ[ûoì>öˇéº∆&}=ˇ§¸¨M∫>ˇ=˘óFw-µÚô≥j≠ÎÿYÇıó∑V	yÎf˘ÿ&EƒZŒ⁄§‡òﬁñÛÚyMîœÂ&&·ì*êœÂGÎYâ	[9·9èK{{≈YæêO’´~ÚŸzµ?‰˙z•Áœ
˜Y‰ÀLj^/»W2π†H√˙…|AÕª _‘‰]êõ4yÂÀ_´yÂüæ∂ñg _ÀæóTÀKr≈e’Úí|àKã≥«Zæë-ﬂ*“Œ.Y‰≤¸É"—U´_öxYæ…ÛÑS-óe√EJ^˙˘VvÂ“úÆÎ…9àKCW<K˛!GriX˛ ˜Á“Q∞º*ßr…≥ÀÛ§I>tE≠gìºˇ;µûMr’wjﬁπ≤QÕª!üjTÛ~íkæWÛ~íÎæWÛn ‰5Ô¶Ï¯É≤k‡ˇÒ›í}yﬁÖá»/r'ûó˝{Øf9äIo¯ﬂÄ∑Âÿ‘—¸MN¸AÈﬂ‰‘¨3dP∆oÚ”b˛.Ø÷î –2M	:ötUç¢ßSôÑO/)™ßO^UÀ3–yK]f≥úa1–çK#-”XÈõÂc#=£±îËYç•D/⁄,ÁX$|Mµîiÿ5’R¶—◊¨ñyôÊk,)]®±§¥ƒfŸ-Ä“˜5ñvÙç•Ω`≥\`±£˙Î™•=5]W-Ìi´ÎVÀ•{°±4—ﬁK‘Bs›:F´,&:EÒì7&yOv§è^WFÖ=Áô.πÆŒGZ¸£:{iÈèjûΩ‹§Ê9QÌnc¶Íns¿€≈&EƒîZ‹l˛@+z´I≠ß7ùtC+Â›∞÷zè≈õû∫°‘—ÍK«˛§Z˙“Ê“ÅõZÈ»Mµó|È±õ NÙ≠x–‚Kk[X6∂êÃ?k%ﬂüµQV¢±(a-,ıøh%Ø_µR–Ø⁄(]~’Fâna“¨ïŒ∑êŒ‹÷JS~”Jèˇ¶-!˜7•O=ñ∞òKóËêJπ4‘≥∆“öﬁ‚“#æ5ñ64˘wE˙§›iK[ö∆•Òß-ÌË*.=t⁄‚Gk∏¥§˝iã?Ω…•ü;ú∂PôTHÍ,Å‘ûKcÂœ,A‘ïKsAjO}òƒØ‹h œf¯Œ“Åˆ–‰”û˜‰”T&’ºÎHü◊XÜ–óòƒøõßß[Hó[H:A+E∂êJZHM-§TQ+U¥ê2t"üªøZBhëN©'>«•=ØS-ª–áıZ©àIÎŸo≥ª–rM^(}⁄®‰uk,•Ôs…n¨=HDR§∂cÕ E2I˘o„Pö∆§2ﬁë•$µóBÈÚ“Z≈í¯˝BÈ%Oûëñ*t•;mñ]iΩ"ëK°ÓaÙ†lï|¬È.ΩSTI£ÿcl÷aDDAw∫úIóÑ´ˆ)ËEü¶äÂƒ¥˛ΩÈ^.’îLö⁄õ^d“j“{`rA?∫‘¡Z∫Å¢ÂLj‹aœJ†ƒQ‰˚R™ê@”úP* uÆòóÕ%Ÿ•uLj†≠Vœ,H†[IËøÛ yû∏vD©‡yû9}¶&–õ\¬o*†<≥⁄ª	4≈¨÷,Å¶õ’ö%“≥Z≥D:…Y-=ëNsVKO§≥ú’“iæ≥:Óât©≥:Fâtµ≥2F≠≈”ñD∫Uc9òÓ÷X¶∏eï˛¥e0≠rVk=Ñ6;+˝Ú#Ãâ!4¿EıB;∑ê∫πXÁƒï¿!¥èãZﬁPö†±JÔ„ñÕ‰¥e(ΩüKΩ‰”ñ$:ÖK;=.%”\≤˜=mF7qilªÀA˜—≥\2\N≥ñªM
µsU§ÚóÉF–0WµÙë4äÁ}÷˛r–H:‹U≠g*çu”J7[H¡ÓZiåß2Áªed§“â\Íü1§©\⁄≥∞`ù≈•bñÉî√•#ê7öpÈ<‰ç¶À∏t{Ù—÷cË.9å˘§-ûj∆“ûj]∆“}-Úz*Ì.Æ)Kﬂ‰í;›T0éæ√%—sM¡˝ÙónÅe=À•)tM¡¥ûK7tk
&–Î\⁄≠ø4ëÍ[)R?ª#ñtÍ¡•…sm√•BﬂÌ“ˆ\˙°›öÇ…4îKèl/»†=∏¥2hM¡C4ÜKeÌ◊<Lqi™∞ª`
}ÄK%Ú˛Ç©Ù.%È∂L£èqi'›^ùÀ•ﬂÈ¡ÇÈ¥êKoíÀAô¥ÑKÕ“À∫ìK{tG,3ÈK\∫_ƒÚ(}ÉKœí#ñYÙóæíj,≥iG/EZ·QcyåfrÈ∫œiÀ„Ù.ıÉ£a}¡Kï'ËÀ<Øÿ∞ª‡	˙é&ÔIzÜÁΩm®*xí^–‰Õ°ç<Ô„ÚÇ9tüèöóM˘(yOB^6≠ıUÛrËy_ær‹é‰–%≠…√Áx¡\⁄≠á6…•√€®~πtl)ù[∆P*‚“ª
rÈ1çe>=ÕÛé{¢t£Ei´‰}È˚AA>çk´ÊÕßÉy^'?îf∑»Ài!pÀ◊}QZ≈%£ﬂÛÈwÀ⁄ƒÛñ†ÙX;m^^;>∂A–O4yh=œ;ÿ•	~⁄ºá˝îº\ªÀAË6?uı—›~ÍÍ/¢/qâÃJ^Hs…k∆˘ÇÖÙ®&Ê"zRâ	Râ˜"˙)∑,⁄ö*,¶óπ¥Ø'J?qÈÖ~(˝∆•√˝JºS…_ëÆ‰¶
K®óy%ﬁKh+.Ωπ9UXJóq)7•5\ZS‚Ωîn·íÀ¶J˚etóZo2êetóˆo¯ﬁn9≠‡“Ãd9=¬%¸Ø⁄b˙ó\'_((¶ó∏‰7˘[ê~‡Rv∆’ÇÙ&óñf¸>zã˘≈}o∑í˙qÈë©¬Jö»•∏e(Á“ÿe%ﬁ+È8&-êœCø<E≥π¥c+JÂä%˘}»ÌÇßËq.Õ¢+|ä^·“û$
R´@E∫“*ö®åÙª˝≤öV0âˇœ≠d“%·ùxs·jZ®Ó¬kicÈV†:“k)	RbÌ‡]∏ñ \⁄PXBÕ\2ë5Î®óöçk
÷S_.Û8mŸ@Éπ4ß]ß¬ç4ÇKì‹¬7—>\z‹'¶p3¬•7€§n•#∏‰·?©i:ûKÅÅ≥
ü°ìπ‘™}~a}òK};Ã*‹F≥∏îú_∏ùŒ±˙¡ÓΩÉZ∏¥Ω†úÓ‡“ÿΩü•GÇ‘∂Ô§ÔºD„ö¬ùtO{æõ∫n)‹M;+í‹˙¥Âyö»•a–/–Â¡jî=t-œãë™
ˆ–∂<yëV1I9ó⁄Koq	œ•ˆ“»Nl¸ÿYﬁ^:úIt‚ö{ÈXEbgV{ÈDûágV{ÈTû◊úS^∏óæ¿%<Ø€K_Ó§ñæóûÈ§ñæè ù’“˜—¯µÙ}4=D)aﬂö´˚Ë‘µÙ}Ù—µÙ}4õÁõªØp}=D-}=¢Œ≥}-Æß˜iÆß–\O/|•≈ıÙÎ-¸éh¸cﬁ‘¯}ZX≠Ò˚ÆXøw4~ô1'4~?û‘¯˝ñ˘˝BSÎ3ÙJà:∂gËı~cŒP}EÍC3c>†Å\
ˆLå˘êFr)¡73Ê#ö •ävâ1”.%d∆ú•E\öîséñpin˚ÃòœhóæÎêsû÷pÈΩ‡Ãò/ËE.u!â1_“&.µñ2c®[®"∫%∆|EπT‚ìsë∆s©æMbÃ◊4ïK=˝3cæ°Y°jk/”<û7Ÿêí∂?/∑ø+-∆Ô-∆Ø©ÖﬂO?„Ç[?Áøj¸¸ª¢PuDªUööâvyÕ÷ëê¢›k\ ˜8\®≥{ùKH›HvÁπÙïèqÅlß≠ãΩùZóÍ<;µ.1Ãv⁄6∏∑Û‘¯ùŒÛ“¯_‡cßmC[ªöZ˚Ÿ5Ú∫ÑéX¸Ï¶wU€Áo7ß´jÈo7ø´b˘ç~¥Øø›k\g±˛vi¸Ï4~vﬂrÀ0]˙Ç ªõ\ZF”⁄˝Æ±≤ì¬îº|ß,≤s„“'ûS¥∑ÛSwçv}¬‘]#ÿ.6L›5ÇÌ^U$˙”ÍôÇÌﬁS˜â`ªcaÍ>lwÜÁ≠Œ…K◊puü∂ÛW[l˜ZÈX∏ZÎ`ª”-ÚŒµ»kW⁄íx9(ÿÓGçeGªﬂ5ñaå`4∆"í/Ú0};q„XƒïcUçÇ/˜Añé¯ÛZƒ«5òS™¶ˇ±R≈ã1˛Æ8≥YGÊ˜E¶Eû∆»ò´µƒy£‰ﬁ©—ìEÆ¨á„ä˜ΩsW®z%ré´E≤”ªeZG:∑πóFOˆ˙˝±ﬁ@~¯gπFr=ËØŸHƒ≥√ˇƒR&·pH%\ã‰™∑ˆ¡Ωû¸∆Í¸Êå≥¶DMN"Ãû0{¬ÏI{ÌËã§,S’ÑçRıÔ,WF_ ‹ﬁGÎ•j•älŒà∂ôS6”˘„=åöÍIàÑèªhÛZî™Ë±]J˙ u*e9Œƒö‹N∆9∂{°Ÿ¨'7Óø[Øÿ„‹C∑99ˆﬁæ˜“cã‹˚‹·π)ä”mß›ô€v÷|}®VÉëw/ƒ1BΩZ‚›uªwm±,‘‡¯>µı˜G©z\ß÷⁄‚àãdS	Í7NPjã«ôòªß≥í∆‹Ω†◊ƒawé{˛xLçG‘±˛ug_°¶e==
¥·.çZìg®£s$O©èVso/≠Mßlµä∆j£jî∂úôjmã5kÆÁ6˜“õÕ^Æí{w€=éÀ{˝y.Œ]ã:‡∏ﬂªî{Î±oˇö^Ykñ©%jgoÀŸ•éªí∆˘f]èJZYÉ'«™æ£“Z¶u‰ˆ5¬ã)™o[ÈõÿétõÉ
6‹yL·kVúu˜»Ø§˝ùG®Ùhb€%¥È§i™∆rgZ°i‚§ıàÅÎ–F— äº7¥iÂhr05m÷›[£çˇÁ®å≈ìS0›-T›µàÎ÷”∏;}	€ì'¨¥ŒkMEÚ»¥;k•¥ÎÓ8s„‘¢DSÍˆ’H6”Ó√ë«zx ”Á≤}ª˚Vƒc≠≥±ÂËk„+πœè™Û·n¸ﬂ’ˇ_Gß˛à·°

∂Ù¢TL±Ó∏´û QÔ∑Œƒ∂¶ºwY÷}¯ˇÕtªT<r√„T); €±#◊cÀq]Ô∞≠Aë‹?5ß-xâÿÇ˙ßó!~∫sÂ‚;” ˘É≤*ˇ®oÀÜYQ¥ùãbØ*g° ŸfK/QÉÍ‹ËŸıœféÇ˜OPÒπ)";Óˇ∑ßï=∂Ì4m˙ŒÛÑñπÍÆ~yj~õäö!¨’ÔWéò˛&”}'≤Qf=ˇ›‹ó¢Üc∫”bÃùª”
vb¯À u7Pé>ÿq§æŒäKx÷˙Kûµ>5Êœl˛(˜MÓv¥Rˆ∑¿u*v∫£V÷z&±ï•úÌc≥5zvÙ1ê◊óc≠256 QIõûﬁ”∏∫udD	˙ˆNCﬂ!iˇ<ı"”ÎHˇª4)!¬ø_9Ó+ª”ﬂÈø”ˇ_MøœÆÎu>lXè˙7∑˛’¥÷Wπ⁄}•s}rq)ö˜Ÿı≤Ö}⁄o&∂›XIkıñR<n≥‹1KPÉoñ“ë 1∏~1◊¿s€oVwı«ÜYKH‹5æ6≠\%)GCè’WõZä6A!Xb´QVç¿ˆO®◊x‘c=ıdEÓ$Î¢0W9ÓøR⁄≤Ì˜jiÀ¥pG+Z¶—f+ÎE3w˝ù-’Ÿüõ¢§UM;œºáˆÚZ¶uƒÌ©{iÙ‰v>Í{L¯Á®\Gh5 q˝á/å∆»_≤Û_÷ì≠BP£§ø[jEëÔ¥îVb*Û≠zÎΩ„czå]wØ√∂Ï˚W„´iÙ¬+æ^Fº“ú‡˙g^ÎYYX+[zV7k£ë¥âDäK‡ºç<•˙∂bÛ
sı,◊–"Wâ¨Æ,•zr%ÔN~ø1≈⁄?"YÕ˙°=ªjPŒ^î¿ÆªÆ’`dÂ|C—¥]Ø¶]FˇoıZ¥Œ·ª”⁄rÔ]á{ï¢M+gûJ:u≤öéæg˙œÎf’Tdbü¨bWRÍôòüœP”ù2TT4⁄ùÔT‡Äg}¥¸Î{ù6Œ_Ÿ˜¥gzˆG˝K∞∂_›l9µÀıXbmù»4:¶—ìÒ	™Øà≠gòØ˜Tœ0ÒNë5W{F™jÙ§v)⁄?7W ÎZŒÈ0⁄‡à[mŒ¿ªµ≥ìÒn≠3ú¡RÇo9æWd¥7ò 5;ÍuLØ'Û0∑Ìåâq$G&_cLüëˇØvû˘uÒÎÃÀH⁄n˛´æÛÓ÷‡í]å3Dâ£Ù!÷Y«j´gµ5∞òFVgâEñYÈî≈¥Éˇ{ﬂÉÍ((µj;E≥fß‹{åÓnùÛ¬;5w∆±⁄¸Q4≈R—„Ã±ŒÑ{è⁄ˇ‹æ›8¥7∞›˛'vÔ‚Ù2‘‡¸ÿ¸â◊bÃ≈s*=[w~oœrçd¸(,Î4ªÍWŒ«î˚“⁄¯^ÏäÏπ)Í]Ÿ;5z«¿„(wqï8JÈø/bw°•y8Z:WKƒ˙¥º¨ﬁ˚˝kxÔΩ¬@Í¢ÓΩ£*(Á†W1;∫©˜‹˛¯Œõ≤Éè«›U˘fjx¸?o≈ââ÷#àreΩkΩr""MlÌÌsßΩr¶ßÕø‚ıﬂY ü€ˇß-ˇJˇok´ùœt¨<˙Ê€ﬂπÁ˛ù˚wÓﬂπÁ˛ù˚wÓﬂπÁ˛yÆr∑V9cˇÎÁÆä˝_?„˝ÎëˇßW/ˇÈµ∆›ˆJúˇÑ◊Ó:HkÛÁΩÙﬂf˘Ô∫:VÓ:Œe˜ÁX5V¸Ô\Yˇª∂ˇ˜œáªGÁØØ¶ˇÑ•∂>Oe˛gGÌœ˜…?∫œ†›C˛ı{/w{˝ı˙¸˘(ˇ{Ìˇ-˝˜ﬁÁ˘Û˙ˇ+Û‰æ˘à”V¢>2ÂüG¯Ô‹©˛Ør=g˝sÂﬁÔ'ì≠˚√?≥W“¯õΩø˚¸ˇπˇ äSf◊_±ÃeødpÔÛÔôW LæW±o%îﬂ‹*ø•T~c©¸œéÚ›¥ÚünÎ≠ÛºÂ[X	∑Êœ˛/@˘-‚›ñ§∑˛:˝ﬁˇyq˜ˇG‹˝_w€høì∫˜Ô˝tÏ{(=ˇJ˘JπgﬁÉçéÚÔÈE®QÓ±OË'~<HM+ÂF¶©xÜ}Ø˝Ÿ åÉ=….¯´6wó•‡˝ÆI˝oÎØØˇ»ÚèfÀücÈ4ÎlYm?+3ƒ˛©ñÈñ˝¨Ëïﬁ˛a¶”[kÿÚ€EÛø√ª˜mÂ7¢ ¯égø«÷^®ø|–ëÜçj´qÌXè˛ãR≠GÎØöˇ¸wVñkdø‘í¯TfëÇ⁄V(ı¸ü∂›e¿üç£b£å¬7)ˇj?ˇªœ«]˘’Ø£T‘Ê∂esª√√5†Y)
*ﬂ¸˛OWÑˆ∑:⁄ı’núäTÒŒv)VﬂÄª⁄ıWP)Ât¥µu:r0E’km¢∫s¶iWÓgl>‡¨hy›toΩÅ≠h„?˘%ÄzÃjy¸∫{7PÙwG¿Ul]À„Ÿ/¡Ó˛ÕÄ∂≈˛ˇV£≠ˆc˜Ó’{ÎˇZØ*æXñÆE4UÛ«øØPˆì2ˆÎ÷„ÏøA„ŸÉ~‰˜«π4¶tﬁ“≤Ù?j≈Ωœ∏ZŒmÕµ3˘ÓRAeV∑çó°eíCú‡„Lºâp|⁄ìA§+I"a	áO7¯D¬ß;|z¿ß'|¢‡”>Ω·”>1ÈüX¯ƒ¡ß?|¿'>·3>	IÑO2AÓ#£·.¶ ß ﬂO!ì…L¯¯Í!ã@Ú’gÉm.9_}yÉ‰Áì∑H><Ú6ô<üú ÛÅ-‰=b. ê‡BÚ1)^@>%Äã»§x!˘ä,^D.A)æ˙≈‰
YºÑ¸É,^JÆì•¿À»OdrÚY\L~#≈¿+à(¨ ^Iå¬J‡ßàù*‚(¨^M\Ñ’¿k†ﬁkÄ◊BΩ◊ó@ΩKÄ◊AΩ◊ØázØﬁ ıﬁ ºÍΩx‘{f®˜f‡-PÔ-¿•PÔR‡≠PÔ≠¿OCΩü~Í˝p‘ªx‘{v®˜v‡PÔ¿ÂƒC(~ñxœÔ$mÑù¿œ·9‡]§Ω∞x7È$Ï~ûÑ
œø@"ÑÄ˜ê¬‡°˝/ÔÖˆÔﬁÌﬂº⁄ø¯ ¥ˇ K§∑À$Fx∏ÇÙ*Ä_!ÉÑWÄ_%CÑWÅía¬A‡CdÑp¯52Zx¯0/~ùL^Æ$
ï¿G»√¬‡7»#¬¿oíô¬õ¿U‰1°
∏ö<)TøEÊ
o%ÛÑ£¿5§P®>F	«Äﬂ&ÀÑ∑Åèìï¬q‡w»·‡w…z·]‡d≥p¯$yZ8	|älNü&;Ö”¿ÔëÁÖ˜Äﬂ'{Ö˜ÅœêóÑ3¿µ‰U°¯rX¯ ∏Åàbb'^ é	/¯x¿'\¸Ê¸◊êâxãóÄø!mƒoÄ/Ò2∑êˇ-“^º‹˝◊|˙ÌOdà¯∞(,E¡WØf∞^X)ÍÅ Äç¿F`>TX#R`;aΩhl/lÌÅM¬”¢	ÿAÿ.: ;
;EG`'`'`3îavûùÅ]ÑΩ¢∞´íË
Ï&º*∫ªáEw`·—ÿSxKÙn%º-∂ˆNà^¿ﬁ¬{¢7∞èÅËÏ+|,˙∑>[∑æ€ ∑æ€∑É6¥ˆÉr˝Ä˝AˆÄz B9Å¿APè ‡.¬@!>]·&8í0¡>Î Ìºx†ü¯tÉO$|∫mHw°ZË!¯√åØbÖ˙˛$$ë©¬x2Müpqö0pw‡2“”!=“ÀÑ«`VÕÖO∏∏Rx∏;pyJ(ÑO∏¯î0∏;pÃ™·.n& wŒ!î‡Û(ú	>g√ã•˝ Ì`/vœ5√Æã«p0√Ü„Nb8ç·lÜ9ÄÓ∞ßπÁ˙ê’,⁄&Ü ˝»k,˝.≥©eÈ%æ‡ûJ&	®ôÕp5`_RÕ“ﬂ
¯îÏ•">w©àœ≈}WDÕ9ë=çï4dßë@BB≥ ˝÷Êìíªb)‡Ò•O⁄Ö≠'~∫‹œ¢∆Oáöé∫Æ]û'∫¬¬Cp‘¿Á6O“ø57J(–c‰kü⁄;Mèœ©d1ßÈ'-Gçﬂ⁄I∞≤ﬂö;÷'Í˜∞Ù`É{Ó3B#”41M3KÎLc[Ã‰öÒî·dÿ~ªSÜœ¬*Ï∂±®3L(>iWg¿:úgÈÛ,]g¿gDüg∏ç=]≤AÍ∫¨…Æöyù¸ÕÆ…0rê£}3îﬁ÷^oD}≥a‰ÿû†y∫€@¿çcG Æ˚`n∑ôÄA≈≥ó˜Yjo2÷çÿdè1∑Ç¶∏d`2√È[˜ÿªÒ)˜nF|ûΩ	"WŸ{	óM‹å”∑¢˙z	q”–ü:ﬂl¯∞‰*§ÒnF|FΩõüﬂl¯f ÷ÍJ¡‰fƒ'‡ªÒ…˜æÃFoƒgß∫±öÎç; _|˙|≥°GT_@Ïs7#>„>lfÅ¶√»J{Aﬁ∏ÓIS†±49U4nL á¯èèùiﬂdò∑2‚„”ÏCåÛVÆaÈ≠Ä¯‘z7#>…^o¨ÅqFéLyM⁄‚ì†È;“@®‹w¯K¶iÃ÷J”66jàÓƒY∆¥óåiÏ±‚Iì”#}j*
ÍM·Ú3ÓóL€H~t•}ñ«núÅΩŸ XöÂê≠à0!ÊB˙ãﬁKÌÛåR˙"H∑Ó∫	“Ü®T!œ¯∆(¥º25zóB∫¢˜.á"cfÔ◊~Ëpé§‰€9û#øòQÈXÃ˙'œ¯Ÿ∫JÍ<~§c	Î·»}¿1œ89jƒ±åÈxÄ≠©iBHﬂÔÌ0Ω∆ÒúÆrÌ«R„ÿÆéˆ•FÏ√s∫≥SﬂÖïΩﬂw|M®_x÷±ArœΩ 6ü<¯ùc9Î˘r÷Û{åÆ√⁄WÒïFú]µ¬—ÿDßZ°(gÏ˜KSú6	„¬RiƒYWd|knæSç—oÌJßS∆9Pü#Æ≤jq‰†›Nu∆ìS"é≠ºùºﬂÆŒ∏{a5§o‹ˇ6‡«Éf⁄Wã.%'ù™≈/G}ÓTaƒwMúÇ6zb{œ	oèJŒ	8?œ	R˙&˚Jc¿¯s%õçÁç#›oæ•Ã@ÑR.≤¯Y¸ã,˛y#∆?o¸rî≈,à.”6ò«…„K∑õ°uUÊs¬ÈQµfÏÛKÄXJëqÁ T°»XX≤“©âıaÎ√f∞wqû&õ&∑u'7èãpFMÁ&÷áz	k’q69Î%¨õIB_ìÑæ≈¨oMZ6≥vaO~‰Ï≈Ê[≥ÒÉ±ü9◊
oî~ÂÏ≈ˆ¿"6Ø¸D∂ÀÆzπÏñsñª¸,-Lyﬁ≈YÃN0ì•2¶W3‹ƒ–M*[p rXÉÆƒrt .Á`∑y€%úE∆¯ÔA∫G‘GÄ≠JŒb}0¶Å†˝Eˇ™KÉ§‘Û„Ö7\|a∂Ë\%|RUà‘3¶ãk$`¢k4K«>Èöƒ4©”f0Ãîpå≤§ìS/π¬eI8FYéQñÑcî)·eJ8Fæ“Å–[ÆyÃ+èÈÛòæR	◊EëÑ3∂H¬^-fñ≈Ã≤ò[‚>Ûö4|¨€9ˆºˆJÿ«p+ÀŸÄhYñn8ÓÀ›™Â®€‹aˆzò‹ ˛éÔ+nÕ∞^éª·ò∆òKå¶…ß›P4òû&Ïù‘ ˝]y€¿6Äk÷	pÊ<=æÉ{©t-y∏˚lÒ´®ÒÓµ“}32 7èô	8•Û\˜r©>6üîJáCwªÔÅ˛9ˆÿ∑µBı¸˜Z˘Å^'‹;äXÁébı®J˚é‚é–J˚y@Ô≥Ó)25¬≈/Gé‡œÓõ‰ËAƒ„g)zêÉ«RH{{‰Ë¢u¿’›œ„Ä|ƒ}†GÖÑ«†JÜÚ……ã<jœq©B≠∞y@˜iWÔﬂ≤yxç·4æüX”kÀ¡kz¸+y˙÷#ªu!Ω´ }¢ÙmèSæ≥≤‹XRúOjÖ0áqá4ì›:˜‹Àêã—NIóB?Ù8G˙Fçˆ<GZıOºP∞…˚síß@øÈ\ÊyNÁPPÓY«f]ùÑ;Uâ—u√!ós∫µ∞õQøÂ;O¨√OgÍ>s¨õ3U<∆.∂ƒæ’yÈÉ±[]dÿ»–ãûZ[ÊŸ˚√≠öX–k!§q]4Ixl™4‚q∂“àGä&âG§Ó}‡8+]]G:©S◊]Õ“À}ˆÄ&ßÙÂV&8Ü.Mxze´fiQj5hpóe˚ûûΩ…≈dJ?πqÃ¶œ¯øË<Ù∏´4K≥∆ƒd|hk™‡À–ƒV∫	éè ÕÓ˘ÁùyV8÷Kx–ÀôΩMbx5 Æàf	è5z[›,·ßYrè5_:é‘kLF≤º£W≥4ÅÈÒH‘,·±√ƒÍå1Ä»8´õ•ØVf{ôdúÛ’rmÔWΩ®€µ∆´Í˘âWûëNŒˆB˝^·r‚∏Åˆ~¥”í&/ƒ€Ìºœ	;B}Ω—>“]¢º›`^›Á›»˜ÛÏÑâﬁµ∫ëÉf ‚J¨’}9ÍyrN∑2eÖwGäœÇıïÒ}ÅÚ‰“Sﬁ!2ˆR§<‰âoº£∆À∏æ‚e\AÒ2ÆùpÍ∫¡¡ßùæµΩOíåcù
8–'çŸg‡Qﬁ50”'ãifÎˆXÁS+Ëˇ¥O¶å{HÉÑÛ9éØ‹Âì#+Áfﬂ/›6saç¸¨õŸÎUüp˝•π«}RË'vß}˝‡‚ -µ:∏yå¢9i˚Âß}ŒÈÒ9Æ?ÎfOæ‡ì«J,bXÃ∞Ña)√Z˘Ÿ|/ﬂ=¨Ü·tQI∏o≠<{kíoÉ~kØ—æL_+_	õÍ;M|zÒcæïL”†rÎXÑI4ÿr›˜<èP¥ﬁ‹∫VÌç´˚—e©¬E÷çΩÙOo®¥ø(„JÙ“/Èﬂ¡Ωë•÷≈‰ˆo˝≥Óó∞≠;≤6b[mùBoıT⁄ïÈ.£∞•œ=Ñë¶ËÄ˛wfsmÙQH_Í§ËﬂÖÙÁa∫ıò[z√ËOA„0Ë¥OØg›≤ü@≥qƒiüf¶AØ1mÙÙõ—péM´Ûf¥©È∑)¥Õ,Ò˝≈àJN˚T»∏g¶–ÛùPÛ·ƒﬂY˙ı<•ÙmRËöu®ÒU4ØÅÊ±ı®È≈~scHÒ≠w!,Õ“Ò,Nø_Í“6â•S¶1Ã`ò…0ãa√:`XÏcó◊/iWbƒïXÁ;⁄çìèèÆhá«î@Ô"àˇaª"∫p‘WÄ;Jø≥‰&†OÆ¡Øàñe ÄsF∑Ú+°8^%Ùvr<§Ò•{©à6Q√g⁄3õbÍøyø]1Ω	ñ≈ÙàôˆEt»í5êæ\Ú:XŒJx«Øú‚Y+¶ˇRäΩWNÒzı˝˝1ùËøöf'åÚ?ß[“a©?Ó√O˘c˝◊˘„Q¶“)?ÓÙà™Mpˇì˛x˙k´^t»ñ˛ÿFS¿9›¢µ›–7*†òùO≥#^◊dl¢xDÿ§_ªy~¿&˝Ô±À∂È{X√∞î·ÓÄ◊Ùã7xWz!j¥Ô6jz∏*†ÑÌ9µ¬¡≈8¸å8Ç«Ìoz"lçxäœ∫—Åàw”S∞¶–éÃ˛}fˇ;≥Ofˆul∂fòﬁÒòÑ#"Í(‚UƒÓæà€€!ˆ@Ñ8µ=‚πàxÈ¶–†vJz&§√YÈ£Xâ?∞≤>KA< “è±ro≤Ù◊Lø÷Àö<:U8@?çÌ˝GO‘ØÓ†ƒ|2∞∆nñ	VY(Í«üÜ›©∫?ÆÙLÏ‡^+dÖ`zxÔÔÌjs◊T°AZë∫6ú~X◊-Å˙√ãvN'ƒ£e	x5Ë¡;Fq∏Ô˙Ì¸ÁgÎfﬂ¯≠æ∞  ^Ô‘∞πZ√ÊjÃ’˜kÿ\≠csØé≤ÛyäÔ;8œÊgÃœ€`3g¥kPõ•ßòÂ)ò•ÉN¡,Ö+e6Kk`ñÕÂí`9+·IÜÎÉŒ≥˘YCqáø¯eP≠puÏe¿{˛DıM…?]d1/B?¸îdák6çaÜ›Æﬁﬂx7⁄±´fÜ&{v?Åa√hÜI”f2ÃcXÃ∞î·ÜïO1<œ∞—Àjf®7!∫1d…∞VŸÄcÒúø’
K†œﬂ•€{ß◊
œ.ôå„ÚHp¥	[7Mº:678ún)û&~îø>8ﬁ§Ïê;a\íLx∑!’Ñw–=0Ç·ÙL¸—‡4¶œ`˙1Ñ«ˇb≤6ö∞ge<+´&¡¨◊üœÏ–q©#g±¯◊ =∑c≥ØcÌ*b˙bπÑE.eö<à6À‘†ãÅRtñºŸ±Œ5◊ÿë¬Y¢¥¶„lq¸†˜ ﬂ(˝b‚9[ù=b8˝qÌµé)tSŒÿ1√O˚î≥kÖÚ±æ_⁄≥S9´ÌﬁÍƒ≠Öù¬È∆uÎÎ∑îu™`Ω¥Tﬂ3F )4	"dôz∆úÎîBM√N˚‘0ØSÎòe•	wûJ^#¿äé9ÌSi¬„˚yfS…fi
}‚Ñ”5c
Égã'†Œ∞r·Ë∂õ6¬±~ö∏&ˇlÁÈ8≥ΩhzΩÁèù/ö~_t6CÛf@«·ÜêF®âGH`Xéó°À$:x∞Kó
÷∆fÜÇ·õ8ò	ÚØÛ:w©ï;Ê˜ÍNcK∫Ë¨«Î)]L<ù∑æ¥ãõˆøØˆ ”ü”/ÅZa‰[]ºp°Íe¿Á–˚.L≠¥˜3‡ôÜ;ﬂF4g˝0"!<Ê‚·Ê÷ëlV0MºÉı¯;%4â•Sπ¶~À·–4ñŒ`xçVl’5úæPõÆë∑Çï‚Ä=ÈÄ£_ bπY¯&{Â≈]ÒÏ≈–%œac“å6&ﬂÇ›]õFBã^ÈZƒZT‰Äw"pn‘
{{Ω”Ø÷8"ñ{;(kÁXÓÖÆŒ0‚ﬂw≈UˇsW™«ß˜ó8ºRåàgÉ%ÏNDnV "ü'xø¢î≈/qòæuhµõ055Ï<¡˚	Â¨ŒÂÊÿ©a{XzèÉ[Ï‹0g∞)
´Ä8¬‹ÿUO•Œ∆J»}!ÃrÜ’@Ó˘0_ñ{ œóNAÓ’0?»˝%¨r›¬YÓyÊ{rÉ√;Bnd¯E»¬rôo#‰Ná‹i·Mêõ…rõY≠ö≤:≠oV∆ãÈ{Ÿ-Óª1<û•ì¶2Lcò¡0ìG0Ü?Æw\öÙ:Dò€È8§c∂~nrƒÛìFäÎ¢ë‚Zh§∏:öò¶âiöò¶ôiöô¶ôiÙv®—€°Foá”òò∆ƒ4ÅL»4ÅL¬4!L¬4nL„∆4nL„À4æL„À4ÂÏ~W4”G3}4”G2M$”D*—W∫BGá•}_Òû—&–Á@†#é∏/‰˛¬rCXnàcDõÃnëÃ&íŸÑÄÕ™n—Ã&öŸD3H˚Ωÿ-KáñY:¥åÀ.ÆÒÃ2ûY∆3ÀxfÔh¸™[âÌKÙhˆ∆»$füƒÏìò}≥ObˆIé?uéLeıIeıIØ˚#”òWÛJc^iÃ+çy•1Ø4«6ä"3òoÛMﬂCëôÃ7ì˘f2ﬂLÊõ…|3ôo&ÛÕtL+˘:2ãE»b2!BÎÓyék\˜€Â±æ-bÈ"«◊º+ ±?ãô¶òiä{¥ÅsN÷á%L_¬Ù%LiøíÓ%¨ﬂJYn)À-eπ•,∑‘ëƒæ*g6ÂÃ¶úŸî3õrfSÓx;Ë ˆœfπáYÓañ{òÂfπáYÓqÙÔ–≠«÷'ÃæÇŸW0˚
f_¡Ï+ò}≥ØpL/…ƒ~h4‚]†SãV:‚›¬T6+Ÿ¨@Müûæpû¸@Oìr‘ÔÇ÷8‚.dR"8‚9¥|ÆgÛ=Âà˙:GºQÁ¯¡ÿs=ÎqﬂÆsƒ†—ÒÀµ—QçéMŸ	Qy:‹ŸGz4óBßNIòUÆcw0XÑ"/äuÏzÅ!û	låV 4{6;,y!™ŸQIø5˜`T”Îù0éﬁii¨w'¨âﬁÈ≠πÔFU≤\À5ÅÊ≥(‰~U√ÙnLÔÊÑ{öËoEπÅçÆ◊)ñÎ˜^u,}û·EÜçõî˙(q‡öˆ'÷´NlUÇÔ®^ëN∏óFC:“X+ìûù≈9µáÎùßπKV˜Ú’c€£ùÊlõ∆qèdµät˙~„áëNxÙâáZÈ%∞{>nÏ≠nÏm?/Ö˛ﬁãJ∞?˜ˆíûﬁ0Ií6&MRù^ô8ª7ï.ÖÊÙNÉrüƒöd8af:±ò’$“G{ß±t√LEœ0è’$èyÂ1Ø<¶/b˙"÷€EL_ƒÙ≈L_Ãz∏òij•>ÎÆ˜.qbwù»nﬂß‹	œ|ŒëY[6Ÿü#mÈ€ßÇyU2¨qj ~≠O©ÁÃ)'Ï’SNx,Æq9Ë€>5PìÎÄSHt9Î∑=¨î
Üu¨çu¨Ωu–cŒ—5L_©gG4÷'ßKÜd^ŸË42M#”4:)È∑Ê∆F71}ìﬁçifi=˚ˆ§ŸÈph¢3õ9&¶—õÒúøVj[≤:∫Vzr=‚Ê1[£MfÏΩÔˆËÕx∑«Õ<´` úW'‰ˇÌk∆“Õ!G2lÅ„OoL˙ﬁ.ƒåıq3è];–ﬁ◊¸Ÿÿ_É∫ôRÇ˙∫ô]R∫ÆéÎ¯*`§œp‹Ã—ÛÔÎÕ”!=[◊o–‰æR¸È`πt–„ê/^∏#eEﬂxfŸ mK€‹∑Ä›iLcs,âïûj∆—I3≥3v3éN¶G'çÕ∆L3éQ≠êìeN{ nÓàÔ…3≥´~s€l‘õËd@|+H1◊∑ŒFÕœòãÔ…2«¯¢ﬂíe~°ÍÒ› YÊ®«7Édô'°ﬂíeû›ı¯Vê,ÛWPèÔ…2F=æ$À@PèÔ…2ªJ®«∑Ådô≥›PèÔ…2/ÛA=æ	$À¸q‘„{@¿Àı¯ê<3æ[•ÿåoJÈE˚ßqÏEÒ,ÆùÖÈ˘Ä%f›ÚÌ1%–∫¿òÂ'bJAs–=7†_)h:ı+Õd@˜‹Ä1À◊ıÀbg{Ãxû∞«Ãæ√2£¶¬Ï9ÎÔJ3Óïlå*Õ∏KÏñW,w¡Ô˚Ù±à±ïlŒT≤Òöm≤llléøO…±ã¥-vìÑw™7¡»Órÿ¶√Ù6›îÂá@?‹Ú‡$À;±€`7{?v\5„∂I¶|o∑ÏÕqªA”
ê}SÏÑ«–pˆùŒvó˚Ä§[ﬁ=ÓÄÑs¯ÄÙŸÿ˛qØIÁ◊'∫Á÷õ™•V£ﬂà≠ñr∂ ∫ÁNé´a≠;≈j{ ºÆ¶Õ¯ï:6jÃxá≥VÖ3ÛÛÃÊºØà/öÒ. E3~óq—ÃÓ¡ÍÍéªh∆Ô™.öÒ;¨•v/=Xá¯^\#[eMõÍù›sãkêﬁ+|$ÿ‰åe5öÒJﬂç•õX∫ô≠ﬂf∂NY⁄◊Wn£≤rùØ%ÓOiñ£˝ÒNÔô˛zÁ√°˜o‚´~Ûò/˙2˚&fÔflË1”ﬁÕ¯`8"æ/Ω“1≥˜)ÔJGˆçq`˜·‹åƒ7≠á8ˇ∫mÿ˜‘§¨$ÄŸ]≤rÒÕÎnƒX^¯ˆv7#æ«‹ÕàÔRw#/Æ€Â‡fƒ7æ7ª97R∫nîàÔV«K!ŒØ[V:πßŒhèw≈79õdºr# ïl∑apvÍåﬂôFC˝k„±-üƒ«≥t√TÜi3f1ÃcNœ≈Ü˚9„∑`EŒ¯ΩXë3~GV‰åﬂé9?„9bPëÛ&ﬂ1É*çx?‹Mˆ(û0®ÿyŸåYÉJú=¬RÖ"Á*ª∞¡Ô@KùÔ∫Ùπ+‡®·ú˙‡ûA•ŒW¿ôÄ3˛ ¢úïRŒ‚ó≥¥•5i∫œgp7ìTa˛Ë≠j
|~∆ã◊ÁÈ!Ë∫c¶nÊŸ∆0àıQÑR:‚˝:ãöJÊÚºZ|6(öˇ&ÚÕ—˛˛<˚:Äò∏ΩõﬁŒRÖ‰	£2∆·‹∂è±∏$s3◊€\áì9&‡*2Ì"QƒYX∆•öqZRºd3@bØ£fÂKGì0œ_hºxì]»S?ÒR0ö%^ã≥;ù√|ôì1^”b&á˜p2üÀÉ[bø@ñ≤ûÌ;~^yﬂáWsu*⁄¡’KmôÆ|£BgïÄVdÈé„Tæ{òÖ]Üß>∆±Ä5s‹j2»KÀ˘x$ÏZÉLÔe≤l	0"«d!:ìÙ0
íáyiÄÕ„Ô*gü q)úÖÈ&Û0?ùâò+öêxoŒ~çF·é–Fîç£LÍ°¨P|%£#EÃAQô∫Òÿ«•Á√Z‡ÎÿíÛÅ-µL
	ço;Bú3⁄ÉêÛŒ;ºAÇ|eX∫ò∑sËP®«e⁄ñ≈=AZÉ¬â¥t:bjh¡û;íSC9
hæ¬ß0≈…‡¯xq"S*¡Dº •ãá2Ç†évAÍúeâ…—ÚŒ2Á£ﬁî>…XpQ(‚q|
6Æx:•8æç.»ÿ∏FåÏöc7erå)R@/)vÿFñfa,⁄«3¯·,ƒ ˛∂π8Ip—K®Ÿ<.ëÍ¬ú¯\ë“»>-LmˆŸ9w5⁄w¶zé{ynvNé#ÕïÌjª9^Xbœ«»÷Õcàﬂú£˛¸≤yûÂ¸*:gb—˛>l1K+Ê©2Ùl&w
RÜÙ.5Cº¨›√‡D∫ƒÂRh∑U∫XrB∞¶Öq‹∆√3 Û∫µû–:∞|œÊPÑŒôBC∆>≥:êáÌ$^ªíD˝	mvó…xùÄ}«†ï≤u»ÿ5/?Q»Ô4‡È˝Ü |> ÁÛ‡¸éõﬂ_Ûûp—|
[CÜ/'Øî∏î4$.êg«¿—∫ûrQ‡Í–ú#∞ÌF—](ÈÓù√tÑi#Æß[ˆºÿœvTûÌ„≤MtS7»å Ÿ€ pRÅíö«xhø≥ÖÛ°“O≠|‚_÷¸3?œüZˇk“ŒB*ø≥≠í©‡á3?Ô®fç∏«“n°Aœ;"ö|6f/@üad ®∆„N!O“ä—2gwî\!&–ŒL-Â)µ[Pt≤9q˘òãÁ@O8¿≤é8+©‡î∂2¿ ¸LË…îMZ}ïq˜=èûˆ`*lÁTüΩ£3iÊÀnz}ƒÊ”ÛtF∆,´z=ì ÿ(Ÿ–s¥ÊT¢#K˛¸Ë8πÿQ<π√j◊EÚ ?|aÅ7+¢£Séº∫£ø=ÇdîäØ4Ëï?Mî≤ã·M√^ç xA£FŸÆ¢ΩCµ^BÔ^ñ—yÒc4á[!4ıÛ∂ü;Ã≈Õÿ•rª≈P~Io∆∫Üòwd5] Ω}ã€ªD\”.ˆ§…√ûøeE@†‡E0Gr«r˘Ü¢˜â!Ó›m+0‘≥∏ÁúGá	WÀ!Êl˙£Õ ΩÌB˚‰l-Û&⁄›@ñ”!ı}¢0<vπ€,[€¢∞g‚PpÎÜÜ|±…AÀ˛:≈KNZﬁF¶∏g*∞”%8·¬U¬≤xƒïÀ¸Ù|^é¡ÈÕqûyª†c_§©Œé	WI]$ÖògÍ©ïé	/õ@Fó1^Eé^Ôtµ.^c`û•M.;fÛ∏õëK„YBƒCáFéæB Dè∏“
 yµàb¥HÑ±‚	∏•ñ◊9C∂\ZƒD<ˆL&√≈¨õÁHé“Hà_áÚÀjdeO–È9P¡ûì·Çkx¯≤6Fô‹mj®†_ä∫unnzFﬁâ“–08jÚˆÜ!‚v¨Ú}ßcêc∏BQô–‰∫:yΩàù;é”©t¸7Åm¨ﬂŒ‘oLr~∫SÛ¬LLí|∆kóÚßÅ‡vÛ`ƒ›â{À∆™f\ÇÑ©…~^´rÂ–*©rA—«≠uj‡áDuÌåÛ”¿∏8éß9È"˘dÛﬂ^ÔÎœﬁ˝q/©`Ø–ˆªÜ˘úõÜñ<ê«Ä†“ÊèÜò≥"’®Gk89]≈·6ñΩ@'}ÓΩ•ππ£‡3ùı-Ë„2é·>œ¯ÿgï¯≤Ñ≤¬… ÔN·1z¡áÍ¿0ë◊Q^!°hæ¥àO©◊Ç“ˆH~…9LÃÜZè1˝∂ê÷ûºdƒÛt?«vé$K‰m‡;4mîE0Õ∏]PƒO‘z›)#¿+5O>I*ÈpÁ[bÏ2$úJbıÒ¬ub'BÀ÷I·?º„†]ˇ @˛⁄ïˇEéÚoê´Ÿ2ód~#òé2Sk}∑í^;-CÚæs∫ÏdkYä¬9Sô÷ÚÖΩk<Qö«Èò¨OóëÛÎìÒ§ﬁZ-‡Oe9øn N´”åó;∂4ﬂOßÕ
Ó|f©óÇ˜®£Jd©◊ÖyïC/.Ëm5ÁuÔ2Çœ4ÇGò,‡à∑Î=‡ÕL“QÓ7ˆ˙dÖP˘$ÿ%âïπâÍV∞35∂Dó	Ä&F¢%7 º	¡≥>öë™ô‰<XÔíxÊd≠xNÁ¸vo¸;c÷¡ØÅÊaò<ÕﬂÖ
Ln¢QF\H^3rë2¬AÎ‚pàØ˘„∆Gœ◊˚©ß9<ÙÀÒ<n“À∞Ò7±/oCïçOPéˆbY†ÿ—4øîÎñ‚˝—µ‚ú¡›B∆ì†‹–Z§ºF˙Ú?KÌe≠ë‚ú	XíŒQƒ˙	X∫ŒQƒ˙	®÷KDÁæÊΩ≥ÚlSY*ú“ßü|ÔÖ∫=Œ;.AÔ∏Yõ\Wæ>aËTÅ≥øPâ˜eå(«72ö‚ˇÖ=8Õ≥¥.—qnƒR9Ñ—ì<Èºmz>[‰ÈÅ?ÒƒœóûÂÙÓIc(êXz#A\è d¢◊ád=·C≤í!Ω˙¿ü√y§µ¥èËsA‰ı©∆h[#Û:Tcú≠ëy™;¬|Të{E’ü0SÚ3´º„>ßHí„˚Yè›”∆◊Zˆ”g€)_ÆèÑ˝YÚ8 ÿ√6LòÉ“ckΩÉÓk¯·Ú”:¥m]ƒØ¢i¸0ùí^∑∆¸ÅáÜ@*≠¨·Ï⁄gO kÛd2Ê*hq3hÚ‚“ æû ﬂËYÎ„
º_æ6Ÿ9ÕZNˆïWZEæÕIù/ÅGÌïuº}Œ∑ú◊=æô∂O⁄kLÕ„Ä‡Vdı.U∞E¬ú6Mjë7ËÄÎy=}¿ÌcKÇÚÛ∑_`Ê∆œ˜W–∑/WËV{øêE⁄ÙÊ≥ÅCÁ˝<€Sﬁî†dÊI]ùéGŒï˙ı‘¥‹¬^s–©övΩïÓ*±vÛ-Ë_±™ÚΩ;˜*ˇ]%z>ØrÓBç¬|âçﬂ+ˆ∏≥’‡aMKºêÈbù/(˙ä$Ë≤dz,ôb˛qî¶â°◊>¬B⁄$êêYk˜»õ»˙€§‚[»+X¸Vö∑e¡~1^%.#-ùkKë‚ÀÕWv&›$˙œ§õ¥…<∂+‡t≤P¿o≥*‹õÓAM5ëÜL|⁄≤TÚ®0œ{*I‘\@‘≤4ÖíëI9H&πêÀKà¬˝%˝âıN:2n€È¢ˇÛaÑpæjÌÏ’`:-ßlY)“óMä≤*ãÅi^j-o}∫8^πÙ£</KÅ©Bæòü/µ•`‹”2Æva∏Xc{’†»j•@7Í€w∫W¡üÄJ…/ØEˆB∫{πîD._Á(Ú˛ÉØˇ%;5ªò)NdéË,ÇÔ£E˘`DQ^pÅ‹ì“qfµı;R¬wQ2∂…U˜c—“´^Ñ±Œò)ù 2…1ñÙ2x—y1[√82˘ÂÏ"æŸÕ>Ï.Ô˘%Ç»xúﬂ:.*˜wgËµ(éÉ/"æ√Ù÷#GÒ˚zôÚ—±⁄˙eÀ¢3N»e)ÚŒÅ≥`⁄ÿu¡Ú´äÓ¢ΩÅ„„[•dF,WÑ«Ù$Æ_ˆ·d˙Éå·"áËúfc)y\Œómåu…3lú8·7\Õ˙–<€≠)˚<øŒ©Oõ˘Hú˚RQN…;˛ô¡‚¢{¢ñÂ‘¯é"ΩˇÖyQò»9úß˚Ç¸tQQ&”E\ÿ+:/:°¿´›{ªÁÊJ+WV¥À0¶ˇT1c*ö∫$ì:∆±#•†®8<Í÷∑ÂæeZm—Ÿ—‹€NÙ¿" ≤Í¥n„ßFg≈SöÖ©å9ªê>öÃkÁµ"ùÁDæúú√üÃ¿o◊näJTÃööƒQê‘+ÕÖ´9îœûöœ‡©á|DÀH Íƒık(LxæÂ2º˜g\BŸÏ¡,Ãuf¨xƒû„Ã‘¨Õ›nwœsπ¸ü‹≤Ö0?d}¸©›}ë≈ª‰¯.µÊr˘í‡ÀEA·lò∂nr«Ò93CztNa∏≤•n#ïy`≤lü60ïwˆÓ$Å®£∂3gB-f†5#LÙzªobËÕØÈ…{T⁄BGÿ'5êóO>˝+dË¶»$+ÆW@XoSƒ›‹/G6äÚ9ÅG†£ﬁiWãÏã¨@N ß!±óÛ(æ„)kÓ∞◊‹b)“ÁuÀ±hä=Õ^‘≤5Â–˝éÑ*Æ5 c~Î[U-˙Yçœ"πC⁄PVõ™Ã§´]D¡âπ‚‚ë–Ç◊?48U‘üH¡Éq‚Ωs|8Y,•(Ê€-Á3ZŒöÅ˛Êó{Bé˚˘Hé®)cÒ@ö8å/. ˜úpèù5!Ÿì¸–JÍò]*!ÆTÅÇ(:´≤˙®iQŸÏûäg"ßƒä∆Eá)åsã&! y~ò£◊”ú<ÙC÷.òtbt^œ8Ò’˝√à~õèÎh+ÁÚ_œ˝UÁ}¸˘ú^íë”¶˜˝Ã/C“Mä‡oÒ%KŒN:ã±
8IxÜ˚[b4≥°_û“oJ¯>◊)BYÜÊ‘É¯B#ÇTŒaP`t‰íTø)q\Óï®gåæŒ1zI‚yAŸhc§.˛4µ†°#VêÖuGØ¯Ü‰qÜ∞¸7áÀ~aÿ,
¡uñ'`®∂”π>ÉB
}‘%¸ËÜ¿ﬁ˝
µòYX‘)Ÿ„%óTPÙäùƒ˘u:p¿ø6aœÔV\ÃÃ;MÙüæû¿/ú∞ÒÆË+ ‚]ù0\›mj⁄ë€C”IÏI5·Z%*˛
Ù‹Ü≤%”Ï©"ΩX•°Ö|)Ø„ºÛ1]–>y?›≈åe
≈írœjà”˙Ú·0Ë4¢©W•1Óµ¿ˇcˆW+…ÃÈƒ¯3≤‹1ÖS7∞Ò†¿dŸ£√GØì…È@ë4~ïÏÊ«çBå»˚5h<ØABM∫i1≠çÄ¬∑¯‘¨|<C9KÀ ˜”›z(ìúhÕæ9:'Øú9ÁÒàóÅ√ÉΩ‹hÓx¶êœQ\k}GÈ£Aç8˜b¶Ò{øﬁ∞º4ı?¯CÁSÉQ¯Ø∂æ¸+Ywe˘◊.Àª¶ºNq¶∫˛’j˝ı:ﬂx±ÓP Œ∑ñ_[~Öä÷ÑˇñÚº¬pé"MÅ0ìÓﬁ€97óZ;ü˚[«Ùu=ûI·æ
òjÂé$¸t∆˛åhµ·¸
Î2Ï% ›Ï¬Gùòs˛‹Là”;ÜÂL=ø=„$1≥“˛7#Rt/‰Û%˘ˆ∏QÚ’åÅõÏ“Ôb–\Tfâ~ö?6ë;äﬂ◊¿	zS¯ù[ï≈[ÆY–ı%ΩªÖ·q
◊ë"Á±·◊-¿æ´y∫ìã£ÊÿªqæeHM£HA^NT˙ßk|_‚”ü‚Ã•eÌ+áÓ*áoz+8Z˘·5	<GÛ W‘qrì'O8øÜ;ﬂßò»üP∆7vf≤ o‚fr¿z$SqfÜ˝≈¸„∑h¶À'LqC∂|ﬂ—˝_π˜ø¥À»e˜ùJÉ¿Q⁄‡≈/êêøÆ?RJûå …"ˆºÛN «f‘:°ìhÓ‹ÜÚ'	è¢n:•?˛"ﬁ¢ÁÛT29©≈G9b–Q{ÚnÁP~ü≈âª_≥a∏ò*‡∆ ˙:á2W°8}]Ñ%JQr\,·πàC◊Ôê0Ç/âªÉë_yÁm√|˙Mﬂ(ÇøMÆ?€ÍæÇk|ß
°¢ößs∏÷<Xﬁ∫Eã¸Úº¢tÓ‹k˝J≥;›:ÔúwãåœEüg’£…‘¢VÈn∆lûC˝πåÁç∏^∆x‡˜¥úÁ 
Ob9˙´0ÛY}úî‘ÃF≥≈Û.«À–ÛØﬁ‰¶‰ Ÿ'0XJûƒ‡\˚ ô=ˇÎSë^™Å^F˚◊ìáßñK˘¸¸ )Ô7ôµí°Õ?–Ø~8‹ îPº¿Ozèd
†≠úRX_„ªã<’È©π¡‹)˜≤Â£˘§ØgÛÑë	'F}VÖ∑çhL¢†ì8¬{¥…Üåcj÷àó;[˛%ä äYXﬁ §u‹^„U„-œœ≥ˆ=ûÃdÂºª∆9ªsnº(/ÚnP>ùÊN…˘'âÛã.º⁄√ß,N)ÛÏF	`õÓ‡{§VÀ∞√…Â$ÙÀ)ï“ë¸ÚúﬁO¢Eäú~@πªº·[&sÚ}ä&¿õ˛xñıù‘F¥´ów«Á‰Ô√Oí52äóÌ:k≤ o∏îì°)wázªRÍö;‘™UM®§:™lïÖ¯∏ÓPÍ.u%ƒU	˛|≠p›•‘∆%»±§Ú@;aÚ´Ê$¿(œ¿]8)sjJZTW;Â´∆e†UàÂî∫Îê”™“⁄Äk(¯V(›VÀt/RπàK¬uÓY»óÜ∏ø‰VÒé-»Piò˜6œ∞Ñ‹€ïZ(Ø}	R©];Ú©.|N¨Õ&Ó`πI ëÇj∑Ãﬂ®gzò“Íì–‚„ÑIQŸX√<Ò’&jä⁄ô8C\ƒVπúáÚ±¸€∑üRîî∫qTùÑ€PtûeR/n‡4ïÕú¿<.Ô⁄Èiº)ç>+ö}Ÿ
Ùy‚Fym'†ƒ¢ìK%.,
«∫)7∆˙)µ-œãea›)*€£n9%˙Ò»Ö"¥cô8tå8ØüãÎlU;DbwRπ9J±B‚⁄®ÙùcPBûûK-Añ‰7sÂv*U’k[ayy’(ı4?EJw˚>Mœ¥(Âbº 2¿=»|™'M2üÑIß5nÍïûÑgá˙wµ<-„¢¨ı7ükπé¥”⁄y ∑¥vKZLx“Ü¯	 üVÍ»∏G¬Z’$µ±òàí¶:Ù»v%IKaªøZ©‘˘?Oâ4Jgñ8Îé#Ø1®5≠¶π™Á©’»OUâ•`œ´•p›◊ïp›◊pAã¬0>¬yèó™;cËRlkÛ™WôÉ“≤®'SÁë©≤ëÿ*:bâûËjG;´»À†|ºøåÓGÈ>O˜›t-±ŸØç]kˆß™≈QSÇñ„]5rˇ`∫„$gjP∑€‘–ÑsGö÷¿˛‹ÿr‰-sFm¡T\”a=õ˜AXRc∆ss˘ÍbøÑÕP˚πüÅ◊[¸tî—cÙ‹Í2/Õ•Ã–,±¥m˜ópÄ⁄ñÛ’•.6ı˝qÍ”yàù‘öπñ!l˝2í!◊fj:Û_≈r$√jÛ“Ä«EwÆêD¶AØ©Í£¬◊~»´„	’k@]™“±éÊt:ŒÈ4DÈ†EYxÇ‰ò^–€™vEûÜJ´w!*œÄ)øSÓj#o≠'g≠'_≠'óp mπ”YÜ)œ56˚ÀÅz´ã‚„Ù;íØ[§!ÊÑ€OB˜`∏’‹≥:øÜàvqé∆Er-ŸhƒQæeçâæU'¶H#-í-]TªdÙ»J
x≥dñ®%)—§IJ_ /‚∏ÿ
ÙÙ≤Rw^|{Æn±N?5Î8J~%ÈW∫y≠‚ Â°Ç[≈P∑BŒ±`—qíJb‰1/
q—0+».d∫]KbÃñ≈’Hí≤Ãì´êv\Ì^®õG_“pÂ¥∫X¢MìôUWc±(!≥‘”.mNR‘Ø≤Û∂
Õ~Ø!õ§n6›'uMûsÅå`Q⁄4Li±’@À”Pü4‹Ω1Ë™o÷pe)eñûÈ®∏çÿ∂,=WQHâlë˙fEP9ïÀZÌøhVû=-|<Ó…·≈\+9iÉyQL¬õ<&Œ‰§om¬Á)/KLAd)„∫cß√y«uT†f›∞eiuêÉ√+©*d@âÃÜ7Ìåò[Ñ~(GI,RÍ §8eh˙=‡)æ‰_[‰;!wÚŒÉpÌRP∆4û—ì¥éÃ@ﬁ¢àRª„ëåPß∑;^˚¿Ãä–ç	nòòùï!"3ü[º•N“`bˇhIÒ\¢]ç´Î©{óà±IÆic∏ç—≥€
ªQ˚p»Vu˙øtœN“h>dåfv™É&Zòyû§ñ% Îr∏
dD∆Œ,ç\€1ı”$ë3NKÜ#7Kïìq<øNj=M`£◊
éô´@˝5óª Qß‹ëí!'∞dL∂Ù4E?3¶`„Ìu…ı¥`⁄∑Lµîî9ùÃSªÜ∆Åö7OR,Ò√2Ò‡v™»2ﬁÓÑDÕò.3OàÙRè`”˘NJX∫˙”31\µt∑ØP±6ÕYO9˛Ô∏
≤)◊ãJ¿¯nê™Sﬂ±ﬂe™°b≥vñÏA‹π∂ı©|Vºß|Õl•Qô'qºRΩE€™Ãé-äà%ï™EPmú/â"x~/pWœJ⁄Ñ™àÃ„5e¯£Õ3 ?S’.’ÖA∆
Ááe‘™ïˇ-à:|ÙßSçe>w˝)Å§î´bÉP¥Ô¬YÍ=ñåÎúY±™gå^kPul?…AöÙûäqTµë3sÑÜ^^VQ¥3ë#â’f-„ÃﬁÁ©\ıÄ~MQfzÏz§…≤¢Ωıíö◊Ëq°Î<Fmr›ôyúi˛ÍV· ƒ˜óU$nœ:fÛúenƒyÑôáÊE€µ·≈æ‚:)˜rêñ…N¿<bÛ1ßG}îIˇº≈‰≤ªŒ†’`özœ\}Ò¥rÂ√úŸô+d)°≠¥öB•π√∑Æ•’˘Zs∫›PÔ^–/Ì2cêŸÁÖn|ö4WëÚõxèãµŸúªzrx(û<óL≠[\˝’N´`7—
ñ´ªt∫=IÅûôyx•#£__dïπñ¶e‰(Ÿp‰‡Çò92&·pÅ—àÒZ¨⁄9%zq∆cîXÁzûßñy,cn‡†»πÓslèˆN)vŒπáy‰8≤^ŸN„≈çºÁupq∂î'ÕÉ„R]·óº}‰Ë•Iπ˝LœvŸnËÎy5ˇIﬂÁ†∆%q]≤Sôi ãÆKˆ‚uÚÇûn˜µŸÎsÕI?Ω»Kqµîëfeàû'k¨ì!ˇr§2‰¬î€S£πˆ¨Hfﬁ’œÆ√Ì≠ŒJ◊8$6ö{lXÌ	Â⁄pUÌÆV™˙<…#˜¶t˝CHyÖñﬁ4ç˝¨Ã]G›ò \q•XY”%—≤ê¢˙èJ^u$»≠Ã–H *◊≥EO$ÿ˙ÈAüDmú‡Øjt≠Ïa¿ü ®€Ó_e”ﬁ˛ïJØgÆàÂ–--ñç,u!Úq⁄ÀœÄΩÖµ©mπÕ’†rﬁ`dtVÙJ⁄†gÂË7òìk’8£|”µf¥»<)û°VÅñØvqÍE”êw»–µæ»eòfR0◊÷FÇzœÔóó}≥Á|r◊äS¿7hC‚Ï6ß»4=K$∞«e•∑≠2"®Æõ0›í∆LÂïÁ07B@˘5zÎÃë£Ù`ãTjŒQ∞≠‚Ëx]õ?-|ﬁZ`»ÃËg˜?≠vO‹°Ë>?;GEqE  gwjªÃ⁄Ù√À›î®w ‰i˛dñeù~mpQ<S§“k÷*kRIô3‡£]àù5G´[æØAóÂóŸŒIÏ¶3Ö∑t†û^˝üx†å” W¸ΩÆüÒ7ß≈®d»Ö*)˚◊™øUL=ﬁ≈A)¶\˙¡_ÁÈ}œ—∏€XÔŸÊXUÍÈß:˝¡÷P˚<9•˜Æ‹π∆⁄ùs¸)ø%1ã2Ù≤Ù‡Ïì.˚=è≤u}◊¬∑˚ÖÍ⁄«WfÎ1E∂ügiÂﬁÅ;ÉÒÓª√^%¸5ØUé”Ü≤˚»ä¨–jìﬁ©syu\‚_÷´SzeXù˛Ù…ùví4≠+7ªC‘Q6HJëòîÀØ‚ãwg<p·k7h∆Î¿‹Ô54¥6•”íw˝|VsÄ¡é	Í‹õ°ÀnÒ1JÌNê≤Ã©’)“ﬁ¢Ùr7Ç¶)7w3¿ªrÓ_¢Ÿ£%ú»ƒ≠Y†I›ÌÎîÌ:?†ïp’¸j;ççDwrΩ†Ù°ÌÑ™b–Å◊≠Wzf'¿ñÎS∆∞ÂmL á û√ªÿY÷ÎkÛƒ‹@u€xµ±]rñ1N–x≠Õt¿—Y9;l®PY<≥u˜„SÙI—ÓL’[Xb$ØjÈY•Ô8∑ˆ¯≈“ø0jŒ|À¥ƒÄ?7;+Æ>Bo<C"·Àyï?ß÷/Y1~æÙçK4G@\ñ\-µÀ;”‚.?.≠Á’t|Í	N}Ã\¸’Û…rAX{ñ≈ÇÀ⁄∞$÷&£óQzùü®Ωl_ÿúøÍMHuõw9⁄ÏÎˇ°vï© ØÑyZcï¢^îrfΩ<€–j‘ÿo)˜‰°mß(ü⁄YNù°>À–
NN®êrW∞_ˇ¬Rõ›hEµ^ïÜÏÈßÇßåÊ2ˆUé-—Ïg] ⁄ÈÛ“N<ÉÎ*g
ÍÈ)b≠˜Ai…8?´ èœËé÷∫–{¯ãÄª…ºËyvÃ}?”ÀT◊œúw=<Á∞Àú)˜`ñ^0Är3/¸9Zïﬁ
AO∞ÖRÉñ‡Ò¯
“¸K÷@ôYk)ø<m;Zs—fî\¥•Ú√'◊ˇÍeö¬\Vn˛W/WÔÎ%Ô¨î¥n}ÕzDπC…¡Ò<ñ+lZ–¿Â|ÙÙ4çù`U9-Œ‡Bƒ≈ö‚.uÏ7˙[m—t^ûˆ–.qGÓπç≈©˘»ØŒ=w!ºåGª÷Zîæ^Ò∆Îd\œ”ëùa«Eø¨÷≥Ù⁄‚∂8‡âØ‡zFUŒÒOº¸6˙(e◊+îﬁü|Ö¯yzﬂ±$F%EJæHœÉ„K≠æ›RZù-xîìÎ ≠ø§OK\Ó¸Ö]⁄#é∑ƒπªËı¯Ï%blyXÔ÷ßﬂ]v7{µ⁄‚µ*ﬁç¡]Í’`"Æ¢uv,’Iªúûπä¯≥B-O,hª`Œ–,∂ Â]E¸*RÆ"@	¯ﬂE˚⁄≈Ê˝>âÉ"i›¶óuÙ˙´)Ä˜Œµ(‰_
‚Ω(^IÙM.òöjDÌZ	tÜÕ∫›’Ò~≈gîÙd-„L∏◊Õ3KA-ÃJ+y» ŒEx∑—ÀO[∞A>N¸≥â√„p◊ìó…eñ‘≠⁄¬ø_ﬁ{ÒÉè~Ù√è˝ˆª«>VlØS·VeU¥ZV<∑∆ç≠ã¥Ü¨∫:B“˝Htc”ä’¨¢ú~{lc”È' §t!D6ù~éÇ’—™çM´kc„]V§¶’‡.Hÿx˙KU%|ºUml<˝s+T—™†L ¨Z!®‚PH„Í=—∫÷
Ãzüµuk¥qı!lT4“™WoÅ™Wü∞G†Í–÷≠ÿêœZTÑ[cÄlÊ"Ô˛öUÕA5‘∆)h\˝√u1Üó4˛ÀqÆ·Ù[¢Ø~´ÈÙ«π∆fUaG®%≤±q5bE†5Mgzj66ùÄá:≥'Táåg∆≠¶{ñÜÿ)¿÷8%†ûÒÕ™ÜB7'4øÒÃ
6˘ÄﬁÅLEÓ∑‘Iag"RGsõ∆‹VCY°¿ß ˇ÷çMg˜W4ceü∞»%Ä>¡ãÅ¯Õ	X|ÊK!ä4û˘rH0_†àQ¬_r	ﬂ‚ûÒó]]¬s∫ÑøÒó.·ﬂ∏Ñb ƒâ0Ç´œ2ˆy¡∂ÊÁût¸ Mg-∂@¯lÖ˜	öŒF8‚Ê¯KŒQTﬂŸZ}gYêÄã—jaÊÈwYQÓìñ(ì‚).§8ì™Rïê™ò3H1!≈òTiê*ÖT…§jÉT-§j&ERÑQ™BRW0©∆ ’©ÜIµ©VHµL
§êêBL
§∞ê$l\™qi<¨ÄË`õŒn6◊i`3ıYÉ[¬6áö4‚í
F4á7h‘eçjÆ∏@#wF]dsdìFÔäôËÊËEöêà{	Õ1›Í≥=n˚œ<a∂ØÒÏÄ∑}çg˜¯€◊xv∞º}çgGÉ⁄◊xv<∏}çg'À⁄'ålVÎ1§‡≠V§J‚wπhTT5nr“::Ω[–]r8@”§àJ¬ﬁ%≈#Ö”¨ödx”DB3 'h∏U	ÒCƒ<»pˆZ.U6S9úΩëî√Ÿ[,2àI&⁄ñmb2D8ΩÍ…µ ÎÏíÂ@ﬁë~[f•s≠W˚‹e9È ±◊ñÈÆC»œ‹G|ÿN	"ªBî÷ÅﬂJëJ%¨&”ÍÿﬁË,MgW%r&°1wÈ»=u“<‚i<ÉMgﬂ‰o¸jô*>{ƒ´BE±æïRˇv/¯é≤RﬁÂäSEùkˇå”‡«¿4áº	õ√µéÚá·Bﬁ\FèQ⁄%FÈÏ!EÙ;2à7òVÑ…\ﬁõú6¯»N]MN1y_Yıgü“’?Ú`À\˝∑uÍ{Sy}!+‚≠∫ü?]KëÕ*ˇEˆ 
√•Í5Xˇ·Áß÷–’ßﬂbhn›S-b]Í¨ì¨´ó»Ÿ/iÃóu‰K∫Q_÷ëgÖ∫«‹’Õ:¡_Í“æ•#£µ–ÍgŸ!äSŒ0(R∏¿¿ZÖ
}äJ•$&º'–£—%É¯bu!O*\◊tˆﬂÍZ–a¥™œ>è~‰}∫ä¡S£#V˛ó`jHœ@£Eg0jB°h®≤
”›ÉMçJÑQ˜i‘}î0^ßDÂrÒòÄ‰ﬂE5S m≠ä®P]›Vr/∞öòêbCíx3y ‰ç«uÿKä∏Ñ‰wR¨°U7ZÇ*Ø$ø¸Iﬂx5CeLìcb6à%FT çÖºÂ÷Çú$Å£°Cpê„Ò(Ÿ30å	€®AßﬂáÓc<Éº*TUUU—`©xEïÖ¬lÖÍB€T˙≥f
»-Ë”8ÈMß?Q
ÔXxHï-ë8RYUVÜ∂YëX∏#°™XºR˛Ö∂Ö´cïï.XQ´2·Hm¨∫“DDÎb5ïLåÁ$–™Xb†¿H§"≠åWW!~¸5≠ò{‹£8∑9˝4RZç›—X8oÅiO®
§7Cß@U1ñHD¶W!ŒY´™b!_g‡·4çC√#5µ—xU$VY]ãEjk ]UÉ[Uue„R}∑Z∫W5≈¬qÍ/*ênU.lVØäÖ´0Ì3ËáR¿¬ÉÛÑjLH±xº2íd¯à#ÒX4åâ∆bç#n5ç˚qL÷5ù~€ânç’ƒ[¬MßøÚ¬ÖEÍ#£ë˙hCòó±∆	§jUﬂ}17Øáøp<kÉwèc¡ g°8≤ÍA¯!⁄¶P^ÿ≈mºá∆$p˚Aj
¥!Í:øÔÅ¥¨∑©(±íÅt˙ﬁeä+úÆ¡éÑ±Æÿ“·j6«"Xt„Èü»3≤ø≈3ß~"£„'öuo$¬·◊x˜Bù Œç´…ò@0-NVDõNˇo˜x˙K±jÈ…É<y$®±ª±˚ÇX‘y¬nj«6†>]’
ä±°±J©âÖ1!◊Ã}˜VÍªM±ÿ6•3«I3`Û∑—Xe=Áñ~ê∏‘∏z-Ñ®L1F™É(–Wå‡&"™R÷@ø∆¬M´‚¥‚»5pº©¡
ëZ⁄¶≈Ñ´Xÿ¿nPZâÍÇ^Æ™jº;QrgáX˚π8$b,G-“"AT"<Xç“œ¬ÇïÛ ›∆qõ™o∞¬mÅ∂ƒπœp0€Kb@Õ#ç˚uÌ\Æ
Åêiœ0£d°Æµˇâµ“¿¯ŒÛ-FÊ]∫&Nv£‘Lvå
Ö@4·oI 
e7›®÷Jd{-≤™ë‰î%Ä≈?›∏—…v˙Aëÿ©m ≈∫M	o$/$HsÊÙE†9_÷x£+yps¸*êáEÓ‹∆ë™ÍöZ‰Cºq±q	<¯Cµ¬ÈY›Å&ø˚<ZÌ®≥˛Ç6r:Ωéà¥µ9JæE`—≈®ã(RÅ>â«QeXx„¢ÀÍ≤’t˜{q+éS‰”ﬂ%F1fÎ&p^WwUPglÖ—#¨å≠ûóÅG≥∫≥B-ë™÷p≥¯ïıîÜ¶¡y[MD¯ÙÛ5≠ÕŒÃ±ûJ:ì∑n¬4<∂6RkJ◊(®ªè¡£Ò°Å∂5&`L`wàiƒaO´ül®Âª?√	„ë**Qsíù∏àQ™/˘ãˇ„z ·ä1—˛l≥µïó9œ_`…†KY+†ÉI	ˇÇ\ìUúë9f%éì)n3å@÷D$l§ ,KÜ†`@◊M≥;Jµ÷àW«*x¿‡ØãÒíQ«ÓÍv	Hu>çZ˝nGÇœ5°cÖ¸öh∫{k”Í@”Íûzí"[ŸJ£≠}(¬Å `BJà‘UCÏÏwõŒ>îF‘kMgíP Z EMïQP=—\8Œ√C∫8‡o322äµ‘™06	jA}£0¯:Ò0™ˇo®èU¬`≈Î¬µU’‡æÛ	◊®äP]„›K0xjM† ™Î }Tõ√-arØ¬ËŒ’≈¡ß†ÅL.#π@ÏáoS§G>%hk31…,~C>Øˆ Ã´±d)0~_ïÖ<ÚSç´O√≥‡∆°Pó™A’A à“‘◊≠A∂Î¥Yé^E„›w°,û~ê•ÎMZe∫!6•ÇÔë¡!˘~a,
ŒS9˝π≥œW¿}©÷ïUPó‚qV≠Æ=A],∑e¥é‹ú8Ãﬁ¿/Ø@G›!6Ñô Wúç∏#»apr9Xø∑†À‘©TV=¸Ø™äí≥RGºx#Û‚ò5Ñ8∂MUQäTqU ŒÏY≈uÜícLéid%"+Y	‚Æg@Ò*ô0µr ›.pœ≠≠°ZÑæ!¶ùG11Úûi6≈Ùz
E´bí7–f-Õc–+ÆB}’®ò&≤ÛBﬁiµpÁPú=äª∏ˆgh‚Åœ˜PÉCõcéO·∫ T∞vuyZ‰<ƒ3Úo‚ µ}ﬂ”©„fQF›]⁄N∆∑aõínä 1ıäóSåÙt‹MáÚc)
så(ËÜhÄ8D‚ËLU∂
Ä™*öZÅ«ô˝t†©Òi–˙ÇDµVê⁄¶`{¢d¶d∆FÍ‹¸ñ˘ﬁêEÌû8˘∞œ°ﬁøá1Ø ú‰ZbG™ˇç‹Ò7@3‹SCcH|ÔJ1hÌ¿HkoÙbîP0WÉ÷'≠<wægÉ®§ª∑j`+Ä-M‚”–Z‘6¥O@ÅIB”DÊú@®¶ïÚ∂V”¬«kË©emkÿäU∆Ωu(NkaÊú±•dmb1ˆÕ` 6≠˛<ﬁt!O&–r¥bı9¯0ÒÜxLU‡‰¢Æ°µ¢ÈÃf–gÔ“d‹é≤`@‹˝>2∫wø˘ò§≠ˆ`ç;Ñ#WJÿ-aøÑ/eÔ˝Ãòù◊*ã∑ñ»¶T≤—Ym ≥Â∞à∞€TYµ:ÄvÓÃm§Y∞ ◊•ZiU≠Jˆ¨*•‘3ïT¿ô z‚/L¢§1Ç)ºg™âmÄ'ii:SKö>NwÊ"„x1#õŒ4“ﬂFdËôÕÓ}µá27øÈÃU\´Rø®!Ñû¿”ñˇ∑Y—*J¡V&ÓT^ﬂÜz†+Ô˛vE¬çuÿßwº¥º”4¨Hzû]«":v˙πûXU”=≥çgZ‡ØÈÃ%ë\Á"D≠çªQ46gZ§àë úiâ„Ç%»˝pn~J|<ÀˇîıUﬁ§‰îhÄãra∏Czå#˙LK∑§ %„~Øµ7V€tœ¸Ñ¯®´ØzT/d<måKÆs¯w	J«+DÇ”4»WÂ ›ëu*=˛çD_“âæÑî,P6±_6`J ò`Y¬íÑ'%ºS¬”ﬁ+·É^ãÛí›b£±˙ —Ü ⁄XƒE«Øä]T©èè6@⁄‡ˇÒ J°°ìuÈ=.ä’¶Æå«±-Á(ä+w
´:Øfñ™÷Xß ÑÌ˝ ⁄ˆÌçw∂Aª[ƒ¯3'ÿ¥?’$SvÓ…¢6Óó˘WÿúxÌ÷”∫ot+(err) {
											return finalCallback(
												makeWebpackError(err, "Compilation.hooks.afterSeal")
											);
										}
										this.fileSystemInfo.logStatistics();
										finalCallback();
									});
								});
							};

							this.logger.time("create chunk assets");
							if (this.hooks.shouldGenerateChunkAssets.call() !== false) {
								this.hooks.beforeChunkAssets.call();
								this.createChunkAssets(err => {
									this.logger.timeEnd("create chunk assets");
									if (err) {
										return finalCallback(err);
									}
									cont();
								});
							} else {
								this.logger.timeEnd("create chunk assets");
								cont();
							}
						});
					});
				}
			);
		});
	}

	/**
	 * @param {Module} module module to report from
	 * @param {DependenciesBlock[]} blocks blocks to report from
	 * @returns {boolean} true, when it has warnings or errors
	 */
	reportDependencyErrorsAndWarnings(module, blocks) {
		let hasProblems = false;
		for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
			const block = blocks[indexBlock];
			const dependencies = block.dependencies;

			for (let indexDep = 0; indexDep < dependencies.length; indexDep++) {
				const d = dependencies[indexDep];

				const warnings = d.getWarnings(this.moduleGraph);
				if (warnings) {
					for (let indexWar = 0; indexWar < warnings.length; indexWar++) {
						const w = warnings[indexWar];

						const warning = new ModuleDependencyWarning(module, w, d.loc);
						this.warnings.push(warning);
						hasProblems = true;
					}
				}
				const errors = d.getErrors(this.moduleGraph);
				if (errors) {
					for (let indexErr = 0; indexErr < errors.length; indexErr++) {
						const e = errors[indexErr];

						const error = new ModuleDependencyError(module, e, d.loc);
						this.errors.push(error);
						hasProblems = true;
					}
				}
			}

			if (this.reportDependencyErrorsAndWarnings(module, block.blocks))
				hasProblems = true;
		}
		return hasProblems;
	}

	codeGeneration(callback) {
		const { chunkGraph } = this;
		this.codeGenerationResults = new CodeGenerationResults(
			this.outputOptions.hashFunction
		);
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const jobs = [];
		for (const module of this.modules) {
			const runtimes = chunkGraph.getModuleRuntimes(module);
			if (runtimes.size === 1) {
				for (const runtime of runtimes) {
					const hash = chunkGraph.getModuleHash(module, runtime);
					jobs.push({ module, hash, runtime, runtimes: [runtime] });
				}
			} else if (runtimes.size > 1) {
				/** @type {Map<string, { runtimes: RuntimeSpec[] }>} */
				const map = new Map();
				for (const runtime of runtimes) {
					const hash = chunkGraph.getModuleHash(module, runtime);
					const job = map.get(hash);
					if (job === undefined) {
						const newJob = { module, hash, runtime, runtimes: [runtime] };
						jobs.push(newJob);
						map.set(hash, newJob);
					} else {
						job.runtimes.push(runtime);
					}
				}
			}
		}

		this._runCodeGenerationJobs(jobs, callback);
	}

	_runCodeGenerationJobs(jobs, callback) {
		if (jobs.length === 0) {
			return callback();
		}
		let statModulesFromCache = 0;
		let statModulesGenerated = 0;
		const { chunkGraph, moduleGraph, dependencyTemplates, runtimeTemplate } =
			this;
		const results = this.codeGenerationResults;
		const errors = [];
		/** @type {Set<Module> | undefined} */
		let notCodeGeneratedModules = undefined;
		const runIteration = () => {
			let delayedJobs = [];
			let delayedModules = new Set();
			asyncLib.eachLimit(
				jobs,
				this.options.parallelism,
				(job, callback) => {
					const { module } = job;
					const { codeGenerationDependencies } = module;
					if (codeGenerationDependencies !== undefined) {
						if (
							notCodeGeneratedModules === undefined ||
							codeGenerationDependencies.some(dep => {
								const referencedModule = moduleGraph.getModule(dep);
								return notCodeGeneratedModules.has(referencedModule);
							})
						) {
							delayedJobs.push(job);
							delayedModules.add(module);
							return callback();
						}
					}
					const { hash, runtime, runtimes } = job;
					this._codeGenerationModule(
						module,
						runtime,
						runtimes,
						hash,
						dependencyTemplates,
						chunkGraph,
						moduleGraph,
						runtimeTemplate,
						errors,
						results,
						(err, codeGenerated) => {
							if (codeGenerated) statModulesGenerated++;
							else statModulesFromCache++;
							callback(err);
						}
					);
				},
				err => {
					if (err) return callback(err);
					if (delayedJobs.length > 0) {
						if (delayedJobs.length === jobs.length) {
							return callback(
								new Error(
									`Unable to make progress during code generation because of circular code generation dependency: ${Array.from(
										delayedModules,
										m => m.identifier()
									).join(", ")}`
								)
							);
						}
						jobs = delayedJobs;
						delayedJobs = [];
						notCodeGeneratedModules = delayedModules;
						delayedModules = new Set();
						return runIteration();
					}
					if (errors.length > 0) {
						errors.sort(
							compareSelect(err => err.module, compareModulesByIdentifier)
						);
						for (const error of errors) {
							this.errors.push(error);
						}
					}
					this.logger.log(
						`${Math.round(
							(100 * statModulesGenerated) /
								(statModulesGenerated + statModulesFromCache)
						)}% code generated (${statModulesGenerated} generated, ${statModulesFromCache} from cache)`
					);
					callback();
				}
			);
		};
		runIteration();
	}

	/**
	 * @param {Module} module module
	 * @param {RuntimeSpec} runtime runtime
	 * @param {RuntimeSpec[]} runtimes runtimes
	 * @param {string} hash hash
	 * @param {DependencyTemplates} dependencyTemplates dependencyTemplates
	 * @param {ChunkGraph} chunkGraph chunkGraph
	 * @param {ModuleGraph} moduleGraph moduleGraph
	 * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
	 * @param {WebpackError[]} errors errors
	 * @param {CodeGenerationResults} results results
	 * @param {function(WebpackError=, boolean=): void} callback callback
	 */
	_codeGenerationModule(
		module,
		runtime,
		runtimes,
		hash,
		dependencyTemplates,
		chunkGraph,
		moduleGraph,
		runtimeTemplate,
		errors,
		results,
		callback
	) {
		let codeGenerated = false;
		const cache = new MultiItemCache(
			runtimes.map(runtime =>
				this._codeGenerationCache.getItemCache(
					`${module.identifier()}|${getRuntimeKey(runtime)}`,
					`${hash}|${dependencyTemplates.getHash()}`
				)
			)
		);
		cache.get((err, cachedResult) => {
			if (err) return callback(err);
			let result;
			if (!cachedResult) {
				try {
					codeGenerated = true;
					this.codeGeneratedModules.add(module);
					result = module.codeGeneration({
						chunkGraph,
						moduleGraph,
						dependencyTemplates,
						runtimeTemplate,
						runtime,
						codeGenerationResults: results,
						compilation: this
					});
				} catch (err) {
					errors.push(new CodeGenerationError(module, err));
					result = cachedResult = {
						sources: new Map(),
						runtimeRequirements: null
					};
				}
			} else {
				result = cachedResult;
			}
			for (const runtime of runtimes) {
				results.add(module, runtime, result);
			}
			if (!cachedResult) {
				cache.store(result, err => callback(err, codeGenerated));
			} else {
				callback(null, codeGenerated);
			}
		});
	}

	_getChunkGraphEntries() {
		/** @type {Set<Chunk>} */
		const treeEntries = new Set();
		for (const ep of this.entrypoints.values()) {
			const chunk = ep.getRuntimeChunk();
			if (chunk) treeEntries.add(chunk);
		}
		for (const ep of this.asyncEntrypoints) {
			const chunk = ep.getRuntimeChunk();
			if (chunk) treeEntries.add(chunk);
		}
		return treeEntries;
	}

	/**
	 * @param {Object} options options
	 * @param {ChunkGraph=} options.chunkGraph the chunk graph
	 * @param {Iterable<Module>=} options.modules modules
	 * @param {Iterable<Chunk>=} options.chunks chunks
	 * @param {CodeGenerationResults=} options.codeGenerationResults codeGenerationResults
	 * @param {Iterable<Chunk>=} options.chunkGraphEntries chunkGraphEntries
	 * @returns {void}
	 */
	processRuntimeRequirements({
		chunkGraph = this.chunkGraph,
		modules = this.modules,
		chunks = this.chunks,
		codeGenerationResults = this.codeGenerationResults,
		chunkGraphEntries = this._getChunkGraphEntries()
	} = {}) {
		const context = { chunkGraph, codeGenerationResults };
		const { moduleMemCaches2 } = this;
		this.logger.time("runtime requirements.modules");
		const additionalModuleRuntimeRequirements =
			this.hooks.additionalModuleRuntimeRequirements;
		const runtimeRequirementInModule = this.hooks.runtimeRequirementInModule;
		for (const module of modules) {
			if (chunkGraph.getNumberOfModuleChunks(module) > 0) {
				const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
				for (const runtime of chunkGraph.getModuleRuntimes(module)) {
					if (memCache) {
						const cached = memCache.get(
							`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`
						);
						if (cached !== undefined) {
							if (cached !== null) {
								chunkGraph.addModuleRuntimeRequirements(
									module,
									runtime,
									cached,
									false
								);
							}
							continue;
						}
					}
					let set;
					const runtimeRequirements =
						codeGenerationResults.getRuntimeRequirements(module, runtime);
					if (runtimeRequirements && runtimeRequirements.size > 0) {
						set = new Set(runtimeRequirements);
					} else if (additionalModuleRuntimeRequirements.isUsed()) {
						set = new Set();
					} else {
						if (memCache) {
							memCache.set(
								`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`,
								null
							);
						}
						continue;
					}
					additionalModuleRuntimeRequirements.call(module, set, context);

					for (const r of set) {
						const hook = runtimeRequirementInModule.get(r);
						if (hook !== undefined) hook.call(module, set, context);
					}
					if (set.size === 0) {
						if (memCache) {
							memCache.set(
								`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`,
								null
							);
						}
					} else {
						if (memCache) {
							memCache.set(
								`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`,
								set
							);
							chunkGraph.addModuleRuntimeRequirements(
								module,
								runtime,
								set,
								false
							);
						} else {
							chunkGraph.addModuleRuntimeRequirements(module, runtime, set);
						}
					}
				}
			}
		}
		this.logger.timeEnd("runtime requirements.modules");

		this.logger.time("runtime requirements.chunks");
		for (const chunk of chunks) {
			const set = new Set();
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(
					module,
					chunk.runtime
				);
				for (const r of runtimeRequirements) set.add(r);
			}
			this.hooks.additionalChunkRuntimeRequirements.call(chunk, set, context);

			for (const r of set) {
				this.hooks.runtimeRequirementInChunk.for(r).call(chunk, set, context);
			}

			chunkGraph.addChunkRuntimeRequirements(chunk, set);
		}
		this.logger.timeEnd("runtime requirements.chunks");

		this.logger.time("runtime requirements.entries");
		for (const treeEntry of chunkGraphEntries) {
			const set = new Set();
			for (const chunk of treeEntry.getAllReferencedChunks()) {
				const runtimeRequirements =
					chunkGraph.getChunkRuntimeRequirements(chunk);
				for (const r of runtimeRequirements) set.add(r);
			}

			this.hooks.additionalTreeRuntimeRequirements.call(
				treeEntry,
				set,
				context
			);

			for (const r of set) {
				this.hooks.runtimeRequirementInTree
					.for(r)
					.call(treeEntry, set, context);
			}

			chunkGraph.addTreeRuntimeRequirements(treeEntry, set);
		}
		this.logger.timeEnd("runtime requirements.entries");
	}

	// TODO webpack 6 make chunkGraph argument non-optional
	/**
	 * @param {Chunk} chunk target chunk
	 * @param {RuntimeModule} module runtime module
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @returns {void}
	 */
	addRuntimeModule(chunk, module, chunkGraph = this.chunkGraph) {
		// Deprecated ModuleGraph association
		if (this._backCompat)
			ModuleGraph.setModuleGraphForModule(module, this.moduleGraph);

		// add it to the list
		this.modules.add(module);
		this._modules.set(module.identifier(), module);

		// connect to the chunk graph
		chunkGraph.connectChunkAndModule(chunk, module);
		chunkGraph.connectChunkAndRuntimeModule(chunk, module);
		if (module.fullHash) {
			chunkGraph.addFullHashModuleToChunk(chunk, module);
		} else if (module.dependentHash) {
			chunkGraph.addDependentHashModuleToChunk(chunk, module);
		}

		// attach runtime module
		module.attach(this, chunk, chunkGraph);

		// Setup internals
		const exportsInfo = this.moduleGraph.getExportsInfo(module);
		exportsInfo.setHasProvideInfo();
		if (typeof chunk.runtime === "string") {
			exportsInfo.setUsedForSideEffectsOnly(chunk.runtime);
		} else if (chunk.runtime === undefined) {
			exportsInfo.setUsedForSideEffectsOnly(undefined);
		} else {
			for (const runtime of chunk.runtime) {
				exportsInfo.setUsedForSideEffectsOnly(runtime);
			}
		}
		chunkGraph.addModuleRuntimeRequirements(
			module,
			chunk.runtime,
			new Set([RuntimeGlobals.requireScope])
		);

		// runtime modules don't need ids
		chunkGraph.setModuleId(module, "");

		// Call hook
		this.hooks.runtimeModule.call(module, chunk);
	}

	/**
	 * If `module` is passed, `loc` and `request` must also be passed.
	 * @param {string | ChunkGroupOptions} groupOptions options for the chunk group
	 * @param {Module=} module the module the references the chunk group
	 * @param {DependencyLocation=} loc the location from with the chunk group is referenced (inside of module)
	 * @param {string=} request the request from which the the chunk group is referenced
	 * @returns {ChunkGroup} the new or existing chunk group
	 */
	addChunkInGroup(groupOptions, module, loc, request) {
		if (typeof groupOptions === "string") {
			groupOptions = { name: groupOptions };
		}
		const name = groupOptions.name;

		if (name) {
			const chunkGroup = this.namedChunkGroups.get(name);
			if (chunkGroup !== undefined) {
				chunkGroup.addOptions(groupOptions);
				if (module) {
					chunkGroup.addOrigin(module, loc, request);
				}
				return chunkGroup;
			}
		}
		const chunkGroup = new ChunkGroup(groupOptions);
		if (module) chunkGroup.addOrigin(module, loc, request);
		const chunk = this.addChunk(name);

		connectChunkGroupAndChunk(chunkGroup, chunk);

		this.chunkGroups.push(chunkGroup);
		if (name) {
			this.namedChunkGroups.set(name, chunkGroup);
		}
		return chunkGroup;
	}

	/**
	 * @param {EntryOptions} options options for the entrypoint
	 * @param {Module} module the module the references the chunk group
	 * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)
	 * @param {string} request the request from which the the chunk group is referenced
	 * @returns {Entrypoint} the new or existing entrypoint
	 */
	addAsyncEntrypoint(options, module, loc, request) {
		const name = options.name;
		if (name) {
			const entrypoint = this.namedChunkGroups.get(name);
			if (entrypoint instanceof Entrypoint) {
				if (entrypoint !== undefined) {
					if (module) {
						entrypoint.addOrigin(module, loc, request);
					}
					return entrypoint;
				}
			} else if (entrypoint) {
				throw new Error(
					`Cannot add an async entrypoint with the name '${name}', because there is already an chunk group with this name`
				);
			}
		}
		const chunk = this.addChunk(name);
		if (options.filename) {
			chunk.filenameTemplate = options.filename;
		}
		const entrypoint = new Entrypoint(options, false);
		entrypoint.setRuntimeChunk(chunk);
		entrypoint.setEntrypointChunk(chunk);
		if (name) {
			this.namedChunkGroups.set(name, entrypoint);
		}
		this.chunkGroups.push(entrypoint);
		this.asyncEntrypoints.push(entrypoint);
		connectChunkGroupAndChunk(entrypoint, chunk);
		if (module) {
			entrypoint.addOrigin(module, loc, request);
		}
		return entrypoint;
	}

	/**
	 * This method first looks to see if a name is provided for a new chunk,
	 * and first looks to see if any named chunks already exist and reuse that chunk instead.
	 *
	 * @param {string=} name optional chunk name to be provided
	 * @returns {Chunk} create a chunk (invoked during seal event)
	 */
	addChunk(name) {
		if (name) {
			const chunk = this.namedChunks.get(name);
			if (chunk !== undefined) {
				return chunk;
			}
		}
		const chunk = new Chunk(name, this._backCompat);
		this.chunks.add(chunk);
		if (this._backCompat)
			ChunkGraph.setChunkGraphForChunk(chunk, this.chunkGraph);
		if (name) {
			this.namedChunks.set(name, chunk);
		}
		return chunk;
	}

	/**
	 * @deprecated
	 * @param {Module} module module to assign depth
	 * @returns {void}
	 */
	assignDepth(module) {
		const moduleGraph = this.moduleGraph;

		const queue = new Set([module]);
		let depth;

		moduleGraph.setDepth(module, 0);

		/**
		 * @param {Module} module module for processing
		 * @returns {void}
		 */
		const processModule = module => {
			if (!moduleGraph.setDepthIfLower(module, depth)) return;
			queue.add(module);
		};

		for (module of queue) {
			queue.delete(module);
			depth = moduleGraph.getDepth(module) + 1;

			for (const connection of moduleGraph.getOutgoingConnections(module)) {
				const refModule = connection.module;
				if (refModule) {
					processModule(refModule);
				}
			}
		}
	}

	/**
	 * @param {Set<Module>} modules module to assign depth
	 * @returns {void}
	 */
	assignDepths(modules) {
		const moduleGraph = this.moduleGraph;

		/** @type {Set<Module | number>} */
		const queue = new Set(modules);
		queue.add(1);
		let depth = 0;

		let i = 0;
		for (const module of queue) {
			i++;
			if (typeof module === "number") {
				depth = module;
				if (queue.size === i) return;
				queue.add(depth + 1);
			} else {
				moduleGraph.setDepth(module, depth);
				for (const { module: refModule } of moduleGraph.getOutgoingConnections(
					module
				)) {
					if (refModule) {
						queue.add(refModule);
					}
				}
			}
		}
	}

	/**
	 * @param {Dependency} dependency the dependency
	 * @param {RuntimeSpec} runtime the runtime
	 * @returns {(string[] | ReferencedExport)[]} referenced exports
	 */
	getDependencyReferencedExports(dependency, runtime) {
		const referencedExports = dependency.getReferencedExports(
			this.moduleGraph,
			runtime
		);
		return this.hooks.dependencyReferencedExports.call(
			referencedExports,
			dependency,
			runtime
		);
	}

	/**
	 *
	 * @param {Module} module module relationship for removal
	 * @param {DependenciesBlockLike} block //TODO: good description
	 * @returns {void}
	 */
	removeReasonsOfDependencyBlock(module, block) {
		if (block.blocks) {
			for (const b of block.blocks) {
				this.removeReasonsOfDependencyBlock(module, b);
			}
		}

		if (block.dependencies) {
			for (const dep of block.dependencies) {
				const originalModule = this.moduleGraph.getModule(dep);
				if (originalModule) {
					this.moduleGraph.removeConnection(dep);

					if (this.chunkGraph) {
						for (const chunk of this.chunkGraph.getModuleChunks(
							originalModule
						)) {
							this.patchChunksAfterReasonRemoval(originalModule, chunk);
						}
					}
				}
			}
		}
	}

	/**
	 * @param {Module} module module to patch tie
	 * @param {Chunk} chunk chunk to patch tie
	 * @returns {void}
	 */
	patchChunksAfterReasonRemoval(module, chunk) {
		if (!module.hasReasons(this.moduleGraph, chunk.runtime)) {
			this.removeReasonsOfDependencyBlock(module, module);
		}
		if (!module.hasReasonForChunk(chunk, this.moduleGraph, this.chunkGraph)) {
			if (this.chunkGraph.isModuleInChunk(module, chunk)) {
				this.chunkGraph.disconnectChunkAndModule(chunk, module);
				this.removeChunkFromDependencies(module, chunk);
			}
		}
	}

	/**
	 *
	 * @param {DependenciesBlock} block block tie for Chunk
	 * @param {Chunk} chunk chunk to remove from dep
	 * @returns {void}
	 */
	removeChunkFromDependencies(block, chunk) {
		/**
		 * @param {Dependency} d dependency to (maybe) patch up
		 */
		const iteratorDependency = d => {
			const depModule = this.moduleGraph.getModule(d);
			if (!depModule) {
				return;
			}
			this.patchChunksAfterReasonRemoval(depModule, chunk);
		};

		const blocks = block.blocks;
		for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
			const asyncBlock = blocks[indexBlock];
			const chunkGroup = this.chunkGraph.getBlockChunkGroup(asyncBlock);
			// Grab all chunks from the first Block's AsyncDepBlock
			const chunks = chunkGroup.chunks;
			// For each chunk in chunkGroup
			for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
				const iteratedChunk = chunks[indexChunk];
				chunkGroup.removeChunk(iteratedChunk);
				// Recurse
				this.removeChunkFromDependencies(block, iteratedChunk);
			}
		}

		if (block.dependencies) {
			for (const dep of block.dependencies) iteratorDependency(dep);
		}
	}

	assignRuntimeIds() {
		const { chunkGraph } = this;
		const processEntrypoint = ep => {
			const runtime = ep.options.runtime || ep.name;
			const chunk = ep.getRuntimeChunk();
			chunkGraph.setRuntimeId(runtime, chunk.id);
		};
		for (const ep of this.entrypoints.values()) {
			processEntrypoint(ep);
		}
		for (const ep of this.asyncEntrypoints) {
			processEntrypoint(ep);
		}
	}

	sortItemsWithChunkIds() {
		for (const chunkGroup of this.chunkGroups) {
			chunkGroup.sortItems();
		}

		this.errors.sort(compareErrors);
		this.warnings.sort(compareErrors);
		this.children.sort(byNameOrHash);
	}

	summarizeDependencies() {
		for (
			let indexChildren = 0;
			indexChildren < this.children.length;
			indexChildren++
		) {
			const child = this.children[indexChildren];

			this.fileDependencies.addAll(child.fileDependencies);
			this.contextDependencies.addAll(child.contextDependencies);
			this.missingDependencies.addAll(child.missingDependencies);
			this.buildDependencies.addAll(child.buildDependencies);
		}

		for (const module of this.modules) {
			module.addCacheDependencies(
				this.fileDependencies,
				this.contextDependencies,
				this.missingDependencies,
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		const errors = [];
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.slice(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
				}
				statModulesHashed++;
				const digest = this._createModuleHash(
					module,
					chunkGraph,
					runtime,
					hashFunction,
					runtimeTemplate,
					hashDigest,
					hashDigestLength,
					errors
				);
				if (memCache) {
					memCache.set(`moduleHash-${getRuntimeKey(runtime)}`, digest);
				}
			}
		}
		if (errors.length > 0) {
			errors.sort(compareSelect(err => err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}
		this.logger.log(
			`${statModulesHashed} modules hashed, ${statModulesFromCache} from cache (${
				Math.round(
					(100 * (statModulesHashed + statModulesFromCache)) / this.modules.size
				) / 100
			} variants per module in average)`
		);
	}

	_createModuleHash(
		module,
		chunkGraph,
		runtime,
		hashFunction,
		runtimeTemplate,
		hashDigest,
		hashDigestLength,
		errors
	) {
		let moduleHashDigest;
		try {
			const moduleHash = createHash(hashFunction);
			module.updateHash(moduleHash, {
				chunkGraph,
				runtime,
				runtimeTemplate
			});
			moduleHashDigest = /** @type {string} */ (moduleHash.digest(hashDigest));
		} catch (err) {
			errors.push(new ModuleHashingError(module, err));
			moduleHashDigest = "XXXXXX";
		}
		chunkGraph.setModuleHashes(
			module,
			runtime,
			moduleHashDigest,
			moduleHashDigest.slice(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.slice(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);
		if (errors.length > 0) {
			errors.sort(compareSelect(err => err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.slice(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.slice(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
			chunkHash.update(chunk.hash);
			chunkHash.update(this.hash);
			const chunkHashDigest = /** @type {string} */ (
				chunkHash.digest(hashDigest)
			);
			chunk.hash = chunkHashDigest;
			chunk.renderedHash = chunk.hash.slice(0, hashDigestLength);
			this.hooks.contentHash.call(chunk);
		}
		this.logger.timeEnd("hashing: process full hash modules");
		return codeGenerationJobs;
	}

	/**
	 * @param {string} file file name
	 * @param {Source} source asset source
	 * @param {AssetInfo} assetInfo extra asset information
	 * @returns {void}
	 */
	emitAsset(file, source, assetInfo = {}) {
		if (this.assets[file]) {
			if (!isSourceEqual(this.assets[file], source)) {
				this.errors.push(
					new WebpackError(
						`Conflict: Multiple assets emit different content to the same filename ${file}${
							assetInfo.sourceFilename
								? `. Original source ${assetInfo.sourceFilename}`
								: ""
						}`
					)
				);
				this.assets[file] = source;
				this._setAssetInfo(file, assetInfo);
				return;
			}
			const oldInfo = this.assetsInfo.get(file);
			const newInfo = Object.assign({}, oldInfo, assetInfo);
			this._setAssetInfo(file, newInfo, oldInfo);
			return;
		}
		this.assets[file] = source;
		this._setAssetInfo(file, assetInfo, undefined);
	}

	_setAssetInfo(file, newInfo, oldInfo = this.assetsInfo.get(file)) {
		if (newInfo === undefined) {
			this.assetsInfo.delete(file);
		} else {
			this.assetsInfo.set(file, newInfo);
		}
		const oldRelated = oldInfo && oldInfo.related;
		const newRelated = newInfo && newInfo.related;
		if (oldRelated) {
			for (const key of Object.keys(oldRelated)) {
				const remove = name => {
					const relatedIn = this._assetsRelatedIn.get(name);
					if (relatedIn === undefined) return;
					const entry = relatedIn.get(key);
					if (entry === undefined) return;
					entry.delete(file);
					if (entry.size !== 0) return;
					relatedIn.delete(key);
					if (relatedIn.size === 0) this._assetsRelatedIn.delete(name);
				};
				const entry = oldRelated[key];
				if (Array.isArray(entry)) {
					entry.forEach(remove);
				} else if (entry) {
					remove(entry);
				}
			}
		}
		if (newRelated) {
			for (const key of Object.keys(newRelated)) {
				const add = name => {
					let relatedIn = this._assetsRelatedIn.get(name);
					if (relatedIn === undefined) {
						this._assetsRelatedIn.set(name, (relatedIn = new Map()));
					}
					let entry = relatedIn.get(key);
					if (entry === undefined) {
						relatedIn.set(key, (entry = new Set()));
					}
					entry.add(file);
				};
				const entry = newRelated[key];
				if (Array.isArray(entry)) {
					entry.forEach(add);
				} else if (entry) {
					add(entry);
				}
			}
		}
	}

	/**
	 * @param {string} file file name
	 * @param {Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new
	 * @param {AssetInfo | function(AssetInfo | undefined): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new
	 */
	updateAsset(
		file,
		newSourceOrFunction,
		assetInfoUpdateOrFunction = undefined
	) {
		if (!this.assets[file]) {
			throw new Error(
				`Called Compilation.updateAsset for not existing filename ${file}`
			);
		}
		if (typeof newSourceOrFunction === "function") {
			this.assets[file] = newSourceOrFunction(this.assets[file]);
		} else {
			this.assets[file] = newSourceOrFunction;
		}
		if (assetInfoUpdateOrFunction !== undefined) {
			const oldInfo = this.assetsInfo.get(file) || EMPTY_ASSET_INFO;
			if (typeof assetInfoUpdateOrFunction === "function") {
				this._setAssetInfo(file, assetInfoUpdateOrFunction(oldInfo), oldInfo);
			} else {
				this._setAssetInfo(
					file,
					cachedCleverMerge(oldInfo, assetInfoUpdateOrFunction),
					oldInfo
				);
			}
		}
	}

	renameAsset(file, newFile) {
		const source = this.assets[file];
		if (!source) {
			throw new Error(
				`Called Compilation.renameAsset for not existing filename ${file}`
			);
		}
		if (this.assets[newFile]) {
			if (!isSourceEqual(this.assets[file], source)) {
				this.errors.push(
					new WebpackError(
						`Conflict: Called Compilation.renameAsset for already existing filename ${newFile} with different content`
					)
				);
			}
		}
		const assetInfo = this.assetsInfo.get(file);
		// Update related in all other assets
		const relatedInInfo = this._assetsRelatedIn.get(file);
		if (relatedInInfo) {
			for (const [key, assets] of relatedInInfo) {
				for (const name of assets) {
					const info = this.assetsInfo.get(name);
					if (!info) continue;
					const related = info.related;
					if (!related) continue;
					const entry = related[key];
					let newEntry;
					if (Array.isArray(entry)) {
						newEntry = entry.map(x => (x === file ? newFile : x));
					} else if (entry === file) {
						newEntry = newFile;
					} else continue;
					this.assetsInfo.set(name, {
						...info,
						related: {
							...related,
							[key]: newEntry
						}
					});
				}
			}
		}
		this._setAssetInfo(file, undefined, assetInfo);
		this._setAssetInfo(newFile, assetInfo);
		delete this.assets[file];
		this.assets[newFile] = source;
		for (const chunk of this.chunks) {
			{
				const size = chunk.files.size;
				chunk.files.delete(file);
				if (size !== chunk.files.size) {
					chunk.files.add(newFile);
				}
			}
			{
				const size = chunk.auxiliaryFiles.size;
				chunk.auxiliaryFiles.delete(file);
				if (size !== chunk.auxiliaryFiles.size) {
					chunk.auxiliaryFiles.add(newFile);
				}
			}
		}
	}

	/**
	 * @param {string} file file name
	 */
	deleteAsset(file) {
		if (!this.assets[file]) {
			return;
		}
		delete this.assets[file];
		const assetInfo = this.assetsInfo.get(file);
		this._setAssetInfo(file, undefined, assetInfo);
		const related = assetInfo && assetInfo.related;
		if (related) {
			for (const key of Object.keys(related)) {
				const checkUsedAndDelete = file => {
					if (!this._assetsRelatedIn.has(file)) {
						this.deleteAsset(file);
					}
				};
				const items = related[key];
				if (Array.isArray(items)) {
					items.forEach(checkUsedAndDelete);
				} else if (items) {
					checkUsedAndDelete(items);
				}
			}
		}
		// TODO If this becomes a performance problem
		// store a reverse mapping from asset to chunk
		for (const chunk of this.chunks) {
			chunk.files.delete(file);
			chunk.auxiliaryFiles.delete(file);
		}
	}

	getAssets() {
		/** @type {Readonly<Asset>[]} */
		const array = [];
		for (const assetName of Object.keys(this.assets)) {
			if (Object.prototype.hasOwnProperty.call(this.assets, assetName)) {
				array.push({
					name: assetName,
					source: this.assets[assetName],
					info: this.assetsInfo.get(assetName) || EMPTY_ASSET_INFO
				});
			}
		}
		return array;
	}

	/**
	 * @param {string} name the name of the asset
	 * @returns {Readonly<Asset> | undefined} the asset or undefined when not found
	 */
	getAsset(name) {
		if (!Object.prototype.hasOwnProperty.call(this.assets, name))
			return undefined;
		return {
			name,
			source: this.assets[name],
			info: this.assetsInfo.get(name) || EMPTY_ASSET_INFO
		};
	}

	clearAssets() {
		for (const chunk of this.chunks) {
			chunk.files.clear();
			chunk.auxiliaryFiles.clear();
		}
	}

	createModuleAssets() {
		const { chunkGraph } = this;
		for (const module of this.modules) {
			if (module.buildInfo.assets) {
				const assetsInfo = module.buildInfo.assetsInfo;
				for (const assetName of Object.keys(module.buildInfo.assets)) {
					const fileName = this.getPath(assetName, {
						chunkGraph: this.chunkGraph,
						module
					});
					for (const chunk of chunkGraph.getModuleChunksIterable(module)) {
						chunk.auxiliaryFiles.add(fileName);
					}
					this.emitAsset(
						fileName,
						module.buildInfo.assets[assetName],
						assetsInfo ? assetsInfo.get(assetName) : undefined
					);
					this.hooks.moduleAsset.call(module, fileName);
				}
			}
		}
	}

	/**
	 * @param {RenderManifestOptions} options options object
	 * @returns {RenderManifestEntry[]} manifest entries
	 */
	getRenderManifest(options) {
		return this.hooks.renderManifest.call([], options);
	}

	/**
	 * @param {Callback} callback signals when the call finishes
	 * @returns {void}
	 */
	createChunkAssets(callback) {
		const outputOptions = this.outputOptions;
		const cachedSourceMap = new WeakMap();
		/** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */
		const alreadyWrittenFiles = new Map();

		asyncLib.forEachLimit(
			this.chunks,
			15,
			(chunk, callback) => {
				/** @type {RenderManifestEntry[]} */
				let manifest;
				try {
					manifest = this.getRenderManifest({
						chunk,
						hash: this.hash,
						fullHash: this.fullHash,
						outputOptions,
						codeGenerationResults: this.codeGenerationResults,
						moduleTemplates: this.moduleTemplates,
						dependencyTemplates: this.dependencyTemplates,
						chunkGraph: this.chunkGraph,
						moduleGraph: this.moduleGraph,
						runtimeTemplate: this.runtimeTemplate
					});
				} catch (err) {
					this.errors.push(new ChunkRenderError(chunk, "", err));
					return callback();
				}
				asyncLib.forEach(
					manifest,
					(fileManifest, callback) => {
						const ident = fileManifest.identifier;
						const usedHash = fileManifest.hash;

						const assetCacheItem = this._assetsCache.getItemCache(
							ident,
							usedHash
						);

						assetCacheItem.get((err, sourceFromCache) => {
							/** @type {string | function(PathData, AssetInfo=): string} */
							let filenameTemplate;
							/** @type {string} */
							let file;
							/** @type {AssetInfo} */
							let assetInfo;

							let inTry = true;
							const errorAndCallback = err => {
								const filename =
									file ||
									(typeof file === "string"
										? file
										: typeof filenameTemplate === "string"
										? filenameTemplate
										: "");

								this.errors.push(new ChunkRenderError(chunk, filename, err));
								inTry = false;
								return callback();
							};

							try {
								if ("filename" in fileManifest) {
									file = fileManifest.filename;
									assetInfo = fileManifest.info;
								} else {
									filenameTemplate = fileManifest.filenameTemplate;
									const pathAndInfo = this.getPathWithInfo(
										filenameTemplate,
										fileManifest.pathOptions
									);
									file = pathAndInfo.path;
									assetInfo = fileManifest.info
										? {
												...pathAndInfo.info,
												...fileManifest.info
										  }
										: pathAndInfo.info;
								}

								if (err) {
									return errorAndCallback(err);
								}

								let source = sourceFromCache;

								// check if the same filename was already written by another chunk
								const alreadyWritten = alreadyWrittenFiles.get(file);
								if (alreadyWritten !== undefined) {
									if (alreadyWritten.hash !== usedHash) {
										inTry = false;
										return callback(
											new WebpackError(
												`Conflict: Multiple chunks emit assets to the same filename ${file}` +
													` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`
											)
										);
									} else {
										source = alreadyWritten.source;
									}
								} else if (!source) {
									// render the asset
									source = fileManifest.render();

									// Ensure that source is a cached source to avoid additional cost because of repeated access
									if (!(source instanceof CachedSource)) {
										const cacheEntry = cachedSourceMap.get(source);
										if (cacheEntry) {
											source = cacheEntry;
										} else {
											const cachedSource = new CachedSource(source);
											cachedSourceMap.set(source, cachedSource);
											source = cachedSource;
										}
									}
								}
								this.emitAsset(file, source, assetInfo);
								if (fileManifest.auxiliary) {
									chunk.auxiliaryFiles.add(file);
								} else {
									chunk.files.add(file);
								}
								this.hooks.chunkAsset.call(chunk, file);
								alreadyWrittenFiles.set(file, {
									hash: usedHash,
									source,
									chunk
								});
								if (source !== sourceFromCache) {
									assetCacheItem.store(source, err => {
										if (err) return errorAndCallback(err);
										inTry = false;
										return callback();
									});
								} else {
									inTry = false;
									callback();
								}
							} catch (err) {
								if (!inTry) throw err;
								errorAndCallback(err);
							}
						});
					},
					callback
				);
			},
			callback
		);
	}

	/**
	 * @param {string | function(PathData, AssetInfo=): string} filename used to get asset path with hash
	 * @param {PathData} data context data
	 * @returns {string} interpolated path
	 */
	getPath(filename, data = {}) {
		if (!data.hash) {
			data = {
				hash: this.hash,
				...data
			};
		}
		return this.getAssetPath(filename, data);
	}

	/**
	 * @param {string | function(PathData, AssetInfo=): string} filename used to get asset path with hash
	 * @param {PathData} data context data
	 * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info
	 */
	getPathWithInfo(filename, data = {}) {
		if (!data.hash) {
			data = {
				hash: this.hash,
				...data
			};
		}
		return this.getAssetPathWithInfo(filename, data);
	}

	/**
	 * @param {string | function(PathData, AssetInfo=): string} filename used to get asset path with hash
	 * @param {PathData} data context data
	 * @returns {string} interpolated path
	 */
	getAssetPath(filename, data) {
		return this.hooks.assetPath.call(
			typeof filename === "function" ? filename(data) : filename,
			data,
			undefined
		);
	}

	/**
	 * @param {string | function(PathData, AssetInfo=): string} filename used to get asset path with hash
	 * @param {PathData} data context data
	 * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info
	 */
	getAssetPathWithInfo(filename, data) {
		const assetInfo = {};
		// TODO webpack 5: refactor assetPath hook to receive { path, info } object
		const newPath = this.hooks.assetPath.call(
			typeof filename === "function" ? filename(data, assetInfo) : filename,
			data,
			assetInfo
		);
		return { path: newPath, info: assetInfo };
	}

	getWarnings() {
		return this.hooks.processWarnings.call(this.warnings);
	}

	getErrors() {
		return this.hooks.processErrors.call(this.errors);
	}

	/**
	 * This function allows you to run another instance of webpack inside of webpack however as
	 * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins
	 * from parent (or top level compiler) and creates a child Compilation
	 *
	 * @param {string} name name of the child compiler
	 * @param {OutputOptions=} outputOptions // Need to convert config schema to types for this
	 * @param {Array<WebpackPluginInstance | WebpackPluginFunction>=} plugins webpack plugins that will be applied
	 * @returns {Compiler} creates a child Compiler instance
	 */
	createChildCompiler(name, outputOptions, plugins) {
		const idx = this.childrenCounters[name] || 0;
		this.childrenCounters[name] = idx + 1;
		return this.compiler.createChildCompiler(
			this,
			name,
			idx,
			outputOptions,
			plugins
		);
	}

	/**
	 * @param {Module} module the module
	 * @param {ExecuteModuleOptions} options options
	 * @param {ExecuteModuleCallback} callback callback
	 */
	executeModule(module, options, callback) {
		// Aggregate all referenced modules and ensure they are ready
		const modules = new Set([module]);
		processAsyncTree(
			modules,
			10,
			/**
			 * @param {Module} module the module
			 * @param {function(Module): void} push push more jobs
			 * @param {Callback} callback callback
			 * @returns {void}
			 */
			(module, push, callback) => {
				this.buildQueue.waitFor(module, err => {
					if (err) return callback(err);
					this.processDependenciesQueue.waitFor(module, err => {
						if (err) return callback(err);
						for (const { module: m } of this.moduleGraph.getOutgoingConnections(
							module
						)) {
							const size = modules.size;
							modules.add(m);
							if (modules.size !== size) push(m);
						}
						callback();
					});
				});
			},
			err => {
				if (err) return callback(err);

				// Create new chunk graph, chunk and entrypoint for the build time execution
				const chunkGraph = new ChunkGraph(
					this.moduleGraph,
					this.outputOptions.hashFunction
				);
				const runtime = "build time";
				const { hashFunction, hashDigest, hashDigestLength } =
					this.outputOptions;
				const runtimeTemplate = this.runtimeTemplate;

				const chunk = new Chunk("build time chunk", this._backCompat);
				chunk.id = chunk.name;
				chunk.ids = [chunk.id];
				chunk.runtime = runtime;

				const entrypoint = new Entrypoint({
					runtime,
					chunkLoading: false,
					...options.entryOptions
				});
				chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
				connectChunkGroupAndChunk(entrypoint, chunk);
				entrypoint.setRuntimeChunk(chunk);
				entrypoint.setEntrypointChunk(chunk);

				const chunks = new Set([chunk]);

				// Assign ids to modules and modules to the chunk
				for (const module of modules) {
					const id = module.identifier();
					chunkGraph.setModuleId(module, id);
					chunkGraph.connectChunkAndModule(chunk, module);
				}

				/** @type {WebpackError[]} */
				const errors = [];

				// Hash modules
				for (const module of modules) {
					this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
				}

				const codeGenerationResults = new CodeGenerationResults(
					this.outputOptions.hashFunction
				);
				/**
				 * @param {Module} module the module
				 * @param {Callback} callback callback
				 * @returns {void}
				 */
				const codeGen = (module, callback) => {
					this._codeGenerationModule(
						module,
						runtime,
						[runtime],
						chunkGraph.getModuleHash(module, runtime),
						this.dependencyTemplates,
						chunkGraph,
						this.moduleGraph,
						runtimeTemplate,
						errors,
						codeGenerationResults,
						(err, codeGenerated) => {
							callback(err);
						}
					);
				};

				const reportErrors = () => {
					if (errors.length > 0) {
						errors.sort(
							compareSelect(err => err.module, compareModulesByIdentifier)
						);
						for (const error of errors) {
							this.errors.push(error);
						}
						errors.length = 0;
					}
				};

				// Generate code for all aggregated modules
				asyncLib.eachLimit(modules, 10, codeGen, err => {
					if (err) return callback(err);
					reportErrors();

					// for backward-compat temporary set the chunk graph
					// TODO webpack 6
					const old = this.chunkGraph;
					this.chunkGraph = chunkGraph;
					this.processRuntimeRequirements({
						chunkGraph,
						modules,
						chunks,
						codeGenerationResults,
						chunkGraphEntries: chunks
					});
					this.chunkGraph = old;

					const runtimeModules =
						chunkGraph.getChunkRuntimeModulesIterable(chunk);

					// Hash runtime modules
					for (const module of runtimeModules) {
						modules.add(module);
						this._createModuleHash(
							module,
							chunkGraph,
							runtime,
							hashFunction,
							runtimeTemplate,
							hashDigest,
							hashDigestLength
						);
					}

					// Generate code for all runtime modules
					asyncLib.eachLimit(runtimeModules, 10, codeGen, err => {
						if (err) return callback(err);
						reportErrors();

						/** @type {Map<Module, ExecuteModuleArgument>} */
						const moduleArgumentsMap = new Map();
						/** @type {Map<string, ExecuteModuleArgument>} */
						const moduleArgumentsById = new Map();

						/** @type {ExecuteModuleResult["fileDependencies"]} */
						const fileDependencies = new LazySet();
						/** @type {ExecuteModuleResult["contextDependencies"]} */
						const contextDependencies = new LazySet();
						/** @type {ExecuteModuleResult["missingDependencies"]} */
						const missingDependencies = new LazySet();
						/** @type {ExecuteModuleResult["buildDependencies"]} */
						const buildDependencies = new LazySet();

						/** @type {ExecuteModuleResult["assets"]} */
						const assets = new Map();

						let cacheable = true;

						/** @type {ExecuteModuleContext} */
						const context = {
							assets,
							__webpack_require__: undefined,
							chunk,
							chunkGraph
						};

						// Prepare execution
						asyncLib.eachLimit(
							modules,
							10,
							(module, callback) => {
								const codeGenerationResult = codeGenerationResults.get(
									module,
									runtime
								);
								/** @type {ExecuteModuleArgument} */
								const moduleArgument = {
									module,
									codeGenerationResult,
									preparedInfo: undefined,
									moduleObject: undefined
								};
								moduleArgumentsMap.set(module, moduleArgument);
								moduleArgumentsById.set(module.identifier(), moduleArgument);
								module.addCacheDependencies(
									fileDependencies,
									contextDependencies,
									missingDependencies,
									buildDependencies
								);
								if (module.buildInfo.cacheable === false) {
									cacheable = false;
								}
								if (module.buildInfo && module.buildInfo.assets) {
									const { assets: moduleAssets, assetsInfo } = module.buildInfo;
									for (const assetName of Object.keys(moduleAssets)) {
										assets.set(assetName, {
											source: moduleAssets[assetName],
											info: assetsInfo ? assetsInfo.get(assetName) : undefined
										});
									}
								}
								this.hooks.prepareModuleExecution.callAsync(
									moduleArgument,
									context,
									callback
								);
							},
							err => {
								if (err) return callback(err);

								let exports;
								try {
									const {
										strictModuleErrorHandling,
										strictModuleExceptionHandling
									} = this.outputOptions;
									const __webpack_require__ = id => {
										const cached = moduleCache[id];
										if (cached !== undefined) {
											if (cached.error) throw cached.error;
											return cached.exports;
										}
										const moduleArgument = moduleArgumentsById.get(id);
										return __webpack_require_module__(moduleArgument, id);
									};
									const interceptModuleExecution = (__webpack_require__[
										RuntimeGlobals.interceptModuleExecution.replace(
											"__webpack_require__.",
											""
										)
									] = []);
									const moduleCache = (__webpack_require__[
										RuntimeGlobals.moduleCache.replace(
											"__webpack_require__.",
											""
										)
									] = {});

									context.__webpack_require__ = __webpack_require__;

									/**
									 * @param {ExecuteModuleArgument} moduleArgument the module argument
									 * @param {string=} id id
									 * @returns {any} exports
									 */
									const __webpack_require_module__ = (moduleArgument, id) => {
										var execOptions = {
											id,
											module: {
												id,
												exports: {},
												loaded: false,
												error: undefined
											},
											require: __webpack_require__
										};
										interceptModuleExecution.forEach(handler =>
											handler(execOptions)
										);
										const module = moduleArgument.module;
										this.buildTimeExecutedModules.add(module);
										const moduleObject = execOptions.module;
										moduleArgument.moduleObject = moduleObject;
										try {
											if (id) moduleCache[id] = moduleObject;

											tryRunOrWebpackError(
												() =>
													this.hooks.executeModule.call(
														moduleArgument,
														context
													),
												"Compilation.hooks.executeModule"
											);
											moduleObject.loaded = true;
											return moduleObject.exports;
										} catch (e) {
											if (strictModuleExceptionHandling) {
												if (id) delete moduleCache[id];
											} else if (strictModuleErrorHandling) {
												moduleObject.error = e;
											}
											if (!e.module) e.module = module;
											throw e;
										}
									};

									for (const runtimeModule of chunkGraph.getChunkRuntimeModulesInOrder(
										chunk
									)) {
										__webpack_require_module__(
											moduleArgumentsMap.get(runtimeModule)
										);
									}
									exports = __webpack_require__(module.identifier());
								} catch (e) {
									const err = new WebpackError(
										`Execution of module code from module graph (${module.readableIdentifier(
											this.requestShortener
										)}) failed: ${e.message}`
									);
									err.stack = e.stack;
									err.module = e.module;
									return callback(err);
								}

								callback(null, {
									exports,
									assets,
									cacheable,
									fileDependencies,
									contextDependencies,
									missingDependencies,
									buildDependencies
								});
							}
						);
					});
				});
			}
		);
	}

	checkConstraints() {
		const chunkGraph = this.chunkGraph;

		/** @type {Set<number|string>} */
		const usedIds = new Set();

		for (const module of this.modules) {
			if (module.type === "runtime") continue;
			const moduleId = chunkGraph.getModuleId(module);
			if (moduleId === null) continue;
			if (usedIds.has(moduleId)) {
				throw new Error(`checkConstraints: duplicate module id ${moduleId}`);
			}
			usedIds.add(moduleId);
		}

		for (const chunk of this.chunks) {
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!this.modules.has(module)) {
					throw new Error(
						"checkConstraints: module in chunk but not in compilation " +
							` ${chunk.debugId} ${module.debugId}`
					);
				}
			}
			for (const module of chunkGraph.getChunkEntryModulesIterable(chunk)) {
				if (!this.modules.has(module)) {
					throw new Error(
						"checkConstraints: entry module in chunk but not in compilation " +
							` ${chunk.debugId} ${module.debugId}`
					);
				}
			}
		}

		for (const chunkGroup of this.chunkGroups) {
			chunkGroup.checkConstraints();
		}
	}
}

/**
 * @typedef {Object} FactorizeModuleOptions
 * @property {ModuleProfile} currentProfile
 * @property {ModuleFactory} factory
 * @property {Dependency[]} dependencies
 * @property {boolean=} factoryResult return full ModuleFactoryResult instead of only module
 * @property {Module | null} originModule
 * @property {Partial<ModuleFactoryCreateDataContextInfo>=} contextInfo
 * @property {string=} context
 */

/**
 * @param {FactorizeModuleOptions} options options object
 * @param {ModuleCallback | ModuleFactoryResultCallback} callback callback
 * @returns {void}
 */

// Workaround for typescript as it doesn't support function overloading in jsdoc within a class
Compilation.prototype.factorizeModule = /** @type {{
	(options: FactorizeModuleOptions & { factoryResult?: false }, callback: ModuleCallback): void;
	(options: FactorizeModuleOptions & { factoryResult: true }, callback: ModuleFactoryResultCallback): void;
}} */ (
	function (options, callback) {
		this.factorizeQueue.add(options, callback);
	}
);

// Hide from typescript
const compilationPrototype = Compilation.prototype;

// TODO webpack 6 remove
Object.defineProperty(compilationPrototype, "modifyHash", {
	writable: false,
	enumerable: false,
	configurable: false,
	value: () => {
		throw new Error(
			"Compilation.modifyHash was removed in favor of Compilation.hooks.fullHash"
		);
	}
});

// TODO webpack 6 remove
Object.defineProperty(compilationPrototype, "cache", {
	enumerable: false,
	configurable: false,
	get: util.deprecate(
		/**
		 * @this {Compilation} the compilation
		 * @returns {Cache} the cache
		 */
		function () {
			return this.compiler.cache;
		},
		"Compilation.cache was removed in favor of Compilation.getCache()",
		"DEP_WEBPACK_COMPILATION_CACHE"
	),
	set: util.deprecate(
		v => {},
		"Compilation.cache was removed in favor of Compilation.getCache()",
		"DEP_WEBPACK_COMPILATION_CACHE"
	)
});

/**
 * Add additional assets to the compilation.
 */
Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL = -2000;

/**
 * Basic preprocessing of assets.
 */
Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS = -1000;

/**
 * Derive new assets from existing assets.
 * Existing assets should not be treated as complete.
 */
Compilation.PROCESS_ASSETS_STAGE_DERIVED = -200;

/**
 * Add additional sections to existing assets, like a banner or initialization code.
 */
Compilation.PROCESS_ASSETS_STAGE_ADDITIONS = -100;

/**
 * Optimize existing assets in a general way.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE = 100;

/**
 * Optimize the count of existing assets, e. g. by merging them.
 * Only assets of the same type should be merged.
 * For assets of different types see PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT = 200;

/**
 * Optimize the compatibility of existing assets, e. g. add polyfills or vendor-prefixes.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY = 300;

/**
 * Optimize the size of existing assets, e. g. by minimizing or omitting whitespace.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE = 400;

/**
 * Add development tooling to assets, e. g. by extracting a SourceMap.
 */
Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING = 500;

/**
 * Optimize the count of existing assets, e. g. by inlining assets of into other assets.
 * Only assets of different types should be inlined.
 * For assets of the same type see PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE = 700;

/**
 * Summarize the list of existing assets
 * e. g. creating an assets manifest of Service Workers.
 */
Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE = 1000;

/**
 * Optimize the hashes of the assets, e. g. by generating real hashes of the asset content.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH = 2500;

/**
 * Optimize the transfer of existing assets, e. g. by preparing a compressed (gzip) file as separate asset.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER = 3000;

/**
 * Analyse existing assets.
 */
Compilation.PROCESS_ASSETS_STAGE_ANALYSE = 4000;

/**
 * Creating assets for reporting purposes.
 */
Compilation.PROCESS_ASSETS_STAGE_REPORT = 5000;

module.exports = Compilation;
