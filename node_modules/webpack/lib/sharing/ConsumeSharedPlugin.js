his._async_environment$_variableNodes,r=0;r<e.length;++r)for(n=e[r],s=t[r],a=(a=n.get$entries(n)).get$iterator(a);a.moveNext$0();)o=(i=a.get$current(a)).key,i=i.value,(B=s.$index(0,o)).toString,l.$indexSet(0,o,new E.ConfiguredValue(i,null,B));return new E.Configuration(l,null)},toModule$2(e,t){return E._EnvironmentModule__EnvironmentModule0(this,e,t,E.NullableExtension_andThen(this._async_environment$_forwardedModules,new E.AsyncEnvironment_toModule_closure))},toDummyModule$0(){return E._EnvironmentModule__EnvironmentModule0(this,new E.CssStylesheet(new E.UnmodifiableListView(I.List_empty3,D.UnmodifiableListView_CssNode),E.SourceFile$decoded(I.List_empty4,"<dummy module>").span$1(0,0)),I.C_EmptyExtensionStore,E.NullableExtension_andThen(this._async_environment$_forwardedModules,new E.AsyncEnvironment_toDummyModule_closure))},_async_environment$_getModule$1(e){var t=this._async_environment$_modules.$index(0,e);if(null!=t)return t;throw E.wrapException(E.SassScriptException$('There is no module with the namespace "'+e+'".',null))},_async_environment$_fromOneModule$1$3(e,t,r,n){var s,a,i,o,B,l,u,_,c,C,p=this._async_environment$_nestedForwardedModules;if(null!=p)for(s=new E.ReversedListIterable(p,E._arrayInstanceType(p)._eval$1("ReversedListIterable<1>")),s=new E.ListIterator(s,s.get$length(s)),a=E._instanceType(s)._precomputed1;s.moveNext$0();)for(i=s.__internal$_current,i=A.get$reversed$ax(null==i?a._as(i):i),i=new E.ListIterator(i,i.get$length(i)),o=E._instanceType(i)._precomputed1;i.moveNext$0();)if(B=i.__internal$_current,null!=(l=r.call$1(null==B?o._as(B):B)))return l;for(s=this._async_environment$_importedModules,s=E.LinkedHashMapKeyIterator$(s,s._modifications);s.moveNext$0();)if(null!=(l=r.call$1(s.__js_helper$_current)))return l;for(s=this._async_environment$_globalModules,a=E.LinkedHashMapKeyIterator$(s,s._modifications),i=D.AsyncCallable,l=null,u=null;a.moveNext$0();)if(o=a.__js_helper$_current,null!=(_=r.call$1(o))&&!(c=i._is(_)?_:o.variableIdentity$1(e)).$eq(0,u)){if(null!=l){for(C=s.get$entries(s).map$1$1(0,new E.AsyncEnvironment__fromOneModule_closure(r,n),D.nullable_FileSpan),a=E.LinkedHashMap_LinkedHashMap$_empty(D.FileSpan,D.String),s=C.get$iterator(C),i="includes "+t;s.moveNext$0();)null!=(o=s.get$current(s))&&a.$indexSet(0,o,i);throw E.wrapException(E.MultiSpanSassScriptException$("This "+t+T.x20is_av,t+" use",a))}u=c,l=_}return l}},E.AsyncEnvironment_importForwards_closure.prototype={call$1(e){var t=e.get$variables();return t.get$keys(t)},$signature:125},E.AsyncEnvironment_importForwards_closure0.prototype={call$1(e){var t=e.get$functions(e);return t.get$keys(t)},$signature:125},E.AsyncEnvironment_importForwards_closure1.prototype={call$1(e){var t=e.get$mixins();return t.get$keys(t)},$signature:125},E.AsyncEnvironment__getVariableFromGlobalModule_closure.prototype={call$1(e){return e.get$variables().$index(0,this.name)},$signature:574},E.AsyncEnvironment_setVariable_closure.prototype={call$0(){var e=this.$this;return e._async_environment$_lastVariableName=this.name,e._async_environment$_lastVariableIndex=0},$signature:12},E.AsyncEnvironment_setVariable_closure0.prototype={call$1(e){return e.get$variables().containsKey$1(this.name)?e:null},$signature:560},E.AsyncEnvironment_setVariable_closure1.prototype={call$0(){var e=this.$this,t=e._async_environment$_variableIndex$1(this.name);return null==t?e._async_environment$_variables.length-1:t},$signature:12},E.AsyncEnvironment__getFunctionFromGlobalModule_closure.prototype={call$1(e){return e.get$functions(e).$index(0,this.name)},$signature:254},E.AsyncEnvironment__getMixinFromGlobalModule_closure.prototype={call$1(e){return e.get$mixins().$index(0,this.name)},$signature:254},E.AsyncEnvironment_toModule_closure.prototype={call$1:e=>new E.MapKeySet(e,D.MapKeySet_Module_AsyncCallable),$signature:248},E.AsyncEnvironment_toDummyModule_closure.prototype={call$1:e=>new E.MapKeySet(e,D.MapKeySet_Module_AsyncCallable),$signature:248},E.AsyncEnvironment__fromOneModule_closure.prototype={call$1(e){return E.NullableExtension_andThen(this.callback.call$1(e.key),new E.Asyefixed }) => {
						resolvedConsumes = resolved;
						unresolvedConsumes = unresolved;
						prefixedConsumes = prefixed;
					}
				);

				const resolver = compilation.resolverFactory.get(
					"normal",
					RESOLVE_OPTIONS
				);

				/**
				 * @param {string} context issuer directory
				 * @param {string} request request
				 * @param {ConsumeOptions} config options
				 * @returns {Promise<ConsumeSharedModule>} create module
				 */
				const createConsumeSharedModule = (context, request, config) => {
					const requiredVersionWarning = details => {
						const error = new WebpackError(
							`No required version specified and unable to automatically determine one. ${details}`
						);
						error.file = `shared module ${request}`;
						compilation.warnings.push(error);
					};
					const directFallback =
						config.import &&
						/^(\.\.?(\/|$)|\/|[A-Za-z]:|\\\\)/.test(config.import);
					return Promise.all([
						new Promise(resolve => {
							if (!config.import) return resolve();
							const resolveContext = {
								/** @type {LazySet<string>} */
								fileDependencies: new LazySet(),
								/** @type {LazySet<string>} */
								contextDependencies: new LazySet(),
								/** @type {LazySet<string>} */
								missingDependencies: new LazySet()
							};
							resolver.resolve(
								{},
								directFallback ? compiler.context : context,
								config.import,
								resolveContext,
								(err, result) => {
									compilation.contextDependencies.addAll(
										resolveContext.contextDependencies
									);
									compilation.fileDependencies.addAll(
										resolveContext.fileDependencies
									);
									compilation.missingDependencies.addAll(
										resolveContext.missingDependencies
									);
									if (err) {
										compilation.errors.push(
											new ModuleNotFoundError(null, err, {
												name: `resolving fallback for shared module ${request}`
											})
										);
										return resolve();
									}
									resolve(result);
								}
							);
						}),
						new Promise(resolve => {
							if (config.requiredVersion !== undefined)
								return resolve(config.requiredVersion);
							let packageName = config.packageName;
							if (packageName === undefined) {
								if (/^(\/|[A-Za-z]:|\\\\)/.test(request)) {
									// For relative or absolute requests we don't automatically use a packageName.
									// If wished one can specify one with the packageName option.
									return resolve();
								}
								const match = /^((?:@[^\\/]+[\\/])?[^\\/]+)/.exec(request);
								if (!match) {
									requiredVersionWarning(
										"Unable to extract the package name from request."
									);
									return resolve();
								}
								packageName = match[0];
							}

							getDescriptionFile(
								compilation.inputFileSystem,
								context,
								["package.json"],
								(err, result) => {
									if (err) {
										requiredVersionWarning(
											`Unable to read description file: ${err}`
										);
										return resolve();
									}
									const { data, path: descriptionPath } = result;
									if (!data) {
										requiredVersionWarning(
											`Unable to find description file in ${context}.`
										);
										return resolve();
									}
									if (data.name === packageName) {
										// Package self-referencing
										return resolve();
									}
									const requiredVersion = getRequiredVersionFromDescriptionFile(
										data,
										packageName
									);
									if (typeof requiredVersion !== "string") {
										requiredVersionWarning(
											`Unable to find required version for "${packageName}" in description file (${descriptionPath}). It need to be in dependencies, devDependencies or peerDependencies.`
										);
										return resolve();
									}
									resolve(parseRange(requiredVersion));
								}
							);
						})
					]).then(([importResolved, requiredVersion]) => {
						return new ConsumeSharedModule(
							directFallback ? compiler.context : context,
							{
								...config,
								importResolved,
								import: importResolved ? config.import : undefined,
								requiredVersion
							}
						);
					});
				};

				normalModuleFactory.hooks.factorize.tapPromise(
					PLUGIN_NAME,
					({ context, request, dependencies }) =>
						// wait for resolving to be complete
						promise.then(() => {
							if (
								dependencies[0] instanceof ConsumeSharedFallbackDependency ||
								dependencies[0] instanceof ProvideForSharedDependency
							) {
								return;
							}
							const match = unresolvedConsumes.get(request);
							if (match !== undefined) {
								return createConsumeSharedModule(context, request, match);
							}
							for (const [prefix, options] of prefixedConsumes) {
								if (request.startsWith(prefix)) {
									const remainder = request.slice(prefix.length);
									return createConsumeSharedModule(context, request, {
										...options,
										import: options.import
											? options.import + remainder
											: undefined,
										shareKey: options.shareKey + remainder
									});
								}
							}
						})
				);
				normalModuleFactory.hooks.createModule.tapPromise(
					PLUGIN_NAME,
					({ resource }, { context, dependencies }) => {
						if (
							dependencies[0] instanceof ConsumeSharedFallbackDependency ||
							dependencies[0] instanceof ProvideForSharedDependency
						) {
							return Promise.resolve();
						}
						const options = resolvedConsumes.get(resource);
						if (options !== undefined) {
							return createConsumeSharedModule(context, resource, options);
						}
						return Promise.resolve();
					}
				);
				compilation.hooks.additionalTreeRuntimeRequirements.tap(
					PLUGIN_NAME,
					(chunk, set) => {
						set.add(RuntimeGlobals.module);
						set.add(RuntimeGlobals.moduleCache);
						set.add(RuntimeGlobals.moduleFactoriesAddOnly);
						set.add(RuntimeGlobals.shareScopeMap);
						set.add(RuntimeGlobals.initializeSharing);
						set.add(RuntimeGlobals.hasOwnProperty);
						compilation.addRuntimeModule(
							chunk,
							new ConsumeSharedRuntimeModule(set)
						);
					}
				);
			}
		);
	}
}

module.exports = ConsumeSharedPlugin;
