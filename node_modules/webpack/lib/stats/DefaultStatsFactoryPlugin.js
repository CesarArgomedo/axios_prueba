/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const util = require("util");
const ModuleDependency = require("../dependencies/ModuleDependency");
const formatLocation = require("../formatLocation");
const { LogType } = require("../logging/Logger");
const AggressiveSplittingPlugin = require("../optimize/AggressiveSplittingPlugin");
const SizeLimitsPlugin = require("../performance/SizeLimitsPlugin");
const { countIterable } = require("../util/IterableHelpers");
const {
	compareLocations,
	compareChunksById,
	compareNumbers,
	compareIds,
	concatComparators,
	compareSelect,
	compareModulesByIdentifier
} = require("../util/comparators");
const { makePathsRelative, parseResource } = require("../util/identifier");

/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGroup")} ChunkGroup */
/** @typedef {import("../ChunkGroup").OriginRecord} OriginRecord */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../Compilation").Asset} Asset */
/** @typedef {import("../Compilation").AssetInfo} AssetInfo */
/** @typedef {import("../Compilation").NormalizedStatsOptions} NormalizedStatsOptions */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../ModuleGraphConnection")} ModuleGraphConnection */
/** @typedef {import("../ModuleProfile")} ModuleProfile */
/** @typedef {import("../RequestShortener")} RequestShortener */
/** @typedef {import("../WebpackError")} WebpackError */
/** @template T @typedef {import("../util/comparators").Comparator<T>} Comparator<T> */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
/** @typedef {import("../util/smartGrouping").GroupConfig<any, object>} GroupConfig */
/** @typedef {import("./StatsFactory")} StatsFactory */
/** @typedef {import("./StatsFactory").StatsFactoryContext} StatsFactoryContext */

/** @typedef {KnownStatsCompilation & Record<string, any>} StatsCompilation */
/**
 * @typedef {Object} KnownStatsCompilation
 * @property {any=} env
 * @property {string=} name
 * @property {string=} hash
 * @property {string=} version
 * @property {number=} time
 * @property {number=} builtAt
 * @property {boolean=} needAdditionalPass
 * @property {string=} publicPath
 * @property {string=} outputPath
 * @property {Record<string, string[]>=} assetsByChunkName
 * @property {StatsAsset[]=} assets
 * @property {number=} filteredAssets
 * @property {StatsChunk[]=} chunks
 * @property {StatsModule[]=} modules
 * @property {number=} filteredModules
 * @property {Record<string, StatsChunkGroup>=} entrypoints
 * @property {Record<string, StatsChunkGroup>=} namedChunkGroups
 * @property {StatsError[]=} errors
 * @property {number=} errorsCount
 * @property {StatsError[]=} warnings
 * @property {number=} warningsCount
 * @property {StatsCompilation[]=} children
 * @property {Record<string, StatsLogging>=} logging
 */

/** @typedef {KnownStatsLogging & Record<string, any>} StatsLogging */
/**
 * @typedef {Object} KnownStatsLogging
 * @property {StatsLoggingEntry[]} entries
 * @property {number} filteredEntries
 * @property {boolean} debug
 */

/** @typedef {KnownStatsLoggingEntry & Record<string, any>} StatsLoggingEntry */
/**
 * @typedef {Object} KnownStatsLoggingEntry
 * @property {string} type
 * @property {string} message
 * @property {string[]=} trace
 * @property {StatsLoggingEntry[]=} children
 * @property {any[]=} args
 * @property {number=} time
 */

/** @typedef {KnownStatsAsset & Record<string, any>} StatsAsset */
/**
 * @typedef {Object} KnownStatsAsset
 * @property {string} type
 * @property {string} name
 * @property {AssetInfo} info
 * @property {number} size
 * @property {boolean} emitted
 * @property {boolean} comparedForEmit
 * @property {boolean} cached
 * @property {StatsAsset[]=} related
 * @property {(string|number)[]=} chunkNames
 * @property {(string|number)[]=} chunkIdHints
 * @property {(string|number)[]=} chunks
 * @property {(string|number)[]=} auxiliaryChunkNames
 * @property {(string|number)[]=} auxiliaryChunks
 * @property {(string|number)[]=} auxiliaryChunkIdHints
 * @property {number=} filteredRelated
 * @property {boolean=} isOverSizeLimit
 */

/** @typedef {KnownStatsChunkGroup & Record<string, any>} StatsChunkGroup */
/**
 * @typedef {Object} KnownStatsChunkGroup
 * @property {string=} name
 * @property {(string|number)[]=} chunks
 * @property {({ name: string, size?: number })[]=} assets
 * @property {number=} filteredAssets
 * @property {number=} assetsSize
 * @property {({ name: string, size?: number })[]=} auxiliaryAssets
 * @property {number=} filteredAuxiliaryAssets
 * @property {number=} auxiliaryAssetsSize
 * @property {{ [x: string]: StatsChunkGroup[] }=} children
 * @property {{ [x: string]: string[] }=} childAssets
 * @property {boolean=} isOverSizeLimit
 */

/** @typedef {KnownStatsModule & Record<string, any>} StatsModule */
/**
 * @typedef {Object} KnownStatsModule
 * @property {string=} type
 * @property {string=} moduleType
 * @property {string=} layer
 * @property {string=} identifier
 * @property {string=} name
 * @property {string=} nameForCondition
 * @property {number=} index
 * @property {number=} preOrderIndex
 * @property {number=} index2
 * @property {number=} postOrderIndex
 * @property {number=} size
 * @property {{[x: string]: number}=} sizes
 * @property {boolean=} cacheable
 * @property {boolean=} built
 * @property {boolean=} codeGenerated
 * @property {boolean=} buildTimeExecuted
 * @property {boolean=} cached
 * @property {boolean=} optional
 * @property {boolean=} orphan
 * @property {string|number=} id
 * @property {string|number=} issuerId
 * @property {(string|number)[]=} chunks
 * @property {(string|number)[]=} assets
 * @property {boolean=} dependent
 * @property {string=} issuer
 * @property {string=} issuerName
 * @property {StatsModuleIssuer[]=} issuerPath
 * @property {boolean=} failed
 * @property {number=} errors
 * @property {number=} warnings
 * @property {StatsProfile=} profile
 * @property {StatsModuleReason[]=} reasons
 * @property {(boolean | string[])=} usedExports
 * @property {string[]=} providedExports
 * @property {string[]=} optimizationBailout
 * @property {number=} depth
 * @property {StatsModule[]=} modules
 * @property {number=} filteredModules
 * @property {ReturnType<Source["source"]>=} source
 */

/** @typedef {KnownStatsProfile & Record<string, any>} StatsProfile */
/**
 * @typedef {Object} KnownStatsProfile
 * @property {number} total
 * @property {number} resolving
 * @property {number} restoring
 * @property {number} building
 * @property {number} integration
 * @property {number} storing
 * @property {number} additionalResolving
 * @property {number} additionalIntegration
 * @property {number} factory
 * @property {number} dependencies
 */

/** @typedef {KnownStatsModuleIssuer & Record<string, any>} StatsModuleIssuer */
/**
 * @typedef {Object} KnownStatsModuleIssuer
 * @property {string=} identifier
 * @property {string=} name
 * @property {(string|number)=} id
 * @property {StatsProfile=} profile
 */

/** @typedef {KnownStatsModuleReason & Record<string, any>} StatsModuleReason */
/**
 * @typedef {Object} KnownStatsModuleReason
 * @property {string=} moduleIdentifier
 * @property {string=} module
 * @property {string=} moduleName
 * @property {string=} resolvedModuleIdentifier
 * @property {string=} resolvedModule
 * @property {string=} type
 * @property {boolean} active
 * @property {string=} explanation
 * @property {string=} userRequest
 * @property {string=} loc
 * @property {(string|number)=} moduleId
 * @property {(string|number)=} resolvedModuleId
 */

/** @typedef {KnownStatsChunk & Record<string, any>} StatsChunk */
/**
 * @typedef {Object} KnownStatsChunk
 * @property {boolean} rendered
 * @property {boolean} initial
 * @property {boolean} entry
 * @property {boolean} recorded
 * @property {string=} reason
 * @property {number} size
 * @property {Record<string, number>=} sizes
 * @property {string[]=} names
 * @property {string[]=} idHints
 * @property {string[]=} runtime
 * @property {string[]=} files
 * @property {string[]=} auxiliaryFiles
 * @property {string} hash
 * @property {Record<string, (string|number)[]>=} childrenByOrder
 * @property {(string|number)=} id
 * @property {(string|number)[]=} siblings
 * @property {(string|number)[]=} parents
 * @property {(string|number)[]=} children
 * @property {StatsModule[]=} modules
 * @property {number=} filteredModules
 * @property {StatsChunkOrigin[]=} origins
 */

/** @typedef {KnownStatsChunkOrigin & Record<string, any>} StatsChunkOrigin */
/**
 * @typedef {Object} KnownStatsChunkOrigin
 * @property {string=} module
 * @property {string=} moduleIdentifier
 * @property {string=} moduleName
 * @property {string=} loc
 * @property {string=} request
 * @property {(string|number)=} moduleId
 */

/** @typedef {KnownStatsModuleTraceItem & Record<string, any>} StatsModuleTraceItem */
/**
 * @typedef {Object} KnownStatsModuleTraceItem
 * @property {string=} originIdentifier
 * @property {string=} originName
 * @property {string=} moduleIdentifier
 * @property {string=} moduleName
 * @property {StatsModuleTraceDependency[]=} dependencies
 * @property {(string|number)=} originId
 * @property {(string|number)=} moduleId
 */

/** @typedef {KnownStatsModuleTraceDependency & Record<string, any>} StatsModuleTraceDependency */
/**
 * @typedef {Object} KnownStatsModuleTraceDependency
 * @property {string=} loc
 */

/** @typedef {KnownStatsError & Record<string, any>} StatsError */
/**
 * @typedef {Object} KnownStatsError
 * @property {string} message
 * @property {string=} chunkName
 * @property {boolean=} chunkEntry
 * @property {boolean=} chunkInitial
 * @property {string=} file
 * @property {string=} moduleIdentifier
 * @property {string=} moduleName
 * @property {string=} loc
 * @property {string|number=} chunkId
 * @property {string|number=} moduleId
 * @property {StatsModuleTraceItem[]=} moduleTrace
 * @property {any=} details
 * @property {string=} stack
 */

/** @typedef {Asset & { type: string, related: PreprocessedAsset[] }} PreprocessedAsset */

/**
 * @template T
 * @template O
 * @typedef {Record<string, (object: O, data: T, context: StatsFactoryContext, options: NormalizedStatsOptions, factory: StatsFactory) => void>} ExtractorsByOption
 */

/**
 * @typedef {Object} SimpleExtractors
 * @property {ExtractorsByOption<Compilation, StatsCompilation>} compilation
 * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset
 * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset$visible
 * @property {ExtractorsByOption<{ name: string, chunkGroup: ChunkGroup }, StatsChunkGroup>} chunkGroup
 * @property {ExtractorsByOption<Module, StatsModule>} module
 * @property {ExtractorsByOption<Module, StatsModule>} module$visible
 * @property {ExtractorsByOption<Module, StatsModuleIssuer>} moduleIssuer
 * @property {ExtractorsByOption<ModuleProfile, StatsProfile>} profile
 * @property {ExtractorsByOption<ModuleGraphConnection, StatsModuleReason>} moduleReason
 * @property {ExtractorsByOption<Chunk, StatsChunk>} chunk
 * @property {ExtractorsByOption<OriginRecord, StatsChunkOrigin>} chunkOrigin
 * @property {ExtractorsByOption<WebpackError, StatsError>} error
 * @property {ExtractorsByOption<WebpackError, StatsError>} warning
 * @property {ExtractorsByOption<{ origin: Module, module: Module }, StatsModuleTraceItem>} moduleTraceItem
 * @property {ExtractorsByOption<Dependency, StatsModuleTraceDependency>} moduleTraceDependency
 */

/**
 * @template T
 * @template I
 * @param {Iterable<T>} items items to select from
 * @param {function(T): Iterable<I>} selector selector function to select values from item
 * @returns {I[]} array of values
 */
const uniqueArray = (items, selector) => {
	/** @type {Set<I>} */
	const set = new Set();
	for (const item of items) {
		for (const i of selector(item)) {
			set.add(i);
		}
	}
	return Array.from(set);
};

/**
 * @template T
 * @template I
 * @param {Iterable<T>} items items to select from
 * @param {function(T): Iterable<I>} selector selector function to select values from item
 * @param {Comparator<I>} comparator comparator function
 * @returns {I[]} array of values
 */
const uniqueOrderedArray = (items, selector, comparator) => {
	return uniqueArray(items, selector).sort(comparator);
};

/** @template T @template R @typedef {{ [P in keyof T]: R }} MappedValues<T, R> */

/**
 * @template T
 * @template R
 * @param {T} obj object to be mapped
 * @param {function(T[keyof T], keyof T): R} fn mapping function
 * @returns {MappedValues<T, R>} mapped object
 */
const mapObject = (obj, fn) => {
	const newObj = Object.create(null);
	for (const key of Object.keys(obj)) {
		newObj[key] = fn(obj[key], /** @type {keyof T} */ (key));
	}
	return newObj;
};

/**
 * @param {Compilation} compilation the compilation
 * @param {function(Compilation, string): any[]} getItems get items
 * @returns {number} total number
 */
const countWithChildren = (compilation, getItems) => {
	let count = getItems(compilation, "").length;
	for (const child of compilation.children) {
		count += countWithChildren(child, (c, type) =>
			getItems(c, `.children[].compilation${type}`)
		);
	}
	return count;
};

/** @type {ExtractorsByOption<WebpackError | string, StatsError>} */
const EXTRACT_ERROR = {
	_: (object, error, context, { requestShortener }) => {
		// TODO webpack 6 disallow strings in the errors/warnings list
		if (typeof error === "string") {
			object.message = error;
		} else {
			if (error.chunk) {
				object.chunkName = error.chunk.name;
				object.chunkEntry = error.chunk.hasRuntime();
				object.chunkInitial = error.chunk.canBeInitial();
			}
			if (error.file) {
				object.file = error.file;
			}
			if (error.module) {
				object.moduleIdentifier = error.module.identifier();
				object.moduleName = error.module.readableIdentifier(requestShortener);
			}
			if (error.loc) {
				object.loc = formatLocation(error.loc);
			}
			object.message = error.message;
		}
	},
	ids: (object, error, { compilation: { chunkGraph } }) => {
		if (typeof error !== "string") {
			if (error.chunk) {
				object.chunkId = error.chunk.id;
			}
			if (error.module) {
				object.moduleId = chunkGraph.getModuleId(error.module);
			}
		}
	},
	moduleTrace: (object, error, context, options, factory) => {
		if (typeof error !== "string" && error.module) {
			const {
				type,
				compilation: { moduleGraph }
			} = context;
			/** @type {Set<Module>} */
			const visitedModules = new Set();
			const moduleTrace = [];
			let current = error.module;
			while (current) {
				if (visitedModules.has(current)) break; // circular (technically impossible, but how knows)
				visitedModules.add(current);
				const origin = moduleGraph.getIssuer(current);
				if (!origin) break;
				moduleTrace.push({ origin, module: current });
				current = origin;
			}
			object.moduleTrace = factory.create(
				`${type}.moduleTrace`,
				moduleTrace,
				context
			);
		}
	},
	errorDetails: (
		object,
		error,
		{ type, compilation, cachedGetErrors, cachedGetWarnings },
		{ errorDetails }
	) => {
		if (
			typeof error !== "string" &&
			(errorDetails === true ||
				(type.endsWith(".error") && cachedGetErrors(compilation).length < 3))
		) {
			object.details = error.details;
		}
	},
	errorStack: (object, error) => {
		if (typeof error !== "string") {
			object.stack = error.stack;
		}
	}
};

/** @type {SimpleExtractors} */
const SIMPLE_EXTRACTORS = {
	compilation: {
		_: (object, compilation, context, options) => {
			if (!context.makePathsRelative) {
				context.makePathsRelative = makePathsRelative.bindContextCache(
					compilation.compiler.context,
					compilation.compiler.root
				);
			}
			if (!context.cachedGetErrors) {
				const map = new WeakMap();
				context.cachedGetErrors = compilation => {
					return (
						map.get(compilation) ||
						(errors => (map.set(compilation, errors), errors))(
							compilation.getErrors()
						)
					);
				};
			}
			if (!context.cachedGetWarnings) {
				const map = new WeakMap();
				context.cachedGetWarnings = compilation => {
					return (
						map.get(compilation) ||
						(warnings => (map.set(compilation, warnings), warnings))(
							compilation.getWarnings()
						)
					);
				};
			}
			if (compilation.name) {
				object.name = compilation.name;
			}
			if (compilation.needAdditionalPass) {
				object.needAdditionalPass = true;
			}

			const { logging, loggingDebug, loggingTrace } = options;
			if (logging || (loggingDebug && loggingDebug.length > 0)) {
				const util = require("util");
				object.logging = {};
				let acceptedTypes;
				let collapsedGroups = false;
				switch (logging) {
					default:
						acceptedTypes = new Set();
						break;
					case "error":
						acceptedTypes = new Set([LogType.error]);
						break;
					case "warn":
						acceptedTypes = new Set([LogType.error, LogType.warn]);
						break;
					case "info":
						acceptedTypes = new Set([
							LogType.error,
							LogType.warn,
							LogType.info
						]);
						break;
					case "log":
						acceptedTypes = new Set([
							LogType.error,
							LogType.warn,
							LogType.info,
							LogType.log,
							LogType.group,
							LogType.groupEnd,
							LogType.groupCollapsed,
							LogType.clear
						]);
						break;
					case "verbose":
						acceptedTypes = new Set([
							LogType.error,
							LogType.warn,
							LogType.info,
							LogType.log,
							LogType.group,
							LogType.groupEnd,
							LogType.groupCollapsed,
							LogType.profile,
							LogType.profileEnd,
							LogType.time,
							LogType.status,
							LogType.clear
						]);
						collapsedGroups = true;
						break;
				}
				const cachedMakePathsRelative = makePathsRelative.bindContextCache(
					options.context,
					compilation.compiler.root
				);
				let depthInCollapsedGroup = 0;
				for (const [origin, logEntries] of compilation.logging) {
					const debugMode = loggingDebug.some(fn => fn(origin));
					if (logging === false && !debugMode) continue;
					/** @type {KnownStatsLoggingEntry[]} */
					const groupStack = [];
					/** @type {KnownStatsLoggingEntry[]} */
					const rootList = [];
					let currentList = rootList;
					let processedLogEntries = 0;
					for (const entry of logEntries) {
						let type = entry.type;
						if (!debugMode && !acceptedTypes.has(type)) continue;

						// Expand groups in verbose and debug modes
						if (
							type === LogType.groupCollapsed &&
							(debugMode || collapsedGroups)
						)
							type = LogType.group;

						if (depthInCollapsedGroup === 0) {
							processedLogEntries++;
						}

						if (type === LogType.groupEnd) {
							groupStack.pop();
							if (groupStack.length > 0) {
								currentList = groupStack[groupStack.length - 1].children;
							} else {
								currentList = rootList;
							}
							if (depthInCollapsedGroup > 0) depthInCollapsedGroup--;
							continue;
						}
						let message = undefined;
						if (entry.type === LogType.time) {
							message = `${entry.args[0]}: ${
								entry.args[1] * 1000 + entry.args[2] / 1000000
							} ms`;
						} else if (entry.args && entry.args.length > 0) {
							message = util.format(entry.args[0], ...entry.args.slice(1));
						}
						/** @type {KnownStatsLoggingEntry} */
						const newEntry = {
							...entry,
							type,
							message,
							trace: loggingTrace ? entry.trace : undefined,
							children:
								type === LogType.group || type === LogType.groupCollapsed
									? []
									: undefined
						};
						currentList.push(newEntry);
						if (newEntry.children) {
							groupStack.push(newEntry);
							currentList = newEntry.children;
							if (depthInCollapsedGroup > 0) {
								depthInCollapsedGroup++;
							} else if (type === LogType.groupCollapsed) {
								depthInCollapsedGroup = 1;
							}
						}
					}
					let name = cachedMakePathsRelative(origin).replace(/\|/g, " ");
					if (name in object.logging) {
						let i = 1;
						while (`${name}#${i}` in object.logging) {
							i++;
						}
						name = `${name}#${i}`;
					}
					object.logging[name] = {
						entries: rootList,
						filteredEntries: logEntries.length - processedLogEntries,
						debug: debugMode
					};
				}
			}
		},
		hash: (object, compilation) => {
			object.hash = compilation.hash;
		},
		version: object => {
			object.version = require("../../package.json").version;
		},
		env: (object, compilation, context, { _env }) => {
			object.env = _env;
		},
		timings: (object, compilation) => {
			object.time = compilation.endTime - compilation.startTime;
		},
		builtAt: (object, compilation) => {
			object.builtAt = compilation.endTime;
		},
		publicPath: (object, compilation) => {
			object.publicPath = compilation.getPath(
				compilation.outputOptions.publicPath
			);
		},
		outputPath: (object, compilation) => {
			object.outputPath = compilation.outputOptions.path;
		},
		assets: (object, compilation, context, options, factory) => {
			const { type } = context;
			/** @type {Map<string, Chunk[]>} */
			const compilationFileToChunks = new Map();
			/** @type {Map<string, Chunk[]>} */
			const compilationAuxiliaryFileToChunks = new Map();
			for (const chunk of compilation.chunks) {
				for (const file of chunk.files) {
					let array = compilationFileToChunks.get(file);
					if (array === undefined) {
						array = [];
						compilationFileToChunks.set(file, array);
					}
					array.push(chunk);
				}
				for (const file of chunk.auxiliaryFiles) {
					let array = compilationAuxiliaryFileToChunks.get(file);
					if (array === undefined) {
						array = [];
						compilationAuxiliaryFileToChunks.set(file, array);
					}
					array.push(chunk);
				}
			}
			/** @type {Map<string, PreprocessedAsset>} */
			const assetMap = new Map();
			/** @type {Set<PreprocessedAsset>} */
			const assets = new Set();
			for (const asset of compilation.getAssets()) {
				/** @type {PreprocessedAsset} */
				const item = {
					...asset,
					type: "asset",
					related: undefined
				};
				assets.add(item);
				assetMap.set(asset.name, item);
			}
			for (const item of assetMap.values()) {
				const related = item.info.related;
				if (!related) continue;
				for (const type of Object.keys(related)) {
					const relatedEntry = related[type];
					const deps = Array.isArray(relatedEntry)
						? relatedEntry
						: [relatedEntry];
					for (const dep of deps) {
						const depItem = assetMap.get(dep);
						if (!depItem) continue;
						assets.delete(depItem);
						depItem.type = type;
						item.related = item.related || [];
						item.related.push(depItem);
					}
				}
			}

			object.assetsByChunkName = {};
			for (const [file, chunks] of compilationFileToChunks) {
				for (const chunk of chunks) {
					const name = chunk.name;
					if (!name) continue;
					if (
						!Object.prototype.hasOwnProperty.call(
							object.assetsByChunkName,
							name
						)
					) {
						object.assetsByChunkName[name] = [];
					}
					object.assetsByChunkName[name].push(file);
				}
			}

			const groupedAssets = factory.create(
				`${type}.assets`,
				Array.from(assets),
				{
					...context,
					compilationFileToChunks,
					compilationAuxiliaryFileToChunks
				}
			);
			const limited = spaceLimited(groupedAssets, options.assetsSpace);
			object.assets = limited.children;
			object.filteredAssets = limited.filteredChildren;
		},
		chunks: (object, compilation, context, options, factory) => {
			const { type } = context;
			object.chunks = factory.create(
				`${type}.chunks`,
				Array.from(compilation.chunks),
				context
			);
		},
		modules: (object, compilation, context, options, factory) => {
			const { type } = context;
			const array = Array.from(compilation.modules);
			const groupedModules = factory.create(`${type}.modules`, array, context);
			const limited = spaceLimited(groupedModules, options.modulesSpace);
			object.modules = limited.children;
			object.filteredModules = limited.filteredChildren;
		},
		entrypoints: (
			object,
			compilation,
			context,
			{ entrypoints, chunkGroups, chunkGroupAuxiliary, chunkGroupChildren },
			factory
		) => {
			const { type } = context;
			const array = Array.from(compilation.entrypoints, ([key, value]) => ({
				name: key,
				chunkGroup: value
			}));
			if (entrypoints === "auto" && !chunkGroups) {
				if (array.length > 5) return;
				if (
					!chunkGroupChildren &&
					array.every(({ chunkGroup }) => {
						if (chunkGroup.chunks.length !== 1) return false;
						const chunk = chunkGroup.chunks[0];
						return (
							chunk.files.size === 1 &&
							(!chunkGroupAuxiliary || chunk.auxiliaryFiles.size === 0)
						);
					})
				) {
					return;
				}
			}
			object.entrypoints = factory.create(
				`${type}.entrypoints`,
				array,
				context
			);
		},
		chunkGroups: (object, compilation, context, options, factory) => {
			const { type } = context;
			const array = Array.from(
				compilation.namedChunkGroups,
				([key, value]) => ({
					name: key,
					chunkGroup: value
				})
			);
			object.namedChunkGroups = factory.create(
				`${type}.namedChunkGroups`,
				array,
				context
			);
		},
		errors: (object, compilation, context, options, factory) => {
			const { type, cachedGetErrors } = context;
			const rawErrors = cachedGetErrors(compilation);
			const factorizedErrors = factory.create(
				`${type}.errors`,
				cachedGetErrors(compilation),
				context
			);
			let filtered = 0;
			if (options.errorDetails === "auto" && rawErrors.length >= 3) {
				filtered = rawErrors
					.map(e => typeof e !== "string" && e.details)
					.filter(Boolean).length;
			}
			if (
				options.errorDetails === true ||
				!Number.isFinite(options.errorsSpace)
			) {
				object.errors = factorizedErrors;
				if (filtered) object.filteredErrorDetailsCount = filtered;
				return;
			}
			const [errors, filteredBySpace] = errorsSpaceLimit(
				factorizedErrors,
				options.errorsSpace
			);
			object.filteredErrorDetailsCount = filtered + filteredBySpace;
			object.errors = errors;
		},
		errorsCount: (object, compilation, { cachedGetErrors }) => {
			object.errorsCount = countWithChildren(compilation, c =>
				cachedGetErrors(c)
			);
		},
		warnings: (object, compilation, context, options, factory) => {
			const { type, cachedGetWarnings } = context;
			const rawWarnings = factory.create(
				`${type}.warnings`,
				cachedGetWarnings(compilation),
				context
			);
			let filtered = 0;
			if (options.errorDetails === "auto") {
				filtered = cachedGetWarnings(compilation)
					.map(e => typeof e !== "string" && e.details)
					.filter(Boolean).length;
			}
			if (
				options.errorDetails === true ||
				!Number.isFinite(options.warningsSpace)
			) {
				object.warnings = rawWarnings;
				if (filtered) object.filteredWarningDetailsCount = filtered;
				return;
			}
			const [warnings, filteredBySpace] = errorsSpaceLimit(
				rawWarnings,
				options.warningsSpace
			);
			object.filteredWarningDetailsCount = filtered + filteredBySpace;
			object.warnings = warnings;
		},
		warningsCount: (
			object,
			compilation,
			context,
			{ warningsFilter },
			factory
		) => {
			const { type, cachedGetWarnings } = context;
			object.warningsCount = countWithChildren(compilation, (c, childType) => {
				if (!warningsFilter && warningsFilter.length === 0)
					return cachedGetWarnings(c);
				return factory
					.create(`${type}${childType}.warnings`, cachedGetWarnings(c), context)
					.filter(warning => {
						const warningString = Object.keys(warning)
							.map(key => `${warning[key]}`)
							.join("\n");
						return !warningsFilter.some(filter =>
							filter(warning, warningString)
						);
					});
			});
		},
		children: (object, compilation, context, options, factory) => {
			const { type } = context;
			object.children = factory.create(
				`${type}.children`,
				compilation.children,
				context
			);
		}
	},
	asset: {
		_: (object, asset, context, options, factory) => {
			const { compilation } = context;
			object.type = asset.type;
			object.name = asset.name;
			object.size = asset.source.size();
			object.emitted = compilation.emittedAssets.has(asset.name);
			object.comparedForEmit = compilation.comparedForEmitAssets.has(
				asset.name
			);
			const cached = !object.emitted && !object.comparedForEmit;
			object.cached = cached;
			object.info = asset.info;
			if (!cached || options.cachedAssets) {
				Object.assign(
					object,
					factory.create(`${context.type}$visible`, asset, context)
				);
			}
		}
	},
	asset$visible: {
		_: (
			object,
			asset,
			{ compilation, compilationFileToChunks, compilationAuxiliaryFileToChunks }
		) => {
			const chunks = compilationFileToChunks.get(asset.name) || [];
			const auxiliaryChunks =
				compilationAuxiliaryFileToChunks.get(asset.name) || [];
			object.chunkNames = uniqueOrderedArray(
				chunks,
				c => (c.name ? [c.name] : []),
				compareIds
			);
			object.chunkIdHints = uniqueOrderedArray(
				chunks,
				c => Array.from(c.idNameHints),
				compareIds
			);
			object.auxiliaryChunkNames = uniqueOrderedArray(
				auxiliaryChunks,
				c => (c.name ? [c.name] : []),
				compareIds
			);
			object.auxiliaryChunkIdHints = uniqueOrderedArray(
				auxiliaryChunks,
				c => Array.from(c.idNameHints),
				compareIds
			);
			object.filteredRelated = asset.related ? asset.related.length : undefined;
		},
		relatedAssets: (object, asset, context, options, factory) => {
			const { type } = context;
			object.related = factory.create(
				`${type.slice(0, -8)}.related`,
				asset.related,
				context
			);
			object.filteredRelated = asset.related
				? asset.related.length - object.related.length
				: undefined;
		},
		ids: (
			object,
			asset,
			{ compilationFileToChunks, compilationAuxiliaryFileToChunks }
		) => {
			const chunks = compilationFileToChunks.get(asset.name) || [];
			const auxiliaryChunks =
				compilationAuxiliaryFileToChunks.get(asset.name) || [];
			object.chunks = uniqueOrderedArray(chunks, c => c.ids, compareIds);
			object.auxiliaryChunks = uniqueOrderedArray(
				auxiliaryChunks,
				c => c.ids,
				compareIds
			);
		},
		performance: (object, asset) => {
			object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(asset.source);
		}
	},
	chunkGroup: {
		_: (
			object,
			{ name, chunkGroup },
			{ compilation, compilation: { moduleGraph, chunkGraph } },
			{ ids, chunkGroupAuxiliary, chunkGroupChildren, chunkGroupMaxAssets }
		) => {
			const children =
				chunkGroupChildren &&
				chunkGroup.getChildrenByOrders(moduleGraph, chunkGraph);
			/**
			 * @param {string} name Name
			 * @returns {{ name: string, size: number }} Asset object
			 */
			const toAsset = name => {
				const asset = compilation.getAsset(name);
				return {
					name,
					size: asset ? asset.info.size : -1
				};
			};
			/** @type {(total: number, asset: { size: number }) => number} */
			const sizeReducer = (total, { size }) => total + size;
			const assets = uniqueArray(chunkGroup.chunks, c => c.files).map(toAsset);
			const auxiliaryAssets = uniqueOrderedArray(
				chunkGroup.chunks,
				c => c.auxiliaryFiles,
				compareIds
			).map(toAsset);
			const assetsSize = assets.reduce(sizeReducer, 0);
			const auxiliaryAssetsSize = auxiliaryAssets.reduce(sizeReducer, 0);
			/** @type {KnownStatsChunkGroup} */
			const statsChunkGroup = {
				name,
				chunks: ids ? chunkGroup.chunks.map(c => c.id) : undefined,
				assets: assets.length <= chunkGroupMaxAssets ? assets : undefined,
				filteredAssets:
					assets.length <= chunkGroupMaxAssets ? 0 : assets.length,
				assetsSize,
				auxiliaryAssets:
					chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets
						? auxiliaryAssets
						: undefined,
				filteredAuxiliaryAssets:
					chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets
						? 0
						: auxiliaryAssets.length,
				auxiliaryAssetsSize,
				children: children
					? mapObject(children, groups =>
							groups.map(group => {
								const assets = uniqueArray(group.chunks, c => c.files).map(
									toAsset
								);
								const auxiliaryAssets = uniqueOrderedArray(
									group.chunks,
									c => c.auxiliaryFiles,
									compareIds
								).map(toAsset);

								/** @type {KnownStatsChunkGroup} */
								const childStatsChunkGroup = {
									name: group.name,
									chunks: ids ? group.chunks.map(c => c.id) : undefined,
									assets:
										assets.length <= chunkGroupMaxAssets ? assets : undefined,
									filteredAssets:
										assets.length <= chunkGroupMaxAssets ? 0 : assets.length,
									auxiliaryAssets:
										chunkGroupAuxiliary &&
										auxiliaryAssets.length <= chunkGroupMaxAssets
											? auxiliaryAssets
											: undefined,
									filteredAuxiliaryAssets:
										chunkGroupAuxiliary &&
										auxiliaryAssets.length <= chunkGroupMaxAssets
											? 0
											: auxiliaryAssets.length
								};

								return childStatsChunkGroup;
							})
					  )
					: undefined,
				childAssets: children
					? mapObject(children, groups => {
							/** @type {Set<string>} */
							const set = new Set();
							for (const group of groups) {
								for (const chunk of group.chunks) {
									for (const asset of chunk.files) {
										set.add(asset);
									}
								}
							}
							return Array.from(set);
					  })
					: undefined
			};
			Object.assign(object, statsChunkGroup);
		},
		performance: (object, { chunkGroup }) => {
			object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(chunkGroup);
		}
	},
	module: {
		_: (object, module, context, options, factory) => {
			const { compilation, type } = context;
			const built = compilation.builtModules.has(module);
			const codeGenerated = compilation.codeGeneratedModules.has(module);
			const buildTimeExecuted =
				compilation.buildTimeExecutedModules.has(module);
			/** @type {{[x: string]: number}} */
			const sizes = {};
			for (const sourceType of module.getSourceTypes()) {
				sizes[sourceType] = module.size(sourceType);
			}
			/** @type {KnownStatsModule} */
			const statsModule = {
				type: "module",
				moduleType: module.type,
				layer: module.layer,
				size: module.size(),
				sizes,
				built,
				codeGenerated,
				buildTimeExecuted,
				cached: !built && !codeGenerated
			};
			Object.assign(object, statsModule);

			if (built || codeGenerated || options.cachedModules) {
				Object.assign(
					object,
					factory.create(`${type}$visible`, module, context)
				);
			}
		}
	},
	module$visible: {
		_: (object, module, context, { requestShortener }, factory) => {
			const { compilation, type, rootModules } = context;
			const { moduleGraph } = compilation;
			/** @type {Module[]} */
			const path = [];
			const issuer = moduleGraph.getIssuer(module);
			let current = issuer;
			while (current) {
				path.push(current);
				current = moduleGraph.getIssuer(current);
			}
			path.reverse();
			const profile = moduleGraph.getProfile(module);
			const errors = module.getErrors();
			const errorsCount = errors !== undefined ? countIterable(errors) : 0;
			const warnings = module.getWarnings();
			const warningsCount =
				warnings !== undefined ? countIterable(warnings) : 0;
			/** @type {{[x: string]: number}} */
			const sizes = {};
			for (const sourceType of module.getSourceTypes()) {
				sizes[sourceType] = module.size(sourceType);
			}
			/** @type {KnownStatsModule} */
			const statsModule = {
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener),
				nameForCondition: module.nameForCondition(),
				index: moduleGraph.getPreOrderIndex(module),
				preOrderIndex: moduleGraph.getPreOrderIndex(module),
				index2: moduleGraph.getPostOrderIndex(module),
				postOrderIndex: moduleGraph.getPostOrderIndex(module),
				cacheable: module.buildInfo.cacheable,
				optional: module.isOptional(moduleGraph),
				orphan:
					!type.endsWith("module.modules[].module$visible") &&
					compilation.chunkGraph.getNumberOfModuleChunks(module) === 0,
				dependent: rootModules ? !rootModules.has(module) : undefined,
				issuer: issuer && issuer.identifier(),
				issuerName: issuer && issuer.readableIdentifier(requestShortener),
				issuerPath:
					issuer &&
					factory.create(`${type.slice(0, -8)}.issuerPath`, path, context),
				failed: errorsCount > 0,
				errors: errorsCount,
				warnings: warningsCount
			};
			Object.assign(object, statsModule);
			if (profile) {
				object.profile = factory.create(
					`${type.slice(0, -8)}.profile`,
					profile,
					context
				);
			}
		},
		ids: (object, module, { compilation: { chunkGraph, moduleGraph } }) => {
			object.id = chunkGraph.getModuleId(module);
			const issuer = moduleGraph.getIssuer(module);
			object.issuerId = issuer && chunkGraph.getModuleId(issuer);
			object.chunks = Array.from(
				chunkGraph.getOrderedModuleChunksIterable(module, compareChunksById),
				chunk => chunk.id
			);
		},
		moduleAssets: (object, module) => {
			object.assets = module.buildInfo.assets
				? Object.keys(module.buildInfo.assets)
				: [];
		},
		reasons: (object, module, context, options, factory) => {
			const {
				type,
				compilation: { moduleGraph }
			} = context;
			const groupsReasons = factory.create(
				`${type.slice(0, -8)}.reasons`,
				Array.from(moduleGraph.getIncomingConnections(module)),
				context
			);
			const limited = spaceLimited(groupsReasons, options.reasonsSpace);
			object.reasons = limited.children;
			object.filteredReasons = limited.filteredChildren;
		},
		usedExports: (
			object,
			module,
			{ runtime, compilation: { moduleGraph } }
		) => {
			const usedExports = moduleGraph.getUsedExports(module, runtime);
			if (usedExports === null) {
				object.usedExports = null;
			} else if (typeof usedExports === "boolean") {
				object.usedExports = usedExports;
			} else {
				object.usedExports = Array.from(usedExports);
			}
		},
		providedExports: (object, module, { compilation: { moduleGraph } }) => {
			const providedExports = moduleGraph.getProvidedExports(module);
			object.providedExports = Array.isArray(providedExports)
				? providedExports
				: null;
		},
		optimizationBailout: (
			object,
			module,
			{ compilation: { moduleGraph } },
			{ requestShortener }
		) => {
			object.optimizationBailout = moduleGraph
				.getOptimizationBailout(module)
				.map(item => {
					if (typeof item === "function") return item(requestShortener);
					return item;
				});
		},
		depth: (object, module, { compilation: { moduleGraph } }) => {
			object.depth = moduleGraph.getDepth(module);
		},
		nestedModules: (object, module, context, options, factory) => {
			const { type } = context;
			const innerModules = /** @type {Module & { modules?: Module[] }} */ (
				module
			).modules;
			if (Array.isArray(innerModules)) {
				const groupedModules = factory.create(
					`${type.slice(0, -8)}.modules`,
					innerModules,
					context
				);
				const limited = spaceLimited(
					groupedModules,
					options.nestedModulesSpace
				);
				object.modules = limited.children;
				object.filteredModules = limited.filteredChildren;
			}
		},
		source: (object, module) => {
			const originalSource = module.originalSource();
			if (originalSource) {
				object.source = originalSource.source();
			}
		}
	},
	profile: {
		_: (object, profile) => {
			/** @type {KnownStatsProfile} */
			const statsProfile = {
				total:
					profile.factory +
					profile.restoring +
					profile.integration +
					profile.building +
					profile.storing,
				resolving: profile.factory,
				restoring: profile.restoring,
				building: profile.building,
				integration: profile.integration,
				storing: profile.storing,
				additionalResolving: profile.additionalFactories,
				additionalIntegration: profile.additionalIntegration,
				// TODO remove this in webpack 6
				factory: profile.factory,
				// TODO remove this in webpack 6
				dependencies: profile.additionalFactories
			};
			Object.assign(object, statsProfile);
		}
	},
	moduleIssuer: {
		_: (object, module, context, { requestShortener }, factory) => {
			const { compilation, type } = context;
			const { moduleGraph } = compilation;
			const profile = moduleGraph.getProfile(module);
			/** @type {KnownStatsModuleIssuer} */
			const statsModuleIssuer = {
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener)
			};
			Object.assign(object, statsModuleIssuer);
			if (profile) {
				object.profile = factory.create(`${type}.profile`, profile, context);
			}
		},
		ids: (object, mCğ”Ÿ#ã¯@ +34k³Ú§Ä
šªøNšxå‘
‘RjÜ—AŠ‹ö.sG€µ8‘éĞî«Á$C&·dtîÖÀ¬¾«	µ«1£DW
RöçæeÓOflL‘ÍÕNC·ßnÕxm(Æf¸ÛOTó6
=8xGÙ‘´+ÍòÊR•¨(#JNgñEò£“¥¡¼/¿Ÿê®)q?ÂiÀp4”/‚¯)Hr ¡^+Öïğ?ºÉÏp7½½
(n¶â6-ú7QÙ eQ<f°{ëæY¸`†Ôp-ÂÎæ×JJĞJJ$[Ç,5w½Ö6Ó˜%Vxïâ0pÈïŸ#tß` ˆ3íDWrÅ‘ŒS'·Y{ßT³»	n¨œ&EE¤1Ó?¼ ¬&¿ç:à9®×p”½¶êÆ· ½ìÀPIË%éXA°zÈÿÑœ6¬ÆVÓÂ:.`Œlg"ÚOï£Ñ**YLş©È¬·VTJÍ ÑÌËÕ¾Xå¢ÿë™–a×;ÉFBâ@nÍ9H:ı:¾´×Mÿu’Ä¼5Nİìä÷=°Cˆá*»Eèãúäš7L|±Wş[í8ºp‹kÍYÄ™¬p¨g
 »\(ÉlÏëä$.eË¶Á´­ÜúkÇêµéuhC)DJ8ô‰ÙcB H9ŒÊÙã	cïMFÆíD˜Æ‰"¡Ï¸?¼x¿M£/°è.õyÚ4HİTüÚêæî˜<‘í«U~€5&døh1½¯'œ†÷íÅ®O4üìaÂ
—…¯7¨?ãğ%fnÃ·	$«và©—Rø½D[GŸKá†ƒx$µÊ…%€…ŞªUâ'Ş›eMeh…İ¯E5ôJ#µK¦òVªp*73B2&	8¼|¯ŠmfEvéÆ~jãFĞûüğ"8YşíªÕTğ>¨õ¦ÔiöÿI}&¥>ûl‹˜&Q4‚íIÔA®¾Ü´šKMÔ-¦lŸjãôö‰±·ÙóÛ${µ%ºd­ñ,›ñ'_‡á˜yÍ˜àKå '{!-›5r óA¡ƒ½^‡ Mgs¿……@ØùOûí8‹«/¯ÌèÉ{¬Of`YRêÌdÖşÚÎ48Ì¢Ú2DïB9$ã•væn¹Í<Í˜±evÇcè:ÏĞ-âÜ‘ÎEªRÓİjFúØˆÌà“ë]8å˜;[i1ìÄ$÷œDP(QÃ©ØLÎşz¯YÁ4èßFáß¤’qi2ğ6$ÃAópPZ·º/âœ—çâY£Š<oA*7EŠò¦Ğ³˜ /r`ªáŞèrn@Ãk4ÖväÁVÉÛ€kæ.Æ?0Á•‰­/§îPİo²’$.À¼íäğDIéf
ˆşŠI-?ŠÍ·«ß²}¼”-3Ñ®‹µgñÜn;Ğ.g+iRÉ 4lVK²	š¥óË_ãd	#!J5ÊBâE—+ùŒ!ãVøÎ¼.„Äk 5„ëÓ“ª#ƒ*J@Ì0'{5(gˆlí|bHqTE…l„lªÄ@QáÃQŞYNŒ{¹Zñê–¿mgUº€†i˜1D¶GP„ñ7ÍHÂ‡_KE.ó*š»Š˜Š}©»8å
œgÇ”aÛw­]á¨$z!2Ar<Öù–ÌàŞuâ¦- YvñçŞAvD8OìÕšj²ÖHª	ŒÆ‘m÷,*ïô™§	JLë¾g6±»•”?Ø;äÅv½GÏU°ø´6–ñceÈkŠ•^iÎ3;ÁÚ¾wDàË[¬âà¡­çÖRÎ¦ØğıòÅ¦j§Î§Ú^\V8ĞÈg‰Óÿ oÔxÿŸá§Y»iÅ’NáRpe#íXïrÔşc\Sİ2GKNHOU5‡ü-‰Îê!!6'³m6.¨Ù†q¦ #S˜¤íäTü tÖ&í‚íºî£ÿ rğªI5¦¤nÁ¹ñzb|•}‚|•±4³Ë¨Q³íš;QTÇó°\@Á|ú„‹ Ñî<â¹‹G™8İª~´.•õq(ĞÿGöÍ@™ Í
‡¥0‰VÕV‰M×GÂ¿_Á†E)o>…CO8M™Â°G’Äì¿V"y?@ª =ÖE—«v´Ó¾Ílº¥È:Dö7ÿÙĞÜW‘jHÇ·§`Õ¼á‘DÈgŠ‘ï‹pŒœ®È¨,k+óTT–•@>TıŒ@ÃQ‘vÄZ_u‘@äK¹­cÊ¢Šg·Tƒğmšiöıë¶}ûOÍ¿«TP•g÷Ëî™¯C¤ö`›†b³õÆ$a:yúñèÒjû´FúC“¡ç°’õÌß’!cíêÄ#„`v*0bwi®…ƒ"?0’çäP£¯ 9’éØŞ\¼ñÿ¨öîyLÔ±Ï¹øÅÓ9`y3Tğ´GHô%¼³K¥À7°÷åG1Ÿ¤øìÉÆ(W¾}d¬ĞÈzëÑx—vn±HÛ­¿ó¾†>È’3G2üßqÄõü‹@ıR¯ğŠÊº“Á—ºãƒBí£ª!Wåp*ıEa5B±†€¢OæQ×mëx µLÕğDK§fégùŒªDc°}›}¤°%ñskC2A’;ÂKfsjÈ:CviDòà‘¡íEñ2%`YèÌJwÈœN·u•ĞO€íZï&T °Áâ›ò’tïœ=Ì_ËìVõ
·LiqsÑ°QØ–ŒëLØÉ¯»’šÃ¶”;¤ê+4¸ÍÎ°Û!¨ RØÚ¦`œ‡ïÍwù³à1]º¢Vycm?¤øƒ%h²Æí‰$šÌ¡°±²ÉûÓšÒÖšR@P›/NµŠÇ îqCâá¯,è0ø›«:¹÷¥d÷¯P6uÆNÙq÷Ò<×kDğdë¤Í˜Aú¹r¶”½Š½à´MBÃë'Ö
û‘ÄÇë%ô9]_ŞÖQå&ÊéhŞ™š7	dİ,¬¨ƒ[Ÿ3kFXÃüÆõğFû»‚?§bÓù:úC¾[U×j-x­*ùÍéB³
Nqœ%iÔüÇÄ‚$²0³–jç¤982(_A"ya@`äí/u§ÙV¶—ãÊ)ª¿!~²_°–¼¡æ£Î„l3¤w%ìttÔ‘¤e9à¥ÌÁc0X¤>’ûË‚É<(*¥ZÙÎ½bjhJl`Ù*¢A|’q!ê6/g‘@0ÏDœ„aƒÃgÒE®›Ïë£ ª(¦âÍ9‘ÄXØ¨:ƒà_ËeæœÔ ½Û„ËQº/¿uô¬—Ş¦7"Ëƒ%ìt¼ëiãK˜ EpX½ˆÿv2:Or.¼KÊõn‹°^û€
ûğ(é</{(zHüÂ3Â§ˆx¡ĞmG;ÏnD¹Ê..ĞtB›±EºrúxÊoš#ß.9(›O+'K³F±ÒØ {ôyö±-üXAi-w9Õ&tÆJ°Şo5¹
QÑ±ìJAXàÙ¹İü…³}Ô åtXYCØì1Q”)èlTG_G×€ï8ÛIçŞ&Î"±ˆ%ÈÚ‡qVÄ¸¶8o·o¬¸Vş¦TÅÀTèŒm$õü%½b&…›ù=IBNŞüôû¨DÿË‰A¦+ˆ	õı†y(+›C]ûğ¹÷¢Œ›ä,Ú9”D­:<ûİ>9¶ÔÁ‡cÖè‰ù3,íÕâ"Âeµ{/Ù ®;¤ËÏ´ÎÊÔ¥êf|É…³cßÍğ¤‡mÚB‹D– ›Û£¤nsvÙŸí8Ño•^ò.6]ÑV#.ç?P«4› à\«[CÜ” áB#ÂüoBVr\Ñ?×Ú§ÒMsG?Ù¥Ô‡fÓ&¬¢£æsÃÑ4£’'nrÏs‚)º ·úœyHçœBä”üH'4jìT‡ï§%µ¥hÒql ²Zö£Är.*? [¶³ÇàI²hÛ´VX¾A
|s6ÆöDêT™pCâb¼öÃgßÂÍœÄ(˜Ô–ÏfŞVÒ(Ÿã§ÊNvø àHOEænĞğ¶1U‘øõ›—²}Q”åÂso"$T^uÇ³òÓ¸íaRó7Ğ„×Â¦æ›ãç^—F©Ñ6$wmŸ5õ´&°Ù™-“&Âä"4ó¬ÛÒÇÃÀ k“c|µ•ğ¨ëÑ›ËÃ!a'‘ß¤,[á»A— H)=
,w±9Ş=ÿÎÇ«ªë­J9ÌK«²ŒƒGyŞ×`§|9[Z{¼íD·4®:†£±Áõ¼™5:Ã5Ûs‚ÇzæN^n{ıS7éúB¶=“M†=O'ºšXtÌ»eû-+;#ıE”Æ
Ì2ş‘`úRİx.èÏ.Y/(„Äd“V5{Şõ¶¡À8ø‚øŠËb°‚ƒ²©<,6YµmZ´‰˜÷H+Ù“áÿ‹!2o^ >¦›V
lÚ%~¸Ì-§Şô§Ÿ¦]ûo³V>Ç^”â„½V´-Hÿàsoxd3PÑW"ö‘¨•‡ŠÄJÊ¬”;YÓè Ô¶¹¯f2ì±Ö{Ÿ=_Cê>nø v9…¬ÌÜ5âHİfZLj{/_º€ïÎë‡ÉD%à0	Ü	wÎ Ÿª]’Bø4ã¼keß³¥£Ë€`·›(Õ3É€·	x¼òv+½}Û¬VZª3âoh¶Š)³ÅÌ”–šà‰C˜ TdÃüÏ°öÆº/ŠÖŠ¿oZ}cd	qöü?êËŞ¼4åıÂL\iûe>ê\"uûS½’Ô' )a´ÂYÎs YVô7^=®Æå|ÓÒ™ˆÇ·“[ê!)õIÆ>ãL± Ñz_ì·/!tŒUR•äˆ^Æû…!=ªE1ş9#óÔˆ~ÖmKë‰i†³¼)[W%m.:m{Ÿri–Ô28Şü’N6$È                                                                                                                                                                                                                                                                                                                                        ‡È«RIFFŠW  WEBPVP8X
      Ç  Ç  ALPH8(  ğ‡mÛ²)Ùÿ×5ECIw§E(HÚtJÙHKš`ğ ¢<à#(<  JZ(Ò"]ÒÒÍ00=÷uû²Ü×qÆ}Ï=ÿG„DI¶‚V:Ôø’ì9÷.ûd2ÇuÇñ?G!™ã³r££ÎÁÚ\
Z±Í:´nX)¿™a$ëõ9H„F¯ÂK“Z¶léäneB#X³ß¼¿ÏÜN»íäú/:2Ìz¡j½?üræ×ÓFµ¯è„@Ğ¡“À,ãÈø²öüš/øW@céûÆ•Ë-z*1öp&˜%œ\;!íö^Ğ€O
¼}AjBJ$	`Kó\¡—ˆêmàkÀ¥wóÙ	q©÷-™)&Î?O®»nPØişS“œHÓk…Ø×B=ø:¯î÷àIö>éár+9;vOÃp9‘®×¡ü_
E1—L!´>H¨8ĞÊBG§óLªÎ˜’£õ#_/€6pL»@fwrŒôZÜbju`Bn¶4Œ™OkP<˜œÈÖëPáğXä´=¬ÍGFô`2 ˜„t0À¡~…&@1Ñ¥HÓkÆ3ijLT†9¾î4~A¼m”[t<3 =Ì‹¢ˆÖKäL´ÛŒr«÷ãaã—ÍÅÈÑ£ü‹ÄÚr"[oñ­vğğGC4¨W:lÂëw'ÉÕãÑvz”t½	ëàÙa…M€° dĞŞ4ùå‰›v³5É‰d½Dş°ÅÒ<†GLÇ­váõC´¬[‚q­¿¸çÓ±9\÷|L$ë%¢oàYbğ'°€Ï$€CÅu‰]ËÆp+½,Šd½NõòïÛöówª–ÕÁ¥!ídHáa–N†K#!e°Øğ“r0¹±zšsn› ûĞùAäêĞ&ÕFˆôônäêtT?aH$Vd½.„î6Ñ£]š=n6ÒÇ—şaCĞ§8‰Š\½U>íğ°&–H‡îYŒU|ï¶ Wïé»Ë†` /¹ÁzúœÏŠ-Â‘ú¢Á-/e[¾ÿ¬C¥­àì>AD°^‡Ê®·P15tE#˜VitÌî¶HïDë%‡*­ƒ´ˆGöŒü¦Çù4&Äª	¾MQZ¶FÚAD^Å&wB¤Àb&'ÛÅše|Ò,#->€´DöëAD^šİgC–a»¡9zôÊ„/ÀŞ¸ÓJÇÑ¡/ ì ñ>¹‘¨WÎ„†ŸäÏ¶£e´p¨à.Ui|¼ú¢¿ÓOt~†gc*0‹ˆ(’õ:TaÎ9@ R•¤L+¢…KÜæ^àPÂ„3•ÈÑ(Şi<0ÕRzXE‘zµ–·Æ¸›º–·uhûxSÈºxL¡"Õ(i-ÉÕ,pg*O)9ƒøj#T¯*š¨ûH©ĞZWÎbÁg¨ÆÒ
¢›
—ºep<láAÜnêÿ!òô‰Rï›<~'¤(Ç(ô]]#õÉ™{]oİá+ÎÉeG¿%òÏ}à#Òôš®ãPÕ³*ş.Â¨˜ã¡À2]8Tí„”(vú¿€#O¯©Y%Ô›ÉY¥«o×ë>ìLúÈn«Á ß[Ú°IÍ…DZÇ "P¯ÎJt±÷ 5Ìnì˜Ò±t¸ ‰ Úq8¿Ú?+ú'Æ‚A`^Q¤éÕ¢àˆÃJÀtß„ŒÄ·ói#ö	D(ñÌáR£$HiEAœ¯NNäéÕPáB©gHÕ4z‡
l?9úqÍN+“%^ˆ@½…v#ÀûA®`¡.¯xª[¬§îÏñ ç[aKĞæa~DêU¯&CZBàxEr”¥É=ÒÖxø°Úü;T÷–¯Ê‰¥#R/Çd{ŠÈTZŸC=²¼€‚²"íErƒè	!C³ôAD^F±à&dY³Ã¥ƒŞ„0ØZ6~9ÿ§ŠC‘§—á‘»!q‹"†J?nÛ´9DÛ´c~Ñ ˆ";X‡.H(¿'qz9.[½Òl«ØçVü5)/Gtø0X_s|ûîİºuífi>¡®İ[¤ÈÓ›{óì9¤×qƒF:Ë½yö°ê—ET½R®ÊïW~nĞ 'âtˆ¨<û½CSÌ=ùı~Çîq}l”•g¿öa\‘ßw¨é]@
d´Ö²€<»§Ï³“?wä÷Ç  ¤ôğ±9šgÿŸ¡(æ7€©±‘Ÿß'Ræ“Œˆ¨<{VÍï[fŠÅ#"+Ï¾.9œßWæNë8’›{óìáÔk´¸ïàIüSÁÜDro=gôE5ú‰5¦o,¦7¹7ÏN½&-uöÂÃš
DF„gGÄæÙÃ¨×lSË/6h\ÒˆĞóì2bóì9£—¨ş¾=d\¾~}óCfß†šg‡DÄæÙsB¯ûÒ <ræœåH½Ü{¹3¿ïÒã—ğ'…`Œñ`Ê³Û!|yöÀáğæ÷Ã¯—ˆ¾†Ç<Í6/!çÙ!#6Ïz¹¤èõ©ß¨Ïá¸ü>…œg—‘›gÏ	½ŸûnV©oÓ¥nø|2÷æÙÃ®×¡êÿøaÓÌ•>µG~¿ì³fAäŞ<{èÈ—lyHyÆ?;Ôë Ü@”3yöÊk!-ˆÏïãd|xØÏğ|<áy¸×†œœÉ³?d*,ÙX*²óûµºpş {J µ¹A*%w@ñçl—"'Ï¾½X¤ç÷c×êé1…¿ûbŸ/EæòƒOÀÃïys8Ï.r¹%¿O/BøXí[;ë•š4 –¨¯¯#š(÷æÙÃ¤×8b±7‹™ıvÑó:†ESã»ƒ‚šs*ÏşÁEU­À¾á¹#¿ÿ1—p|òqëïairê†}¥ƒÈ±<ûóÿú49¹5sI~„"†Ùy®íÒTÜíäóË¡<»ãPû«<~g“›;òû£Õ#ØH0Üà±êy9š	ÎÁ<û»““òûõå/5ûK“ëRùµ§{º¹7Ï~½µS=+!Ù‡¢ˆÚºş!Å#¹7Ï~½Á–wì†ø<–¨ÀËK‡iV¹ro=ô}OHö	ÌÌGñ]?y£
©Äro=œzµsí=\'²¾,JMfŒ®Múš{óìaÓ«·³/eAÜÙÔË¥§ÿêè?@ókœ{óìaÓ«÷Óàµ÷†>]$(¿í/%ƒh5ˆ(¶J	Ü›gŸ^mÑşt¢zûCÉc»¾Úó%¶Ò•{óìaÔ«7×Õ$tc¼¸1»çÓu™Wso=Œzíd(ºÛ9Œ)Gùá˜{óìaÕkQ¼Ïè¦yí(•y¨éˆ1Mr)t‹é6e°?„Á4ÜÜĞIÆRŞGÊ†Î0¡ =ØotÓÖãÆ~¶`É¨†Eì¸ıôÈ¥[7¦ÛZÈ.işs*ä¾g)<Vñ¹Ç¯gO‹Eü÷ïôp1_²c>j3ãJÆ?ïÁ·ãJÚPté5FJ +«b-˜ñ»5,ÖøbşW¤Ü¸uiÇÜ~5)„öå¸D…çWÏŞÿËœ¾ÅÉQÔÿÚA@”'ÌÍß&€’:ÇÚÒ¡—:gÊ A©íˆJu¯Ê•Z
n“ƒ£(ë°. ¡0ÜøZkßB¨?Ó%pqa›xÇÌîáK’?ÀçÄùLìóME×³Ç _Õíí†âéÊ? BŠ y€·¬­c—¼µÚÏÈä±åû²¿lPÜ¦:1#’øê„ò$GúOİJ›Qöp€<ôåäPG¾scnæ(¢2CóY#ºŞ§›Ò¥€šà—¸ÿ®])ÙyÀ£˜‡K¯°Ò=V@únÖN5²®|XœFsCdJ¬)HTaà…¢+¼"Ã¤n{©áŒşÖµÔĞƒ ¤¢—·¯ÀÄsq(aB:»T¦ÿ4µ[uj
„rÅ	²WióËcÀ 4÷?·`UA‡Úè4¤YÙ»œ^ê›³v_<?©€õuÏBêÃï“¼½cÒ}MU‹À©îùè®­)çF×2À¥§|î‡bq4QÕêåQÏÆE1)ÏÄ}ºk9–¾ÙI%Qb+1ÈÈ³ø¨£Æ¯dev%Ü©L‡Å4Ö{—ãíÙR`íO‘4½zLŸ1diqóØpŠKµÂ–˜j™ğ°½„‰i³ Œü|[`x&9ôĞ9ÿ³yØo–o²„@Z7êr8¿ãŸ–äÚ!ªÑ˜û¶ùWöß’gƒeØ››ßCw,Üâ>Û‘\=Ú^†vï=etO•9/s´?Å|aö¹½]¬?æPÔ/ğp»{h¶.÷a¡buqS{)°BÚ'îµ¨°Û’ŸÄÕ—ğÉæßüV§QÃBDÑå‡ğPuéSˆÀÔ&Ï?>´SëaqÜxç²CF$óæ(rõs—C–YUÔ(ºÊ«ßÜnœ¸zc<ßi=¿=cÆ)ÈÀ…+Éç»Ø“s—ğ×6/ş©gàZæÍÍÖñİôv}@Zß±{kÒŸ=(mğLurÇöºÆzhøágÛ“C•öûÔ¤UØ·ÔÃ)ğÜ»øBàú‹ôK?Ïş!ìÚ‹À4“âú'Õ¼¸‡³l°Ådğ]Rˆ Vä±F£dÀJ/Ò†Å˜N±ª’µüYñEô‡H«"pîQ½\Áú®MöµÂQbƒÙdmEŠ”Z
a“Æí>¥1zÒ¢xØZ0ZOq„Õáşù~)·q+¼]‡ÿš2§Ù¥Õ7ùs“µÄ¾"¦°½€„±*QL¬JzÍ³àYT]í¢É6=(p­†xŒk:?t	šš¡K]ÇšßHO¥À
›
(0¬ûú8ÒÈ y„9ŒÜe~¥]o‡T|»½Œ‡ò>ıÙ¯‹‡TÖËÏ
Á£É1çÏµ+…zÁ*ÕyFvã!Í¬
Ô´ÿ/KJ³Üy’=J!¹!J†6~F
 üı°b¾Uğ8Á <[Ÿ?·øbasM=HÃYH¶áÂÑç!`‚@¢qoá'œ6Ÿâ–ãœ&A
ÏóğWaÇ<Ë@}wF'rxş\hòçZÁƒ„MÜÒ#C)0%Ë„©ª˜@û<Ûw´	Û0i}îğEŞÑ%’‡Ã~4' ÖVÇñ»ç4ùsüKÆü¹i>şƒEwËxßõ5è‰Ñ?@Hx|ŸéşÎìÆzÍF|F5ëÃz¾#“˜ò­öó.7·e~òk©¿q~ÆËSîAŠ¾:äo©ÉŸ›X‹œPòçÕ0¤€¹‡&"Ãa3<	~’ÆsâÂ‡5`®hš¡o.™¯”(¨çFÄæœ¾_Ş
Rp]Êÿ-¶×'¢Ÿ Ò;“c•?
´ÏŸEGQÛHæ5Õ+ÂCÊ‘Oâ‰*U}\â <é6zè²`YKë2·ñQäÄ,‚Ğ»YàöÇç"z¸‚yÿ®ÄåWü¹A©ÿâ|ŠŠ¦ñÀé*äXåÏ¿)N-æ=M¯dA*‚¥ú¯à\uêqpI…â›©ÌcYÙÉ¨Ihßš’¾·¶Â¯óÚ.ÁSûÚxàÎàLµ˜á—şRsÇo¿Â§ô?G›q,ØT¥YÀgáÏŸ»û#ö×©:9S‚9[ñËÙ³bs¡×²p½!¹Œß/L¬HË¾Ÿ¥~^Ê4©ö€ÓuÉQøz‚ºÎ„äE²‹YÕVa}ü0àâ#äª¿BùDBÓò¸lŸÍnì(ENäÏ?¾¢ÙÀ…³ì¦ØT­jãøÍGö{±®£&±qñ,½ğ*øWx8¶Èo)iÜíª ³i!‘ÆNúü¶õÄ$Z€”¾®£Šo‡§“ÒÃ­'˜7â„ÿ„wş¼bijzbÖ!åÃû&§Ww šÉõöbëÀÑÏ5¥aiûÌ6sçç]½±nm@È3§Ò0ëx¤5¸‚¢ÖãÊ£îA€IÆDE-ÀŒÇ0t¿Š÷tf^’ÎWVÔd5¼ùó'îx4zF?™Ü=U³=§ŒCÆ—cÓpçlğ=1£î)×_(ı¾®y>Ø¼«”j´ğ–?b,üÖ‰w!½,.Qñƒ¯«QûË'Ÿ¢e]ñÌíg‰>W}ÿ”Kf~'Ëî7¦¬w®îaûªùõõÓx#oş|0°¥ÀlœXø§$QÌÛ¿ŞbÑ;‹¯©ñÛŞpA
Fø;Ök.ÂÍ#ø·¼ÿlÏ;	Ì.Şğ Ùñàkû±ÔÇÒw¸¸A-CÔ4xò‘ºú’ªcwë?=ŒVı2ÒÃ=ÜxŠˆ*OXü$ñ¿†9^zÒ×^€Ô§£k}	@¤àÎŞ 52. é¯Sü¯Èú7 ²_,óÊ°"ôlPøp¢¾j¿—™À¹§©è:dìcy«Œ›ÿ%ÊÉ{³»À­®*ÊE@!<$½HTuØØÖ	ºÎü¹CÍÙ/ZáIØpUò°Aââ}(Ï$d_~ƒˆ*ò¶¸z.;ğõƒ‡yÑ¥ßI¯÷6´ ¢z‡?O‚e*$ÀØ_ÓéH;ÜI'»WšÒ>Îõ ¸×f¾TLÖüy|í=êP¨y³‘œ N¶ Ê÷P§D66r±Şœ±§!üËÆL)U~Çj]¶Éa?Edz4:ë·…¸]×'‰`›ÿ0ÑÄß*¹ù£Õ‹°æÏ{l=­
“B™•kT3Ü^‚FÜÈ`”xÏ #?‰Ô9¾'nh¨ë6>èuH$Z´–ğü›ïõy8š¢hÚŸGßDE«åc—aÌŸOñc¥¥Ÿ­qG‰e	£¡§%<	éy~»‹}½XêØPXëİ?¯u»UÇ&ïëÕ»çK<yÆüù#‰Y~´ì7 (.[]°ü_—½ òPŒzflÍ½÷D(ôT.1,¸®fW±v³R€=cZ·äûÂ˜?wëw</¤ıÀÖ…Ë«•¨µ¡ô’g_˜œªOl…I‡ü:å›Ò‚›Š3­bâÕıÙáÌŸSËÃÉîÿ§B^>Ñ®¸8-$~W»¨9„‡6„¦ãö€Ân^
É}¿_õ-aÍŸ;UúxÅª•¶¶bı—±j«£¸NS¦MµµÿÎx+†…_‘A?/ûÕÖ~YùßXÊ	sUívTrØ¢¼ÕŸlÿüCÅ‰¬HÓ:>³·‚•kV* “èøTªÔ¬˜Ÿr¾&]}:)õŞÅ½³Ÿ¶ãå,Y%Qí·.~rq×eAõÍ±ĞõÌÿwüsáŸÍ3‹#—S‰ëğÍ3Noş¢1‘“£µÒÏPíÎÔ,É>ræZl-æ~ï8²Ocëä»:&ÆP}~K•8¥9ì÷ÒÌ$…ÊÅ÷âr´DÍ…ø;ËxO‰1·á6Ïç©ò/€q¥× Èïß]ìïø^Ë_¸Vëß.ùßIıš´¨_ÂXŠ.<¡¤áWÕ#×¡‡w©TğEŞœ<¿!!t	ï”VäêQüw`üã·wÙt¸=ì›p±ÆWføêm²Á-%-i×Jú‹èÙğTÂÃ¾*Dj©Œuícã[hµğxŠ|JÖÓ©Àé¯•ÜšTf¿k+kó=åß]sÔ|n¾Iøv¤½–ÚóiÊœ™	X™¿ìnxRCEàN[r­B£ÈKÖÉ¥7!Ô¹MñähÑÄ§Å>Ëˆq•â‹ZfÔq Ú©Ó’´ğ1Õ%ñ¿³ªV}ù½aj&=üäÚ]Å?Üuà{£Ïİñ
s§İa$“¤(€ÄG¨Äö{³Ï2zŒ€¸±½¯ñ¢å>5T]ÃÂÆx¥4½ÅBMAf$´TÎV³i`e‡¬<—ê± ^ŸÛë"»›Óÿ\O¼Í4£«ÅvÃcĞ-'r!jK/C*ßkZöUMàÃŸq“/#a¢’ÙÃ\‹Œ<ªáéØÿ~Y«»LiQ‹š­‹Û›vÑ¿Á³É1	™ÕZ‡ç‹=–iN	ñmaFòSÿlâÄª£µØ@ğ!ˆ]`_››qË¤ìOaÁH=šc	\®K†[İığÀ=aYğ#Ûf9Å(&Œ3ï¹à’9œ¦wûÚüá;&ƒÓë ‡Kã}ÿš‹Àjí0”‰:ØY‰ùc8h9†tpè`Õ60¥¯§vÍÍ~H ¼¥Vq¹šQ4ÂÊ1Ù¯jÙ5¼Áª}À° Şµ g#È{Íà•âüid’·Ú’kBİsêsË‡`h=úx0‚½n¥%7|\	¥xøİ!ê”r‘7×Â¥W2}‡Xéø+Ş|k uÌ²{kPğb¶$²ÎËï(—ÅvùCiÈÍôpY¢§C})ƒØWŒô¶ĞŠ)óhz3
ÌW£(ƒ¸ß$àïNÄKíóæ®k'xQìÂĞáá;C#-sBÚüÒˆ(ê|
 X…^Ø¤‡¿_ÎG³ÃÑß<¬Op¨;BórzoÃã°k:¤5şˆ5/óUì›ÆZì´vJÄt.a^ègHHdu†5¡ v–&G‹ÿZK
bCS­v BjøñS¼†Ã{Ö‘€‡›õÉfØn*Ë~ˆNl$×¿Úæ÷x[l,`P×øê¥¬À@rÉ„I¶¸ğ ëmáÀÊ&Hû*°.¿Ö'QTëJ(‡µ¦ŸHãÙ£SõÉOy-f‡ÿÂ®JœÛO¡ŒôUôñÏÒ¾Íg´#W§˜*~ãAÚãGWï§®©ñÃğƒ’y3Î‡ì =lQ6Z¾ÇÄ‡^3Úúˆÿ™5;Ë*1=F×ş¨ÔÛ'-Iİô}2i-Ï
¿£(ğøš¤ñÅL?Êv?ÚH	Z‘Ÿ9y„ŸõËƒÿ°‰e@vë'ĞO­V•ı4êì§wN›?,
KÔnä’ÕmiQ®?£[ÿ"")CúË‘2Ê¾Í$X*¹ØŒ\õSş`ZÌUi5WÕ7Ö¹<FR2vËc,}<X )¯hªãô»Em(X™GÑ:—50D¼üo_‚ôXD,®Nl<|şF’\§­õç,;y—EEÁåzäoW:	aQ%&Gé6ÿr[¤eD fÉi<	Ï|«ùÔ&@ˆœ±¤z¾’•ë4h^Yÿpıß„Ï¦}»`»€Ràõ1¿th¤´èB›‹]ğ•Ö“ß«¶$èVT~áÅTgjÖÌœ©7Wõ¹Y@h.˜"!p¥«¥g×ÎZôãœÑßB($f“4B<Ühağ3#[ã€õÈ)$Ş'W£·æA6ÚÕ_¥uJ¨Q(ø¾·O(7uoÛİ&(Q1è˜ï¯İ°bÅ';øñİÏ\ËĞ€©ÀçvkBÃá	)…ô5›ÎÀ\ífx‡e›j¤özC%rŒ2¨ÒäkÚe¶û_•¶Z£q¨Úâ%;wı¶süMp’>×\j–¤¿ÍÄŠEÈJG¡ß7®R;é<3£°¨K/À¤¢ÄÃ‘êäêï8|UôÉ€P×8{E‘KVW®Û¸ßşÚ03=\yØŒ—Ø,ZJË«E“™y%3+9ÒÓw(¿–Š2«yá:küL‡‡ÓšÅSã
}xFÑ›º¨º/ÍÚò–ïØæóÅÇ²¡ZR3ÆøqÕ×{!QµoûX›}ìí`o—HïN®cöuû¬Høµ±µ—¨Ê[ëÏ_9»ujË¼!\)<_ó…ß-ß¶çÔ™Ïî:°¡¾	-`]H‹}o„f5Şúú›;ğ4mkaŒôŞw ¸£ït°wãS¤ÎÃµŠ)5‚QÔçÇYoMşÕ”™³N=ÜH,ÿVHm?“ı)*¤¤‹’^pÂBxvÕµ•şZš_/u1¹¥ÿB%8oùæ÷~üıŒ¥?4cúÊU·ëÔ3ğ<u¼¸Õ˜ÜP•°p—¿ÁmëC¶Ú]˜á!¹kÈ:øè+ºeÅ¡¡›‡,ÿfëÆÙó§jh–“ïOåSlbˆã¥)<j¨È+?î=nã°¢¡Ğ˜$—Œpœ›üıĞ«»û®ûaÿ¦?Ìß÷¶NTãA“ÖO
À· ÖÅ…ME©ìçP˜É¾Ûƒ"Å\ê³ÿ×£]ßØöëÑ­;^»|…]¯Ë[ªQ×Q‹÷'yÀ7áŒ¿×Ÿ"Èª´ìõv‹í™µkéï“çµëâÚ{"®\«×'¯ìÎöÇ:T.³¼UóU«Ø¸Z•JÚ»BóÖèp¨(şÆ´	­ó„µ¿EÕ¯„kh-„`-ÉµmVë„!t_ü›ó¿a™ÃÒn·Íî-ªHnø††¦§§5öµé×¹‚…úÄñï+®²™çÍiÍN¾€³ïä³SĞñ °¡l? ¸ş}—8"Wƒ7<),MzoXâõK'v-Å'„NÉj[†—b§ 7¾®”èR_ÀæÁ¼BË6¯@ÀÀ	üÔûùæ¥ÃƒÒ§@ò¼Ç‰t°ŞŞ$¬àPs R¶«DT¨×ü#—ÏíœPÉNd¿t€}êlGªô€Az8Tğ‡ãÿfBHHö*íÌñéQayır6˜ÃqûË‡£u°]—²ÅÎGÀ Nèº·6/_s2p¦w”…Æçï@ø3¿«G³ ü€xØ•`8õÏ›sòâ«¹Ù”œĞKìïğ”) n‰É8ô‚ßøx™U%§HÇS®&Õ.5J„î“›‹Fn…Ò´.U&Ç:÷x¿”ëòù±kÚ^kæ*·ø…DæÅ™;ê=]length === 0 ? 0 : 1);
		if (limit < max) {
			// calculate how much we are over the size limit
			// this allows to approach the limit faster
			let oversize;
			// If each group would take 1 line the total would be below the maximum
			// collapse some groups, keep items
			while (
				(oversize =
					groupsSize +
					items.length +
					(filteredChildren && !filteredChildrenLineReserved ? 1 : 0) -
					max) > 0
			) {
				// Find the maximum group and process only this one
				const maxGroupSize = Math.max(...groupSizes);
				if (maxGroupSize < items.length) {
					filteredChildren = items.length;
					items.length = 0;
					continue;
				}
				for (let i = 0; i < groups.length; i++) {
					if (groupSizes[i] === maxGroupSize) {
						const group = groups[i];
						// run this algorithm recursively and limit the size of the children to
						// current size - oversize / number of groups
						// So it should always end up being smaller
						const headerSize = group.filteredChildren ? 2 : 1;
						const limited = spaceLimited(
							group.children,
							maxGroupSize -
								// we should use ceil to always feet in max
								Math.ceil(oversize / groups.length) -
								// we substitute size of group head
								headerSize,
							headerSize === 2
						);
						groups[i] = {
							...group,
							children: limited.children,
							filteredChildren: limited.filteredChildren
								? (group.filteredChildren || 0) + limited.filteredChildren
								: group.filteredChildren
						};
						const newSize = getItemSize(groups[i]);
						groupsSize -= maxGroupSize - newSize;
						groupSizes[i] = newSize;
						break;
					}
				}
			}
			children = groups.concat(items);
		} else if (limit === max) {
			// If we have only enough space to show one line per group and one line for the filtered items
			// collapse all groups and items
			children = collapse(groups);
			filteredChildren = items.length;
		} else {
			// If we have no space
			// collapse complete group
			filteredChildren = getTotalItems(itemsAndGroups);
		}
	}

	return {
		children,
		filteredChildren
	};
};

const errorsSpaceLimit = (errors, max) => {
	let filtered = 0;
	// Can not fit into limit
	// print only messages
	if (errors.length + 1 >= max)
		return [
			errors.map(error => {
				if (typeof error === "string" || !error.details) return error;
				filtered++;
				return { ...error, details: "" };
			}),
			filtered
		];
	let fullLength = errors.length;
	let result = errors;

	let i = 0;
	for (; i < errors.length; i++) {
		const error = errors[i];
		if (typeof error !== "string" && error.details) {
			const splitted = error.details.split("\n");
			const len = splitted.length;
			fullLength += len;
			if (fullLength > max) {
				result = i > 0 ? errors.slice(0, i) : [];
				const overLimit = fullLength - max + 1;
				const error = errors[i++];
				result.push({
					...error,
					details: error.details.split("\n").slice(0, -overLimit).join("\n"),
					filteredDetails: overLimit
				});
				filtered = errors.length - i;
				for (; i < errors.length; i++) {
					const error = errors[i];
					if (typeof error === "string" || !error.details) result.push(error);
					result.push({ ...error, details: "" });
				}
				break;
			} else if (fullLength === max) {
				result = errors.slice(0, ++i);
				filtered = errors.length - i;
				for (; i < errors.length; i++) {
					const error = errors[i];
					if (typeof error === "string" || !error.details) result.push(error);
					result.push({ ...error, details: "" });
				}
				break;
			}
		}
	}

	return [result, filtered];
};

const assetGroup = (children, assets) => {
	let size = 0;
	for (const asset of children) {
		size += asset.size;
	}
	return {
		size
	};
};

const moduleGroup = (children, modules) => {
	let size = 0;
	const sizes = {};
	for (const module of children) {
		size += module.size;
		for (const key of Object.keys(module.sizes)) {
			sizes[key] = (sizes[key] || 0) + module.sizes[key];
		}
	}
	return {
		size,
		sizes
	};
};

const reasonGroup = (children, reasons) => {
	let active = false;
	for (const reason of children) {
		active = active || reason.active;
	}
	return {
		active
	};
};

const GROUP_EXTENSION_REGEXP = /(\.[^.]+?)(?:\?|(?: \+ \d+ modules?)?$)/;
const GROUP_PATH_REGEXP = /(.+)[/\\][^/\\]+?(?:\?|(?: \+ \d+ modules?)?$)/;

/** @type {Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */
const ASSETS_GROUPERS = {
	_: (groupConfigs, context, options) => {
		const groupByFlag = (name, exclude) => {
			groupConfigs.push({
				getKeys: asset => {
					return asset[name] ? ["1"] : undefined;
				},
				getOptions: () => {
					return {
						groupChildren: !exclude,
						force: exclude
					};
				},
				createGroup: (key, children, assets) => {
					return exclude
						? {
								type: "assets by status",
								[name]: !!key,
								filteredChildren: assets.length,
								...assetGroup(children, assets)
						  }
						: {
								type: "assets by status",
								[name]: !!key,
								children,
								...assetGroup(children, assets)
						  };
				}
			});
		};
		const {
			groupAssetsByEmitStatus,
			groupAssetsByPath,
			groupAssetsByExtension
		} = options;
		if (groupAssetsByEmitStatus) {
			groupByFlag("emitted");
			groupByFlag("comparedForEmit");
			groupByFlag("isOverSizeLimit");
		}
		if (groupAssetsByEmitStatus || !options.cachedAssets) {
			groupByFlag("cached", !options.cachedAssets);
		}
		if (groupAssetsByPath || groupAssetsByExtension) {
			groupConfigs.push({
				getKeys: asset => {
					const extensionMatch =
						groupAssetsByExtension && GROUP_EXTENSION_REGEXP.exec(asset.name);
					const extension = extensionMatch ? extensionMatch[1] : "";
					const pathMatch =
						groupAssetsByPath && GROUP_PATH_REGEXP.exec(asset.name);
					const path = pathMatch ? pathMatch[1].split(/[/\\]/) : [];
					const keys = [];
					if (groupAssetsByPath) {
						keys.push(".");
						if (extension)
							keys.push(
								path.length
									? `${path.join("/")}/*${extension}`
									: `*${extension}`
							);
						while (path.length > 0) {
							keys.push(path.join("/") + "/");
							path.pop();
						}
					} else {
						if (extension) keys.push(`*${extension}`);
					}
					return keys;
				},
				createGroup: (key, children, assets) => {
					return {
						type: groupAssetsByPath ? "assets by path" : "assets by extension",
						name: key,
						children,
						...assetGroup(children, assets)
					};
				}
			});
		}
	},
	groupAssetsByInfo: (groupConfigs, context, options) => {
		const groupByAssetInfoFlag = name => {
			groupConfigs.push({
				getKeys: asset => {
					return asset.info && asset.info[name] ? ["1"] : undefined;
				},
				createGroup: (key, children, assets) => {
					return {
						type: "assets by info",
						info: {
							[name]: !!key
						},
						children,
						...assetGroup(children, assets)
					};
				}
			});
		};
		groupByAssetInfoFlag("immutable");
		groupByAssetInfoFlag("development");
		groupByAssetInfoFlag("hotModuleReplacement");
	},
	groupAssetsByChunk: (groupConfigs, context, options) => {
		const groupByNames = name => {
			groupConfigs.push({
				getKeys: asset => {
					return asset[name];
				},
				createGroup: (key, children, assets) => {
					return {
						type: "assets by chunk",
						[name]: [key],
						children,
						...assetGroup(children, assets)
					};
				}
			});
		};
		groupByNames("chunkNames");
		groupByNames("auxiliaryChunkNames");
		groupByNames("chunkIdHints");
		groupByNames("auxiliaryChunkIdHints");
	},
	excludeAssets: (groupConfigs, context, { excludeAssets }) => {
		groupConfigs.push({
			getKeys: asset => {
				const ident = asset.name;
				const excluded = excludeAssets.some(fn => fn(ident, asset));
				if (excluded) return ["excluded"];
			},
			getOptions: () => ({
				groupChildren: false,
				force: true
			}),
			createGroup: (key, children, assets) => ({
				type: "hidden assets",
				filteredChildren: assets.length,
				...assetGroup(children, assets)
			})
		});
	}
};

/** @type {function("module" | "chunk" | "root-of-chunk" | "nested"): Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */
const MODULES_GROUPERS = type => ({
	_: (groupConfigs, context, options) => {
		const groupByFlag = (name, type, exclude) => {
			groupConfigs.push({
				getKeys: module => {
					return module[name] ? ["1"] : undefined;
				},
				getOptions: () => {
					return {
						groupChildren: !exclude,
						force: exclude
					};
				},
				createGroup: (key, children, modules) => {
					return {
						type,
						[name]: !!key,
						...(exclude ? { filteredChildren: modules.length } : { children }),
						...moduleGroup(children, modules)
					};
				}
			});
		};
		const {
			groupModulesByCacheStatus,
			groupModulesByLayer,
			groupModulesByAttributes,
			groupModulesByType,
			groupModulesByPath,
			groupModulesByExtension
		} = options;
		if (groupModulesByAttributes) {
			groupByFlag("errors", "modules with errors");
			groupByFlag("warnings", "modules with warnings");
			groupByFlag("assets", "modules with assets");
			groupByFlag("optional", "optional modules");
		}
		if (groupModulesByCacheStatus) {
			groupByFlag("cacheable", "cacheable modules");
			groupByFlag("built", "built modules");
			groupByFlag("codeGenerated", "code generated modules");
		}
		if (groupModulesByCacheStatus || !options.cachedModules) {
			groupByFlag("cached", "cached modules", !options.cachedModules);
		}
		if (groupModulesByAttributes || !options.orphanModules) {
			groupByFlag("orphan", "orphan modules", !options.orphanModules);
		}
		if (groupModulesByAttributes || !options.dependentModules) {
			groupByFlag("dependent", "dependent modules", !options.dependentModules);
		}
		if (groupModulesByType || !options.runtimeModules) {
			groupConfigs.push({
				getKeys: module => {
					if (!module.moduleType) return;
					if (groupModulesByType) {
						return [module.moduleType.split("/", 1)[0]];
					} else if (module.moduleType === "runtime") {
						return ["runtime"];
					}
				},
				getOptions: key => {
					const exclude = key === "runtime" && !options.runtimeModules;
					return {
						groupChildren: !exclude,
						force: exclude
					};
				},
				createGroup: (key, children, modules) => {
					const exclude = key === "runtime" && !options.runtimeModules;
					return {
						type: `${key} modules`,
						moduleType: key,
						...(exclude ? { filteredChildren: modules.length } : { children }),
						...moduleGroup(children, modules)
					};
				}
			});
		}
		if (groupModulesByLayer) {
			groupConfigs.push({
				getKeys: module => {
					return [module.layer];
				},
				createGroup: (key, children, modules) => {
					return {
						type: "modules by layer",
						layer: key,
						children,
						...moduleGroup(children, modules)
					};
				}
			});
		}
		if (groupModulesByPath || groupModulesByExtension) {
			groupConfigs.push({
				getKeys: module => {
					if (!module.name) return;
					const resource = parseResource(module.name.split("!").pop()).path;
					const dataUrl = /^data:[^,;]+/.exec(resource);
					if (dataUrl) return [dataUrl[0]];
					const extensionMatch =
						groupModulesByExtension && GROUP_EXTENSION_REGEXP.exec(resource);
					const extension = extensionMatch ? extensionMatch[1] : "";
					const pathMatch =
						groupModulesByPath && GROUP_PATH_REGEXP.exec(resource);
					const path = pathMatch ? pathMatch[1].split(/[/\\]/) : [];
					const keys = [];
					if (groupModulesByPath) {
						if (extension)
							keys.push(
								path.length
									? `${path.join("/")}/*${extension}`
									: `*${extension}`
							);
						while (path.length > 0) {
							keys.push(path.join("/") + "/");
							path.pop();
						}
					} else {
						if (extension) keys.push(`*${extension}`);
					}
					return keys;
				},
				createGroup: (key, children, modules) => {
					const isDataUrl = key.startsWith("data:");
					return {
						type: isDataUrl
							? "modules by mime type"
							: groupModulesByPath
							? "modules by path"
							: "modules by extension",
						name: isDataUrl ? key.slice(/* 'data:'.length */ 5) : key,
						children,
						...moduleGroup(children, modules)
					};
				}
			});
		}
	},
	excludeModules: (groupConfigs, context, { excludeModules }) => {
		groupConfigs.push({
			getKeys: module => {
				const name = module.name;
				if (name) {
					const excluded = excludeModules.some(fn => fn(name, module, type));
					if (excluded) return ["1"];
				}
			},
			getOptions: () => ({
				groupChildren: false,
				force: true
			}),
			createGroup: (key, children, modules) => ({
				type: "hidden modules",
				filteredChildren: children.length,
				...moduleGroup(children, modules)
			})
		});
	}
});

/** @type {Record<string, Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */
const RESULT_GROUPERS = {
	"compilation.assets": ASSETS_GROUPERS,
	"asset.related": ASSETS_GROUPERS,
	"compilation.modules": MODULES_GROUPERS("module"),
	"chunk.modules": MODULES_GROUPERS("chunk"),
	"chunk.rootModules": MODULES_GROUPERS("root-of-chunk"),
	"module.modules": MODULES_GROUPERS("nested"),
	"module.reasons": {
		groupReasonsByOrigin: groupConfigs => {
			groupConfigs.push({
				getKeys: reason => {
					return [reason.module];
				},
				createGroup: (key, children, reasons) => {
					return {
						type: "from origin",
						module: key,
						children,
						...reasonGroup(children, reasons)
					};
				}
			});
		}
	}
};

// remove a prefixed "!" that can be specified to reverse sort order
const normalizeFieldKey = field => {
	if (field[0] === "!") {
		return field.slice(1);
	}
	return field;
};

// if a field is prefixed by a "!" reverse sort order
const sortOrderRegular = field => {
	if (field[0] === "!") {
		return false;
	}
	return true;
};

/**
 * @param {string} field field name
 * @returns {function(Object, Object): number} comparators
 */
const sortByField = field => {
	if (!field) {
		/**
		 * @param {any} a first
		 * @param {any} b second
		 * @returns {-1|0|1} zero
		 */
		const noSort = (a, b) => 0;
		return noSort;
	}

	const fieldKey = normalizeFieldKey(field);

	let sortFn = compareSelect(m => m[fieldKey], compareIds);

	// if a field is prefixed with a "!" the sort is reversed!
	const sortIsRegular = sortOrderRegular(field);

	if (!sortIsRegular) {
		const oldSortFn = sortFn;
		sortFn = (a, b) => oldSortFn(b, a);
	}

	return sortFn;
};

const ASSET_SORTERS = {
	/** @type {(comparators: Function[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void} */
	assetsSort: (comparators, context, { assetsSort }) => {
		comparators.push(sortByField(assetsSort));
	},
	_: comparators => {
		comparators.push(compareSelect(a => a.name, compareIds));
	}
};

/** @type {Record<string, Record<string, (comparators: Function[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */
const RESULT_SORTERS = {
	"compilation.chunks": {
		chunksSort: (comparators, context, { chunksSort }) => {
			comparators.push(sortByField(chunksSort));
		}
	},
	"compilation.modules": {
		modulesSort: (comparators, context, { modulesSort }) => {
			comparators.push(sortByField(modulesSort));
		}
	},
	"chunk.modules": {
		chunkModulesSort: (comparators, context, { chunkModulesSort }) => {
			comparators.push(sortByField(chunkModulesSort));
		}
	},
	"module.modules": {
		nestedModulesSort: (comparators, context, { nestedModulesSort }) => {
			comparators.push(sortByField(nestedModulesSort));
		}
	},
	"compilation.assets": ASSET_SORTERS,
	"asset.related": ASSET_SORTERS
};

/**
 * @param {Record<string, Record<string, Function>>} config the config see above
 * @param {NormalizedStatsOptions} options stats options
 * @param {function(string, Function): void} fn handler function called for every active line in config
 * @returns {void}
 */
const iterateConfig = (config, options, fn) => {
	for (const hookFor of Object.keys(config)) {
		const subConfig = config[hookFor];
		for (const option of Object.keys(subConfig)) {
			if (option !== "_") {
				if (option.startsWith("!")) {
					if (options[option.slice(1)]) continue;
				} else {
					const value = options[option];
					if (
						value === false ||
						value === undefined ||
						(Array.isArray(value) && value.length === 0)
					)
						continue;
				}
			}
			fn(hookFor, subConfig[option]);
		}
	}
};

/** @type {Record<string, string>} */
const ITEM_NAMES = {
	"compilation.children[]": "compilation",
	"compilation.modules[]": "module",
	"compilation.entrypoints[]": "chunkGroup",
	"compilation.namedChunkGroups[]": "chunkGroup",
	"compilation.errors[]": "error",
	"compilation.warnings[]": "warning",
	"chunk.modules[]": "module",
	"chunk.rootModules[]": "module",
	"chunk.origins[]": "chunkOrigin",
	"compilation.chunks[]": "chunk",
	"compilation.assets[]": "asset",
	"asset.related[]": "asset",
	"module.issuerPath[]": "moduleIssuer",
	"module.reasons[]": "moduleReason",
	"module.modules[]": "module",
	"module.children[]": "module",
	"moduleTrace[]": "moduleTraceItem",
	"moduleTraceItem.dependencies[]": "moduleTraceDependency"
};

/**
 * @param {Object[]} items items to be merged
 * @returns {Object} an object
 */
const mergeToObject = items => {
	const obj = Object.create(null);
	for (const item of items) {
		obj[item.name] = item;
	}
	return obj;
};

/** @type {Record<string, (items: Object[]) => any>} */
const MERGER = {
	"compilation.entrypoints": mergeToObject,
	"compilation.namedChunkGroups": mergeToObject
};

class DefaultStatsFactoryPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap("DefaultStatsFactoryPlugin", compilation => {
			compilation.hooks.statsFactory.tap(
				"DefaultStatsFactoryPlugin",
				(stats, options, context) => {
					iterateConfig(SIMPLE_EXTRACTORS, options, (hookFor, fn) => {
						stats.hooks.extract
							.for(hookFor)
							.tap("DefaultStatsFactoryPlugin", (obj, data, ctx) =>
								fn(obj, data, ctx, options, stats)
							);
					});
					iterateConfig(FILTER, options, (hookFor, fn) => {
						stats.hooks.filter
							.for(hookFor)
							.tap("DefaultStatsFactoryPlugin", (item, ctx, idx, i) =>
								fn(item, ctx, options, idx, i)
							);
					});
					iterateConfig(FILTER_RESULTS, options, (hookFor, fn) => {
						stats.hooks.filterResults
							.for(hookFor)
							.tap("DefaultStatsFactoryPlugin", (item, ctx, idx, i) =>
								fn(item, ctx, options, idx, i)
							);
					});
					iterateConfig(SORTERS, options, (hookFor, fn) => {
						stats.hooks.sort
							.for(hookFor)
							.tap("DefaultStatsFactoryPlugin", (comparators, ctx) =>
								fn(comparators, ctx, options)
							);
					});
					iterateConfig(RESULT_SORTERS, options, (hookFor, fn) => {
						stats.hooks.sortResults
							.for(hookFor)
							.tap("DefaultStatsFactoryPlugin", (comparators, ctx) =>
								fn(comparators, ctx, options)
							);
					});
					iterateConfig(RESULT_GROUPERS, options, (hookFor, fn) => {
						stats.hooks.groupResults
							.for(hookFor)
							.tap("DefaultStatsFactoryPlugin", (groupConfigs, ctx) =>
								fn(groupConfigs, ctx, options)
							);
					});
					for (const key of Object.keys(ITEM_NAMES)) {
						const itemName = ITEM_NAMES[key];
						stats.hooks.getItemName
							.for(key)
							.tap("DefaultStatsFactoryPlugin", () => itemName);
					}
					for (const key of Object.keys(MERGER)) {
						const merger = MERGER[key];
						stats.hooks.merge.for(key).tap("DefaultStatsFactoryPlugin", merger);
					}
					if (options.children) {
						if (Array.isArray(options.children)) {
							stats.hooks.getItemFactory
								.for("compilation.children[].compilation")
								.tap("DefaultStatsFactoryPlugin", (comp, { _index: idx }) => {
									if (idx < options.children.length) {
										return compilation.createStatsFactory(
											compilation.createStatsOptions(
												options.children[idx],
												context
											)
										);
									}
								});
						} else if (options.children !== true) {
							const childFactory = compilation.createStatsFactory(
								compilation.createStatsOptions(options.children, context)
							);
							stats.hooks.getItemFactory
								.for("compilation.children[].compilation")
								.tap("DefaultStatsFactoryPlugin", () => {
									return childFactory;
								});
						}
					}
				}
			);
		});
	}
}
module.exports = DefaultStatsFactoryPlugin;
