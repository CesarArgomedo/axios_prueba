/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { SyncWaterfallHook, SyncHook, SyncBailHook } = require("tapable");
const vm = require("vm");
const {
	ConcatSource,
	OriginalSource,
	PrefixSource,
	RawSource,
	CachedSource
} = require("webpack-sources");
const Compilation = require("../Compilation");
const { tryRunOrWebpackError } = require("../HookWebpackError");
const HotUpdateChunk = require("../HotUpdateChunk");
const InitFragment = require("../InitFragment");
const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_DYNAMIC,
	JAVASCRIPT_MODULE_TYPE_ESM
} = require("../ModuleTypeConstants");
const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const { last, someInIterable } = require("../util/IterableHelpers");
const StringXor = require("../util/StringXor");
const { compareModulesByIdentifier } = require("../util/comparators");
const createHash = require("../util/createHash");
const nonNumericOnlyHash = require("../util/nonNumericOnlyHash");
const { intersectRuntime } = require("../util/runtime");
const JavascriptGenerator = require("./JavascriptGenerator");
const JavascriptParser = require("./JavascriptParser");

/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../CodeGenerationResults")} CodeGenerationResults */
/** @typedef {import("../Compilation").ChunkHashContext} ChunkHashContext */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../DependencyTemplates")} DependencyTemplates */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("../util/Hash")} Hash */

/**
 * @param {Chunk} chunk a chunk
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @returns {boolean} true, when a JS file is needed for this chunk
 */
const chunkHasJs = (chunk, chunkGraph) => {
	if (chunkGraph.getNumberOfEntryModules(chunk) > 0) return true;

	return chunkGraph.getChunkModulesIterableBySourceType(chunk, "javascript")
		? true
		: false;
};

const printGeneratedCodeForStack = (module, code) => {
	const lines = code.split("\n");
	const n = `${lines.length}`.length;
	return `\n\nGenerated code for ${module.identifier()}\n${lines
		.map((line, i, lines) => {
			const iStr = `${i + 1}`;
			return `${" ".repeat(n - iStr.length)}${iStr} | ${line}`;
		})
		.join("\n")}`;
};

/**
 * @typedef {Object} RenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {boolean} strictMode rendering in strict context
 */

/**
 * @typedef {Object} MainRenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {string} hash hash to be used for render call
 * @property {boolean} strictMode rendering in strict context
 */

/**
 * @typedef {Object} ChunkRenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {InitFragment<ChunkRenderContext>[]} chunkInitFragments init fragments for the chunk
 * @property {boolean} strictMode rendering in strict context
 */

/**
 * @typedef {Object} RenderBootstrapContext
 * @property {Chunk} chunk the chunk
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {string} hash hash to be used for render call
 */

/** @typedef {RenderContext & { inlined: boolean }} StartupRenderContext */

/**
 * @typedef {Object} CompilationHooks
 * @property {SyncWaterfallHook<[Source, Module, ChunkRenderContext]>} renderModuleContent
 * @property {SyncWaterfallHook<[Source, Module, ChunkRenderContext]>} renderModuleContainer
 * @property {SyncWaterfallHook<[Source, Module, ChunkRenderContext]>} renderModulePackage
 * @property {SyncWaterfallHook<[Source, RenderContext]>} renderChunk
 * @property {SyncWaterfallHook<[Source, RenderContext]>} renderMain
 * @property {SyncWaterfallHook<[Source, RenderContext]>} renderContent
 * @property {SyncWaterfallHook<[Source, RenderContext]>} render
 * @property {SyncWaterfallHook<[Source, Module, StartupRenderContext]>} renderStartup
 * @property {SyncWaterfallHook<[string, RenderBootstrapContext]>} renderRequire
 * @property {SyncBailHook<[Module, RenderBootstrapContext], string>} inlineInRuntimeBailout
 * @property {SyncBailHook<[Module, RenderContext], string>} embedInRuntimeBailout
 * @property {SyncBailHook<[RenderContext], string>} strictRuntimeBailout
 * @property {SyncHook<[Chunk, Hash, ChunkHashContext]>} chunkHash
 * @property {SyncBailHook<[Chunk, RenderContext], boolean>} useSourceMap
 */

/** @type {WeakMap<Compilation, CompilationHooks>} */
const compilationHooksMap = new WeakMap();

const PLUGIN_NAME = "JavascriptModulesPlugin";

class JavascriptModulesPlugin {
	/**
	 * @param {Compilation} compilation the compilation
	 * @returns {CompilationHooks} the attached hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				"The 'compilation' argument must be an instance of Compilation"
			);
		}
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				renderModuleContent: new SyncWaterfallHook([
					"source",
					"module",
					"renderContext"
				]),
				renderModuleContainer: new SyncWaterfallHook([
					"source",
					"module",
					"renderContext"
				]),
				renderModulePackage: new SyncWaterfallHook([
					"source",
					"module",
					"renderContext"
				]),
				render: new SyncWaterfallHook(["source", "renderContext"]),
				renderContent: new SyncWaterfallHook(["source", "renderContext"]),
				renderStartup: new SyncWaterfallHook([
					"source",
					"module",
					"startupRenderContext"
				]),
				renderChunk: new SyncWaterfallHook(["source", "renderContext"]),
				renderMain: new SyncWaterfallHook(["source", "renderContext"]),
				renderRequire: new SyncWaterfallHook(["code", "renderContext"]),
				inlineInRuntimeBailout: new SyncBailHook(["module", "renderContext"]),
				embedInRuntimeBailout: new SyncBailHook(["module", "renderContext"]),
				strictRuntimeBailout: new SyncBailHook(["renderContext"]),
				chunkHash: new SyncHook(["chunk", "hash", "context"]),
				useSourceMap: new SyncBailHook(["chunk", "renderContext"])
			};
			compilationHooksMap.set(compilation, hooks);
		}
		return hooks;
	}

	constructor(options = {}) {
		this.options = options;
		/** @type {WeakMap<Source, TODO>} */
		this._moduleFactoryCache = new WeakMap();
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory }) => {
				const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
				normalModuleFactory.hooks.createParser
					.for(JAVASCRIPT_MODULE_TYPE_AUTO)
					.tap(PLUGIN_NAME, options => {
						return new JavascriptParser("auto");
					});
				normalModuleFactory.hooks.createParser
					.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)
					.tap(PLUGIN_NAME, options => {
						return new JavascriptParser("script");
					});
				normalModuleFactory.hooks.createParser
					.for(JAVASCRIPT_MODULE_TYPE_ESM)
					.tap(PLUGIN_NAME, options => {
						return new JavascriptParser("module");
					});
				normalModuleFactory.hooks.createGenerator
					.for(JAVASCRIPT_MODULE_TYPE_AUTO)
					.tap(PLUGIN_NAME, () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)
					.tap(PLUGIN_NAME, () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for(JAVASCRIPT_MODULE_TYPE_ESM)
					.tap(PLUGIN_NAME, () => {
						return new JavascriptGenerator();
					});
				compilation.hooks.renderManifest.tap(PLUGIN_NAME, (result, options) => {
					const {
						hash,
						chunk,
						chunkGraph,
						moduleGraph,
						runtimeTemplate,
						dependencyTemplates,
						outputOptions,
						codeGenerationResults
					} = options;

					const hotUpdateChunk = chunk instanceof HotUpdateChunk ? chunk : null;

					let render;
					const filenameTemplate =
						JavascriptModulesPlugin.getChunkFilenameTemplate(
							chunk,
							outputOptions
						);
					if (hotUpdateChunk) {
						render = () =>
							this.renderChunk(
								{
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								},
								hooks
							);
					} else if (chunk.hasRuntime()) {
						render = () =>
							this.renderMain(
								{
									hash,
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								},
								hooks,
								compilation
							);
					} else {
						if (!chunkHasJs(chunk, chunkGraph)) {
							return result;
						}

						render = () =>
							this.renderChunk(
								{
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								},
								hooks
							);
					}

					result.push({
						render,
						filenameTemplate,
						pathOptions: {
							hash,
							runtime: chunk.runtime,
							chunk,
							contentHashType: "javascript"
						},
						info: {
							javascriptModule: compilation.runtimeTemplate.isModule()
						},
						identifier: hotUpdateChunk
							? `hotupdatechunk${chunk.id}`
							: `chunk${chunk.id}`,
						hash: chunk.contentHash.javascript
					});

					return result;
				});
				compilation.hooks.chunkHash.tap(PLUGIN_NAME, (chunk, hash, context) => {
					hooks.chunkHash.call(chunk, hash, context);
					if (chunk.hasRuntime()) {
						this.updateHashWithBootstrap(
							hash,
							{
								hash: "0000",
								chunk,
								codeGenerationResults: context.codeGenerationResults,
								chunkGraph: context.chunkGraph,
								moduleGraph: context.moduleGraph,
								runtimeTemplate: context.runtimeTemplate
							},
							hooks
						);
					}
				});
				compilation.hooks.contentHash.tap(PLUGIN_NAME, chunk => {
					const {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate,
						outputOptions: {
							hashSalt,
							hashDigest,
							hashDigestLength,
							hashFunction
						}
					} = compilation;
					const hash = createHash(hashFunction);
					if (hashSalt) hash.update(hashSalt);
					if (chunk.hasRuntime()) {
						this.updateHashWithBootstrap(
							hash,
							{
								hash: "0000",
								chunk,
								codeGenerationResults,
								chunkGraph: compilation.chunkGraph,
								moduleGraph: compilation.moduleGraph,
								runtimeTemplate: compilation.runtimeTemplate
							},
							hooks
						);
					} else {
						hash.update(`${chunk.id} `);
						hash.update(chunk.ids ? chunk.ids.join(",") : "");
					}
					hooks.chunkHash.call(chunk, hash, {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate
					});
					const modules = chunkGraph.getChunkModulesIterableBySourceType(
						chunk,
						"javascript"
					);
					if (modules) {
						const xor = new StringXor();
						for (const m of modules) {
							xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
						}
						xor.updateHash(hash);
					}
					const runtimeModules = chunkGraph.getChunkModulesIterableBySourceType(
						chunk,
						"runtime"
					);
					if (runtimeModules) {
						const xor = new StringXor();
						for (const m of runtimeModules) {
							xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
						}
						xor.updateHash(hash);
					}
					const digest = /** @type {string} */ (hash.digest(hashDigest));
					chunk.contentHash.javascript = nonNumericOnlyHash(
						digest,
						hashDigestLength
					);
				});
				compilation.hooks.additionalTreeRuntimeRequirements.tap(
					PLUGIN_NAME,
					(chunk, set, { chunkGraph }) => {
						if (
							!set.has(RuntimeGlobals.startupNoDefault) &&
							chunkGraph.hasChunkEntryDependentChunks(chunk)
						) {
							set.add(RuntimeGlobals.onChunksLoaded);
							set.add(RuntimeGlobals.require);
						}
					}
				);
				compilation.hooks.executeModule.tap(PLUGIN_NAME, (options, context) => {
					const source = options.codeGenerationResult.sources.get("javascript");
					if (source === undefined) return;
					const { module, moduleObject } = options;
					const code = source.source();

					const fn = vm.runInThisContext(
						`(function(${module.moduleArgument}, ${module.exportsArgument}, __webpack_require__) {\n${code}\n/**/})`,
						{
							filename: module.identifier(),
							lineOffset: -1
						}
					);
					try {
						fn.call(
							moduleObject.exports,
							moduleObject,
							moduleObject.exports,
							context.__webpack_require__
						);
					} catch (e) {
						e.stack += printGeneratedCodeForStack(options.module, code);
						throw e;
					}
				});
				compilation.hooks.executeModule.tap(PLUGIN_NAME, (options, context) => {
					const source = options.codeGenerationResult.sources.get("runtime");
					if (source === undefined) return;
					let code = source.source();
					if (typeof code !== "string") code = code.toString();

					const fn = vm.runInThisContext(
						`(function(__webpack_require__) {\n${code}\n/**/})`,
						{
							filename: options.module.identifier(),
							lineOffset: -1
						}
					);
					try {
						fn.call(null, context.__webpack_require__);
					} catch (e) {
						e.stack += printGeneratedCodeForStack(options.module, code);
						throw e;
					}
				});
			}
		);
	}

	static getChunkFilenameTemplate(chunk, outputOptions) {
		if (chunk.filenameTemplate) {
			return chunk.filenameTemplate;
		} else if (chunk instanceof HotUpdateChunk) {
			return outputOptions.hotUpdateChunkFilename;
		} else if (chunk.canBeInitial()) {
			return outputOptions.filename;
		} else {
			return outputOptions.chunkFilename;
		}
	}

	/**
	 * @param {Module} module the rendered module
	 * @param {ChunkRenderContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @param {boolean} factory true: renders as factory method, false: pure module content
	 * @returns {Source} the newly generated source from rendering
	 */
	renderModule(module, renderContext, hooks, factory) {
		const {
			chunk,
			chunkGraph,
			runtimeTemplate,
			codeGenerationResults,
			strictMode
		} = renderContext;
		try {
			const codeGenResult = codeGenerationResults.get(module, chunk.runtime);
			const moduleSource = codeGenResult.sources.get("javascript");
			if (!moduleSource) return null;
			if (codeGenResult.data !== undefined) {
				const chunkInitFragments = codeGenResult.data.get("chunkInitFragments");
				if (chunkInitFragments) {
					for (const i of chunkInitFragments)
						renderContext.chunkInitFragments.push(i);
				}
			}
			const moduleSourcePostContent = tryRunOrWebpackError(
				() =>
					hooks.renderModuleContent.call(moduleSource, module, renderContext),
				"JavascriptModulesPlugin.getCompilationHooks().renderModuleContent"
			);
			let moduleSourcePostContainer;
			if (factory) {
				const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(
					module,
					chunk.runtime
				);
				const needModule = runtimeRequirements.has(RuntimeGlobals.module);
				const needExports = runtimeRequirements.has(RuntimeGlobals.exports);
				const needRequire =
					runtimeRequirements.has(RuntimeGlobals.require) ||
					runtimeRequirements.has(RuntimeGlobals.requireScope);
				const needThisAsExports = runtimeRequirements.has(
					RuntimeGlobals.thisAsExports
				);
				const needStrict = module.buildInfo.strict && !strictMode;
				const cacheEntry = this._moduleFactoryCache.get(
					moduleSourcePostContent
				);
				let source;
				if (
					cacheEntry &&
					cacheEntry.needModule === needModule &&
					cacheEntry.needExports === needExports &&
					cacheEntry.needRequire === needRequire &&
					cacheEntry.needThisAsExports === needThisAsExports &&
					cacheEntry.needStrict === needStrict
				) {
					source = cacheEntry.source;
				} else {
					const factorySource = new ConcatSource();
					const args = [];
					if (needExports || needRequire || needModule)
						args.push(
							needModule
								? module.moduleArgument
								: "__unused_webpack_" + module.moduleArgument
						);
					if (needExports || needRequire)
						args.push(
							needExports
								? module.exportsArgument
								: "__unused_webpack_" + module.exportsArgument
						);
					if (needRequire) args.push("__webpack_require__");
					if (!needThisAsExports && runtimeTemplate.supportsArrowFunction()) {
						factorySource.add("/***/ ((" + args.join(", ") + ") => {\n\n");
					} else {
						factorySource.add("/***/ (function(" + args.join(", ") + ") {\n\n");
					}
					if (needStrict) {
						factorySource.add('"use strict";\n');
					}
					factorySource.add(moduleSourcePostContent);
					factorySource.add("\n\n/***/ })");
					source = new CachedSource(factorySource);
					this._moduleFactoryCache.set(moduleSourcePostContent, {
						source,
						needModule,
						needExports,
						needRequire,
						needThisAsExports,
						needStrict
					});
				}
				moduleSourcePostContainer = tryRunOrWebpackError(
					() => hooks.renderModuleContainer.call(source, module, renderContext),
					"JavascriptModulesPlugin.getCompilationHooks().renderModuleContainer"
				);
			} else {
				moduleSourcePostContainer = moduleSourcePostContent;
			}
			return tryRunOrWebpackError(
				() =>
					hooks.renderModulePackage.call(
						moduleSourcePostContainer,
						module,
						renderContext
					),
				"JavascriptModulesPlugin.getCompilationHooks().renderModulePackage"
			);
		} catch (e) {
			e.module = module;
			throw e;
		}
	}

	/**
	 * @param {RenderContext} renderContext the render context
	 * @param {CompilationHooks} hooks hooks
	 * @returns {Source} the rendered source
	 */
	renderChunk(renderContext, hooks) {
		const { chunk, chunkGraph } = renderContext;
		const modules = chunkGraph.getOrderedChunkModulesIterableBySourceType(
			chunk,
			"javascript",
			compareModulesByIdentifier
		);
		const allModules = modules ? Array.from(modules) : [];
		let strictHeader;
		let allStrict = renderContext.strictMode;
		if (!allStrict && allModules.every(m => m.buildInfo.strict)) {
			const strictBailout = hooks.strictRuntimeBailout.call(renderContext);
			strictHeader = strictBailout
				? `// runtime can't be in strict mode because ${strictBailout}.\n`
				: '"use strict";\n';
			if (!strictBailout) allStrict = true;
		}
		/** @type {ChunkRenderContext} */
		const chunkRenderContext = {
			...renderContext,
			chunkInitFragments: [],
			strictMode: allStrict
		};
		const moduleSources =
			Template.renderChunkModules(chunkRenderContext, allModules, module =>
				this.renderModule(module, chunkRenderContext, hooks, true)
			) || new RawSource("{}");
		let source = tryRunOrWebpackError(
			() => hooks.renderChunk.call(moduleSources, chunkRenderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderChunk"
		);
		source = tryRunOrWebpackError(
			() => hooks.renderContent.call(source, chunkRenderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderContent"
		);
		if (!source) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something"
			);
		}
		source = InitFragment.addToSource(
			source,
			chunkRenderContext.chunkInitFragments,
			chunkRenderContext
		);
		source = tryRunOrWebpackError(
			() => hooks.render.call(source, chunkRenderContext),
			"JavascriptModulesPlugin.getCompilationHooks().render"
		);
		if (!source) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something"
			);
		}
		chunk.rendered = true;
		return strictHeader
			? new ConcatSource(strictHeader, source, ";")
			: renderContext.runtimeTemplate.isModule()
			? source
			: new ConcatSource(source, ";");
	}

	/**
	 * @param {MainRenderContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @param {Compilation} compilation the compilation
	 * @returns {Source} the newly generated source from rendering
	 */
	renderMain(renderContext, hooks, compilation) {
		const { chunk, chunkGraph, runtimeTemplate } = renderContext;

		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);
		const iife = runtimeTemplate.isIIFE();

		const bootstrap = this.renderBootstrap(renderContext, hooks);
		const useSourceMap = hooks.useSourceMap.call(chunk, renderContext);

		const allModules = Array.from(
			chunkGraph.getOrderedChunkModulesIterableBySourceType(
				chunk,
				"javascript",
				compareModulesByIdentifier
			) || []
		);

		const hasEntryModules = chunkGraph.getNumberOfEntryModules(chunk) > 0;
		let inlinedModules;
		if (bootstrap.allowInlineStartup && hasEntryModules) {
			inlinedModules = new Set(chunkGraph.getChunkEntryModulesIterable(chunk));
		}

		let source = new ConcatSource();
		let prefix;
		if (iife) {
			if (runtimeTemplate.supportsArrowFunction()) {
				source.add("/******/ (() => { // webpackBootstrap\n");
			} else {
				source.add("/******/ (function() { // webpackBootstrap\n");
			}
			prefix = "/******/ \t";
		} else {
			prefix = "/******/ ";
		}
		let allStrict = renderContext.strictMode;
		if (!allStrict && allModules.every(m => m.buildInfo.strict)) {
			const strictBailout = hooks.strictRuntimeBailout.call(renderContext);
			if (strictBailout) {
				source.add(
					prefix +
						`// runtime can't be in strict mode because ${strictBailout}.\n`
				);
			} else {
				allStrict = true;
				source.add(prefix + '"use strict";\n');
			}
		}

		/** @type {ChunkRenderContext} */
		const chunkRenderContext = {
			...renderContext,
			chunkInitFragments: [],
			strictMode: allStrict
		};

		const chunkModules = Template.renderChunkModules(
			chunkRenderContext,
			inlinedModules
				? allModules.filter(m => !inlinedModules.has(m))
				: allModules,
			module => this.renderModule(module, chunkRenderContext, hooks, true),
			prefix
		);
		if (
			chunkModules ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactories) ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly) ||
			runtimeRequirements.has(RuntimeGlobals.require)
		) {
			source.add(prefix + "var __webpack_modules__ = (");
			source.add(chunkModules || "{}");
			source.add(");\n");
			source.add(
				"/************************************************************************/\n"
			);
		}

		if (bootstrap.header.length > 0) {
			const header = Template.asString(bootstrap.header) + "\n";
			source.add(
				new PrefixSource(
					prefix,
					useSourceMap
						? new OriginalSource(header, "webpack/bootstrap")
						: new RawSource(header)
				)
			);
			source.add(
				"/************************************************************************/\n"
			);
		}

		const runtimeModules =
			renderContext.chunkGraph.getChunkRuntimeModulesInOrder(chunk);

		if (runtimeModules.length > 0) {
			source.add(
				new PrefixSource(
					prefix,
					Template.renderRuntimeModules(runtimeModules, chunkRenderContext)
				)
			);
			source.add(
				"/************************************************************************/\n"
			);
			// runtimeRuntimeModules calls codeGeneration
			for (const module of runtimeModules) {
				compilation.codeGeneratedModules.add(module);
			}
		}
		if (inlinedModules) {
			if (bootstrap.beforeStartup.length > 0) {
				const beforeStartup = Template.asString(bootstrap.beforeStartup) + "\n";
				source.add(
					new PrefixSource(
						prefix,
						useSourceMap
							? new OriginalSource(beforeStartup, "webpack/before-startup")
							: new RawSource(beforeStartup)
					)
				);
			}
			const lastInlinedModule = last(inlinedModules);
			const startupSource = new ConcatSource();
			startupSource.add(`var __webpack_exports__ = {};\n`);
			for (const m of inlinedModules) {
				const renderedModule = this.renderModule(
					m,
					chunkRenderContext,
					hooks,
					false
				);
				if (renderedModule) {
					const innerStrict = !allStrict && m.buildInfo.strict;
					const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(
						m,
						chunk.runtime
					);
					const exports = runtimeRequirements.has(RuntimeGlobals.exports);
					const webpackExports =
						exports && m.exportsArgument === "__webpack_exports__";
					let iife = innerStrict
						? "it need to be in strict mode."
						: inlinedModules.size > 1
						? // TODO check globals and top-level declarations of other entries and chunk modules
						  // to make a better decision
						  "it need to be isolated against other entry modules."
						: chunkModules
						? "it need to be isolated against other modules in the chunk."
						: exports && !webpackExports
						? `it uses a non-standard name for the exports (${m.exportsArgument}).`
						: hooks.embedInRuntimeBailout.call(m, renderContext);
					let footer;
					if (iife !== undefined) {
						startupSource.add(
							`// This entry need to be wrapped in an IIFE because ${iife}\n`
						);
						const arrow = runtimeTemplate.supportsArrowFunction();
						if (arrow) {
							startupSource.add("(() => {\n");
							footer = "\n})();\n\n";
						} else {
							startupSource.add("!function() {\n");
							footer = "\n}();\n";
						}
						if (innerStrict) startupSource.add('"use strict";\n');
					} else {
						footer = "\n";
					}
					if (exports) {
						if (m !== lastInlinedModule)
							startupSource.add(`var ${m.exportsArgument} = {};\n`);
						else if (m.exportsArgument !== "__webpack_exports__")
							startupSource.add(
								`var ${m.exportsArgument} = __webpack_exports__;\n`
							);
					}
					startupSource.add(renderedModule);
					startupSource.add(footer);
				}
			}
			if (runtimeRequirements.has(RuntimeGlobals.onChunksLoaded)) {
				startupSource.add(
					`__webpack_exports__ = ${RuntimeGlobals.onChunksLoaded}(__webpack_exports__);\n`
				);
			}
			source.add(
				hooks.renderStartup.call(startupSource, lastInlinedModule, {
					...renderContext,
					inlined: true
				})
			);
			if (bootstrap.afterStartup.length > 0) {
				const afterStartup = Template.asString(bootstrap.afterStartup) + "\n";
				source.add(
					new PrefixSource(
						prefix,
						useSourceMap
							? new OriginalSource(afterStartup, "webpack/after-startup")
							: new RawSource(afterStartup)
					)
				);
			}
		} else {
			const lastEntryModule = last(
				chunkGraph.getChunkEntryModulesIterable(chunk)
			);
			const toSource = useSourceMap
				? (content, name) =>
						new OriginalSource(Template.asString(content), name)
				: content => new RawSource(Template.asString(content));
			source.add(
				new PrefixSource(
					prefix,
					new ConcatSource(
						toSource(bootstrap.beforeStartup, "webpack/before-startup"),
						"\n",
						hooks.renderStartup.call(
							toSource(bootstrap.startup.concat(""), "webpack/startup"),
							lastEntryModule,
							{
								...renderContext,
								inlined: false
							}
						),
						toSource(bootstrap.afterStartup, "webpack/after-startup"),
						"\n"
					)
				)
			);
		}
		if (
			hasEntryModules &&
			runtimeRequirements.has(RuntimeGlobals.returnExportsFromRuntime)
		) {
			source.add(`${prefix}return __webpack_exports__;\n`);
		}
		if (iife) {
			source.add("/******/ })()\n");
		}

		/** @type {Source} */
		let finalSource = tryRunOrWebpackError(
			() => hooks.renderMain.call(source, renderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderMain"
		);
		if (!finalSource) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderMain plugins should return something"
			);
		}
		finalSource = tryRunOrWebpackError(
			() => hooks.renderContent.call(finalSource, renderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderContent"
		);
		if (!finalSource) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something"
			);
		}
		finalSource = InitFragment.addToSource(
			finalSource,
			chunkRenderContext.chunkInitFragments,
			chunkRenderContext
		);
		finalSource = tryRunOrWebpackError(
			() => hooks.render.call(finalSource, renderContext),
			"JavascriptModulesPlugin.getCompilationHooks().render"
		);
		if (!finalSource) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something"
			);
		}
		chunk.rendered = true;
		return iife ? new ConcatSource(finalSource, ";") : finalSource;
	}

	/**
	 * @param {Hash} hash the hash to be updated
	 * @param {RenderBootstrapContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 */
	updateHashWithBootstrap(hash, renderContext, hooks) {
		const bootstrap = this.renderBootstrap(renderContext, hooks);
		for (const key of Object.keys(bootstrap)) {
			hash.update(key);
			if (Array.isArray(bootstrap[key])) {
				for (const line of bootstrap[key]) {
					hash.update(line);
				}
			} else {
				hash.update(JSON.stringify(bootstrap[key]));
			}
		}
	}

	/**
	 * @param {RenderBootstrapContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @returns {{ header: string[], beforeStartup: string[], startup: string[], afterStartup: string[], allowInlineStartup: boolean }} the generated source of the bootstrap code
	 */
	renderBootstrap(renderContext, hooks) {
		const {
			chunkGraph,
			codeGenerationResults,
			moduleGraph,
			chunk,
			runtimeTemplate
		} = renderContext;

		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);

		const requireFunction = runtimeRequirements.has(RuntimeGlobals.require);
		const moduleCache = runtimeRequirements.has(RuntimeGlobals.moduleCache);
		const moduleFactories = runtimeRequirements.has(
			RuntimeGlobals.moduleFactories
		);
		const moduleUsed = runtimeRequirements.has(RuntimeGlobals.module);
		const requireScopeUsed = runtimeRequirements.has(
			RuntimeGlobals.requireScope
		);
		const interceptModuleExecution = runtimeRequirements.has(
			RuntimeGlobals.interceptModuleExecution
		);

		const useRequire =
			requireFunction || interceptModuleExecution || moduleUsed;

		const result = {
			header: [],
			beforeStartup: [],
			startup: [],
			afterStartup: [],
			allowInlineStartup: true
		};

		let { header: buf, startup, beforeStartup, afterStartup } = result;

		if (result.allowInlineStartup && moduleFactories) {
			startup.push(
				"// module factories are used so entry inlining is disabled"
			);
			result.allowInlineStartup = false;
		}
		if (result.allowInlineStartup && moduleCache) {
			startup.push("// module cache are used so entry inlining is disabled");
			result.allowInlineStartup = false;
		}
		if (result.allowInlineStartup && interceptModuleExecution) {
			startup.push(
				"// module execution is intercepted so entry inlining is disabled"
			);
			result.allowInlineStartup = false;
		}

		if (useRequire || moduleCache) {
			buf.push("// The module cache");
			buf.push("var __webpack_module_cache__ = {};");
			buf.push("");
		}

		if (useRequire) {
			buf.push("// The require function");
			buf.push(`function __webpack_require__(moduleId) {`);
			buf.push(Template.indent(this.renderRequire(renderContext, hooks)));
			buf.push("}");
			buf.push("");
		} else if (runtimeRequirements.has(RuntimeGlobals.requireScope)) {
			buf.push("// The require scope");
			buf.push("var __webpack_require__ = {};");
			buf.push("");
		}

		if (
			moduleFactories ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly)
		) {
			buf.push("// expose the modules object (__webpack_modules__)");
			buf.push(`${RuntimeGlobals.moduleFactories} = __webpack_modules__;`);
			buf.push("");
		}

		if (moduleCache) {
			buf.push("// expose the module cache");
			buf.push(`${RuntimeGlobals.moduleCache} = __webpack_module_cache__;`);
			buf.push("");
		}

		if (interceptModuleExecution) {
			buf.push("// expose the module execution interceptor");
			buf.push(`${RuntimeGlobals.interceptModuleExecution} = [];`);
			buf.push("");
		}

		if (!runtimeRequirements.has(RuntimeGlobals.startupNoDefault)) {
			if (chunkGraph.getNumberOfEntryModules(chunk) > 0) {
				/** @type {string[]} */
				const buf2 = [];
				const runtimeRequirements =
					chunkGraph.getTreeRuntimeRequirements(chunk);
				buf2.push("// Load entry module and return exports");
				let i = chunkGraph.getNumberOfEntryModules(chunk);
				for (const [
					entryModule,
					entrypoint
				] of chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)) {
					const chunks = entrypoint.chunks.filter(c => c !== chunk);
					if (result.allowInlineStartup && chunks.length > 0) {
						buf2.push(
							"// This entry module depends on other loaded chunks and execution need to be delayed"
						);
						result.allowInlineStartup = false;
					}
					if (
						result.allowInlineStartup &&
						someInIterable(
							moduleGraph.getIncomingConnectionsByOriginModule(entryModule),
							([originModule, connections]) =>
								originModule &&
								connections.some(c => c.isTargetActive(chunk.runtime)) &&
								someInIterable(
									chunkGraph.getModuleRuntimes(originModule),
									runtime =>
										intersectRuntime(runtime, chunk.runtime) !== undefined
								)
						)
					) {
						buf2.push(
							"// This entry module is referenced by other modules so it can't be inlined"
						);
						result.allowInlineStartup = false;
					}

					let data;
					if (codeGenerationResults.has(entryModule, chunk.runtime)) {
						const result = codeGenerationResults.get(
							entryModule,
							chunk.runtime
						);
						data = result.data;
					}
					if (
						result.allowInlineStartup &&
						(!data || !data.get("topLevelDeclarations")) &&
						(!entryModule.buildInfo ||
							!entryModule.buildInfo.topLevelDeclarations)
					) {
						buf2.push(
							"// This entry module doesn't tell about it's top-level declarations so it can't be inlined"
						);
						result.allowInlineStartup = false;
					}
					if (result.allowInlineStartup) {
						const bailout = hooks.inlineInRuntimeBailout.call(
							entryModule,
							renderContext
						);
						if (bailout !== undefined) {
							buf2.push(
								`// This entry module can't be inlined because ${bailout}`
							);
							result.allowInlineStartup = false;
						}
					}
					i--;
					const moduleId = chunkGraph.getModuleId(entryModule);
					const entryRuntimeRequirements =
						chunkGraph.getModuleRuntimeRequirements(entryModule, chunk.runtime);
					let moduleIdExpr = JSON.stringify(moduleId);
					if (runtimeRequirements.has(RuntimeGlobals.entryModuleId)) {
						moduleIdExpr = `${RuntimeGlobals.entryModuleId} = ${moduleIdExpr}`;
					}
					if (
						result.allowInlineStartup &&
						entryRuntimeRequirements.has(RuntimeGlobals.module)
					) {
						result.allowInlineStartup = false;
						buf2.push(
							"// This entry module used 'module' so it can't be inlined"
						);
					}
					if (chunks.length > 0) {
						buf2.push(
					œq‡ä±;¨“ÎpøÊlW—ôœ¾xƒEpÉ7j;»"E<Ì2ƒ¬›d£'f^¶Â^`nx6± üó36²Şaæƒ\>¶R¬B°Ø!'”Ìä±Næ‚ºX.¹Xş¹ğ{±"=yCŒYƒZ‡Ai/Õ‚»¶ïaKoƒr~Š³4,ƒ}bé­ÔƒUB2\Â¦èbe¬òy¡­ˆÈ'Ã<ŸŒQ>è§Æå 2…•C‰n1Fª-[‹Q}º8•×Å©tº®l¦¡d¦¡\¦¡”ÀŸÖóxHi$±´˜_´›Îç€÷H†ydŒcB›=‘n€ğ^óù–åeŒÒFâÌ¶&“RÌ)µÔ+¤4¤« Í^Ôİ°Ùø•*ãƒT•YIáx1@"q9§ìlædç0Gµ¶C€¡]‡À±µ¨1¬–ÃZk‰Â;=–Si+ÌP¯¨ÛvSØ¶t!Q²î€õ vÀ\ [q·:.Ş¦ƒA¿Ü3êPnÂojïÿ¡…:å`Ta“ZaX4è€ŒAápŠÄK(PIM §Sw›\Å½€|¤yº¬ĞíaÍj¢óÅ4QİP6 ĞÛv€Ü…|q;Ø|IÄ·<G×? |]#$R—`OÚÊ1cÎ¤8±œ%&AÂV7ô¯‹Z‰TÖ¤~‡Dß< es±"mJXóÈÕC­xIğeÛEıuz©­1ÀˆJ‚2GÚI}èÃV¢ŠœÜnª»á‡$Ñ°ƒÕ³Y‚HÆ”ÅğëÈ9µB>Ï€ŠæÂô]]åEb­Mb‚ÔñÅør¹h2±l­-c7ĞòE$º‰4pDœ›Ö—Ï0ˆvÌÙ#hIE›¾° ÄVh»]%46¼P„üª9AHä…RŒSoàs·5éˆ†&oÒlÑÄ`"Qpn¢i‚ÜÃ[À1Ë•«Ò#f„…DDè#oÅOçVZ”AÁI0&ç9$Â‰ä[LòMëËìÑ÷0“/Á0Í)—8RÒ¬Ã^bßxŠ‡¹hvqa¬„lWWâ”&€i¹IWpĞ>S,{.Û5+ù‘jŒSr½ëŒPã]b=õ	Ä{ˆ]*³åë«ÈõP“únKTsn€äëÈòëºfœ"ä´8µ]ºò>"¥½Qc>ŞŸ6•ó`ÙhQT~ÈSÛit\0%ö¨8$,şÛë!c€
È.hMW'4ÜI‚ UµäM4àÁ#‚¡ñ5,i£ÊIúö‹‚Ä;$ó÷ê„óvabwgÓ\D¿ä$ãİüw;(ù¼¤fˆ¥İçÀd¤õ?œ´©jj´httçã‚ÊMd¦‰î¢>¡y¸¨5¯ UılÍ6´WuôYÿUÿ­.wèäå¿Ø¹lc›,;(ÖF˜!«š×'ÉöD¿^P‰J^’÷ÕOõ·««Å ’i£¯Y.Ô>=¾v.×ıD}’rZÖ¼èÛIóˆb]¢drš-ğ?ZÈ‘zh,Üˆ5¦sÁ-°='áÚÂ@3[¤›Û	I'ÔÜ8[óÖìjXÔZagÿgës¨¢ºSÇ´ZÉÅü|^ÅXÒ"D±Ë«¯ÑáPö!Líµ†»iî8oG qm¤0¸`Hû=r1ê×™lT2eL/Qì"k§4v’QpJÊõŠxë\2©`ÍGfÜ
mrµ‹„{fHßãt9]M7·P}Z…€#	k jäŠª©
•'«XdrÖ«ª; _3UØP½Ù¥Ãv®Şu€3ÁÎiŠƒ$ãá!š½A¥–í"…BSÿºêá
¥¦×Ç;4 ¯í‰­kj‘x‰ïbk|ş"‚ÊqÕu4ıßX§¶
5ÅØC}—Šb¢–±‚”YMfÆÙ	¹a1ouÒ„>VÒ¯¦—„“Šï ­4?ÑXWÇ.Ó‰£lÉ|Â‡‡èu›bÃÊ«q^wXû\"sX“ ÖFû©V:*òÜVD5›ÏQZ—Ø‹¢¸y¤O±Ì9¤KœE3ÁÆÌï…ş5êWjÅ<Ñ/)ÛØŞrµaìÍªı†£f“*5Ÿæ7.÷8„yâaEzÀœëÍr•ñ²Õ“©òğ~{è×X;Q¶¯0/&.`aZZæ>â¼—MIøàì8yÂ&Ë\z1G5kòW©²Ú‹ˆšõ´Ä×I2°ã˜ú*WŠ—-be,Ş a#å¼ÏÒ­±Yä"
/ÓyÂ(ëßÔ¢s´‚MÃ};Ö£ÚÏ­B©áË]2|·ªöö
&Àœ¤¬|hªq°3¡şbaíy¨~–Î±í#5ËEª“h±IõÔ'ôÒ9˜ßà+“bS"Z8&9£HÊIÎ’æ-Œ†áZ/©£bÉ&æˆ¯ë$üGˆ¸ıÂdHò#5u»‰¸KxR¸ÎRÀ<Z$æ% 4ĞIóFÇQ¡ôÎ„“<¬¶ZÌ|€Mb‰¾Ò ÔÒI}©xH±¨ÕÄF£*>Fz6¥òx6Ì¹ô:–‘×‘k8<dÇ±¡QÂ¶ÒIxåó:K1÷’xUİ­zN%}…Î2î#•sÙIJ`@GG]né€Ãõç`R,M©a¼–ö:…ûğİPMª7Ã9«jWëï2Ì„rE\sÈº¡¥…ñÆÄlb`ÿ¦bº´š(ÖOX«*^ésÄ)Œï§	'0{èó\ôQkª'ïG¥æNÕUÌwdl2y½<êq×Ó¼s”Z‘j"VgNï'èJXGÖ'v^¨¯õóUS>@+ª]ğ§äõ·©5:ˆF$¶'%÷Ìw^¦Ğra"rÕÂA}í9@{IKŸS/<…4œ_‰k£½¢zsÒ˜:Í°#at$ËYB9Ù¤âa?Ñ%VIg?ÜË«ã°Ö)öu¤,’’Ë%Flœ!ÍËf›k ÷´µ¬6ûÆÕSo‚ñJÿAg8[®P4Ğ%ÑÇæ¹Éòw[XZ@ÔÇú/ªNâã;\ÏJrıY#|½š ™^U“ÆJ„Ô]LxwXêİ‰Ô:&=ôŞ¸µw8]8o ± ™¥Şá›¸8#âVcãškìà.b$œÃéƒW8â[I÷×îÈ¨4…ªjôsF68Ñ£€Ëx`ß›F”nƒ?óàŞÊCõ)³IñS/k¨J¤¶Ø„ÙBX«ô¨bKï‚zÏ^@Ğ+®oú¥5ğ88õk3(U	M,j+=nĞ®°gñ¢½“HĞ#Ø&Ïï2ô‰só¡è,ÅªY£‡ê]SH$İ¤»Hd{T'½Qj»0—Îu 5z½ƒ™ vóöÚaÏGR›á£ÿÏÇ§|Ë=O=¶åå@uÊGÿ¦ÿL7¤ãe`ÜÊ}9wœi¿Lx"ÚÒÌ6J!V=GGºñK2^×D–ÓKhò	j7Ç¹À’©E§¹tû+²‡šC(¨:vÌ
..j&Û­MÙì¿²[iE»Ôu´Ç«¦UÍœ"	CQ÷±ú¯ŒÇÂáw'~W˜wfeÒı$ÆwJ.¹—¤ôŸ÷Ÿéš[FêÓÕsÈü«ÿ¼D&Ñ*Ğ\ØXÜO#%aº%I‚şĞ€¶X½Â¶ç»¡—Ï>¤]nvL‚fI<µ´
Ño^¸Ô³zÃ%:oÊãİl˜FëŒs)vQ£HÀ…»±Y¥·ÑdíGÄi=.Ãq#W+âğÖƒÙÖiÁ¤;°ÉpIÊäh*gl:Û9p_“×?ÃúI¥İ%2	{F'Ê‘J£·$¼{h_Æ¯™É] h\ü§zn¤Á¤n¤¯_ïTkMÀAXˆ7½^ÑE-Hî!'8ÍßY— ß²	=H] kU×%Ñ;iŸÛGÓèêáÓ¶–aŒ AMüğÃk^Ü?kë	ÇİõipÓƒèwRRŠb3Ã#w0³(8Êì0)Y<\OÏ¥1Yçõ_¢ä‰÷<óÈşWóúx,ŸY g^ÿgüõ“ypŞ9ŠÙîPçö¯ƒTF1hœõ)ötzğ—ŠY¯Ó…7)fU”0C—M6
æEÏÀfÙx_¢ë-Ø ïEnl0t*VQ³ƒåF¯´B÷í¹±›U4‘bÇª)˜ÃxSùLô4?G1™4‚åPïF°4·ğşb3…ù,7Gá£ÁDNhàĞQ›…Ì È€U!À…„‰	h*ÅXÜfãı¹÷3¥[Sm6/k†ñÛlé“Èb³eYM¼şÄ66¨mà¨ø˜7òìV«Ù†?»¹r(1_Œpƒ@Yÿfè0Ò}Oµ*¹3-Ö³-·¨Äd7[MæÜyH0öLê
ƒ2öt«	^¼¹l}
ü7C[¦5İœ‘™j±A%iéiĞŸÌ ÛÓ¬ğ°§§å®€!feÀäæ®È¤§}5‡»¦ë †N9çÃPSìi|hˆ®4«IÀpLE6«Åœf†æó¬©¹EúÚs'¶²l²òú·[X
t© G`¶X3l…)yı÷ù4˜³Íµ9æì”ÚœÀ‰‰µÿy%%¬CMM@Çs°‘±N@«İa¶eÃÿ›ÉêHQ
Sl6lršÒ­Ğ­T«%Í–nOX^ÿƒ¹ıbŸëøtFir 1ÿOPÇ7É±>!õ		Ø$ °©'ş<ÂššäÏ¡VLL"É$Ö
Ï™Ú*(!‘Yp%	ÁD¨N¤_YV«pQ›EÈ´¥0fKs¤"vG"1'…§ò•”sl½É¥QÁ\äFÇò)ÄY¸ê…¾ò…Œ½H³¦â|šù,™ÓXª’ÿpŒyıÏ(¼T:3‰¹³Ù°j-ÅX˜I)È1ÁØaq0E) åÆóã|èrçXMÚj³Ğ/“¸)§Y›EÀ<VñNµ =›,v«¨¦W™XÜœ uıâÒ³ã°ˆD“ÅÆÓ1ÂÙ/ñŒ4‡Â)ĞfBî’"áö¡¬paJ#Å”5çˆT'±à´"Ô\bPL?öÅ¸¢¼/&<Ú*sÛUéZW3ˆ±˜M#XªæÉ.gÏ6‚Y!ól†bƒ%b‚™µiù õ[€¹Y`â,ˆØ `³AÀP;DìÀ%MDg&KTiC^gÊ.›[Çé«Ğ2&Z„<šÉÉ­“³±@$ŒFĞ€×q¡ ’‘8[–…¡”ÌâÆœáP4\ša‰G'£iŠÁ!+A Ğ©Ğ`ÌvÌÈ÷7Rì‰òN €èpÅÄKG–¹˜;¯ÿ|’rgòª¹¸!t#Åæ3™Ú¨w ¸è{–˜P3Ú`y`#€äí
I{h&¯S1eá£ã`‰š3T	¼z˜`f:ÁÆ06MÈ¼”,˜ØÂ”lM,¢H„ÉIáÒ”–¼MäÍTÄsãŒå—²wœ
ÍœíîIwXlÈb`Â’ÈDéÁBG0!õm|<|ş6ˆ÷âr±ER:/:)Q€£0SGqk5åE+à?0Ñhƒ§X@'°ä+Ö¿ş#÷@1æEâÿU„§“H¥ŠD(­¢çtBãIù0; èd*æ¼ØÍğßn·™¸şµ(a&”ÏºhúgRÁ	¯áb£„š4¡¤™miBGƒ^#)GOQl"DI6ÙA"q3ÌÄ	c! /²Ä4®“Ó(øêXÔ‹¥¤œ-MÇázùà»y±Ûùÿ(“ƒFôÉ(»HuÔ?i¶00F¤
*HÌ™yLWb–ÍÔ•@İ;[ÇÿSŸê2ÿ'È<]­›´ªŒA]­B&“«ÊqÙdªYÿ”©æTK^ô	$x^›hZ›lH(À ëp¤Ğ$RÊÓåìöÜh	ÁN&ØÉÈëÌƒ­æ¼è¥6Ğ«‰ÙùÉ1¶=î3áóî.üb÷!íêRàÅät‚AEÆ‘ıR(ëZ`¡jMÛà¬¼è%hjÃœ;¡¸´9!¡}€ÆDè%`Ä¿í1d! O½&×š
yÑU¼=âSûhÌWÛh%äõ_Lƒ¿zœÕ«J õ97Ú¯GA¥_0ïèúl¬{IIâDÈÔœ|…(a	tŞ$ˆıÑ ±¡x…¯ F
.n¤Eû(%m$È½âş&İK mŞÆ-²¯ø¼ŞMğ»)|…o²"B1äË¥w%İ–cµäÅããÄ­G{õşÜØ3vG*˜RÏØ²
l4N|1áÂÀÇ<€b1t9Ùº7á#Ój“P®, •±°=6Y {×MªÕT`Ê²Iôsôo@Ó'“zÿ õşPÃì9v;±Â% #
ÆX­²…,5×CHˆ)&5–ŸcJQ\kÎ%İ®¥sj¢0gñ¸dû‰¤Êö4H¬TL( ¥ñê0,›	*° É/¶@êcaÄ, ­£Wb—ˆ*Tó¹¡d–˜g)Bş›L4îGlD¹ÑzBÀ#V´Ï –®ŠlÂFnôqJ$±İn·XSíør ÑóŠŞ•T¿2¾‹ëjö/“$²Œk›C¹½œNÏ/	ã»¸ôÆ9A`EE¹ˆÉ‹î¦ø…….Ô¿½ tEää€-Q¿6»	¥^ÿ>®_ªF^ ÛIé ©nWt5+¤	6 E-V1tPÜ„º“pXId‚º†…P°©Ò‚¬âm³ˆõeï‰V	¬0·4U§sı3ƒF/ÔUG^ÇUaE´Í›!´ÈMBİ@å‚‹WÕ8%‹qFÙÿ@ì1nØm0"ÖW? ¹ş Yï7JA®U ”º¥lÙlÌ¬äÅ¾´á/éÔIĞ¡2µf÷29–`± c«Ö‹_¢:aÊsØIÂò¦ü#wšLÂ`Š~Œê§EK³KìPˆ[d@½g/r}ÌQIï|à`Âd“o2çxvÙˆCVãPŒ5ÚU ™R*P³ifnWdU\N‘¯+/6J¸½d85GaœKJSñ)…¿ ğvªé—¨±f;R5•è×B´,j"ı=ÃšZh¶I-œæJrH†#W¢(Lºã®ƒG¹ï0QEy11?ÏF $JxlœI2İı\qq?‚bdWÄ¸Dùó&¨€2|GÀ)ü#eN¥Ì©¦JàiM>?Ğ3A!=XãÙqq*–AÅ2r­XæBeE±UŸe5ˆ%‚ó±@}IêÄ,±IñĞ¸(-YÈ•Ï%ËiMÕZ"ÄÄr$W®¦îåØÈÀËıƒ„éOÜ‰Dï,xWb®¤’ƒ¨À v\zÇ
P`ı™V‡p…vd¨>BnQåÆÆRÂX2.·gÙ­*78(ßVô!ß¤Uå¦ÓêE]Œª™HÕ€]™"(YĞ§¸F¸ÿs5‡x;6?Yƒè,)ùÌ4Tp%•'
	Dn’¾GÈfËĞªKØaÖÕŠ«ÉÈae–j–Ö4ÑYéÿ@N¦²´a$S>5ú0i¤ÕWÎf(hWİ¶<İHÅmğ#`miÃ—õÒUmƒã›•#“˜(~,6	‰A¹¬f»Í¦"Xåij#éjÏóYğjëº~¤Õ< ïÅB}3³Zmyç+¼ï¨ÂÕâ&&r1Eò<ñ4n(š…¡EìN“I§e,7:q´5š6$.§Á
çGÎUlĞ¯<WV+­ĞÁ¢r(Ák„@nÔ©­€j›p…%ƒÈôé
æ¼ş÷Öóú÷ »„÷{Üˆ~o”Õ±ÕT+T +¢öáÂO†m2S¦èêÑ™µÖl¬ºToSq‡‰õrŠ
êøÕ”o…g–ÍÕËæêµæêÁ”Ï¶bşµ¹Ñ¹ÑNœ$tšÈĞ^ê%4ÅYí_‹d`£¹²Ñ<RˆÏ•MNô½E=™¸×Z¡ÈÇ#·Óyf´ÙLÜ¬B;
,lñ¼4Ê½ÜçYYé‚u‚eÏDórz‰¬²*T×‚r£· ‹¸­ØÔ¦[1¨Ó¯‰{‘QO“1;ùHkt³ ô`Ş27hÉ¸ëñS`‚¥•"»E›;•SMvì6ö³;)º—€—oB?ıy…ÄàsÏËÌA!Ä7ºêÈÜ‹‘]ƒ-BxAæQ¸†Â5¤1WØp²®„vÒ‰U¡j3›‰0tœ÷íO®f¤K3t-—ëtòàªøŒLtwy´ËBJïÈ'€K7ª6/ú<•égµ¨~~j—ã,N'OAW£ªóË€Ú5k÷Ø„vkÎ“ÍÈİ“,Ûp«¦êo	Âğ·òíih„Å¾Ì=/iN´é§ªıi`0Öšå#äXSsëlº±Pb%vÙÉ[/`§.×š*ƒ‚VÀüÉi+<¦œdµ87ÚÁ'A]±:I“ÂcYF$Raà5ÑçÍ	|52ãTŒéOV=jë!¦,ãæØãæ4Sh¨|ì6Ò‹Ğ­‚¤¼š¶/2!ï¼á¨À»3%w'ê»ä±¡s¦ÆšŒâb¥¯ù>f6Æ‘yğ7ª KT¦„&0ØÀº•Û"Â!Èm“Å3¢®ŒèŠeÖLŞ°O»lÆ1Ä¯©„¬Jzˆ,Œor~øùÕùÔQcü$•ä'ik˜‰
•¶Ysp,A¹ÑÉtr¥èá9ƒà[ZpOœR@ïi³Á‡$p·‘¤Â}\*<HPhrc:ÉÓ=ÄÚÒuMsø[*\ö·¿”ü$½ÉOÒ.¬ßCmÑĞ³R’HPz·[2Ÿ›J>“F9rL7·¢ ¿X#G5¿ÌrÓV»hš(0©ˆ–y zÛH«Õv 5D§clë¿Ğ:+LÂë(@S$ˆ%ÜPA‡Ú?A$‚"
H&H3¡æa59l >ª”šddwç'KŞ-±}÷€IÓA‘xïdk†öi^: pñ½uŞë´À°NpÒ\_JZQı