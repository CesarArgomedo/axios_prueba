'use strict'

const Buffer = require('buffer').Buffer
const types = require('./types')
const rcodes = require('./rcodes')
const opcodes = require('./opcodes')
const classes = require('./classes')
const optioncodes = require('./optioncodes')
const ip = require('@leichtgewicht/ip-codec')

const QUERY_FLAG = 0
const RESPONSE_FLAG = 1 << 15
const FLUSH_MASK = 1 << 15
const NOT_FLUSH_MASK = ~FLUSH_MASK
const QU_MASK = 1 << 15
const NOT_QU_MASK = ~QU_MASK

const name = exports.name = {}

name.encode = function (str, buf, offset) {
  if (!buf) buf = Buffer.alloc(name.encodingLength(str))
  if (!offset) offset = 0
  const oldOffset = offset

  // strip leading and trailing .
  const n = str.replace(/^\.|\.$/gm, '')
  if (n.length) {
    const list = n.split('.')

    for (let i = 0; i < list.length; i++) {
      const len = buf.write(list[i], offset + 1)
      buf[offset] = len
      offset += len + 1
    }
  }

  buf[offset++] = 0

  name.encode.bytes = offset - oldOffset
  return buf
}

name.encode.bytes = 0

name.decode = function (buf, offset) {
  if (!offset) offset = 0

  const list = []
  let oldOffset = offset
  let totalLength = 0
  let consumedBytes = 0
  let jumped = false

  while (true) {
    if (offset >= buf.length) {
      throw new Error('Cannot decode name (buffer overflow)')
    }
    const len = buf[offset++]
    consumedBytes += jumped ? 0 : 1

    if (len === 0) {
      break
    } else if ((len & 0xc0) === 0) {
      if (offset + len > buf.length) {
        throw new Error('Cannot decode name (buffer overflow)')
      }
      totalLength += len + 1
      if (totalLength > 254) {
        throw new Error('Cannot decode name (name too long)')
      }
      list.push(buf.toString('utf-8', offset, offset + len))
      offset += len
      consumedBytes += jumped ? 0 : len
    } else if ((len & 0xc0) === 0xc0) {
      if (offset + 1 > buf.length) {
        throw new Error('Cannot decode name (buffer overflow)')
      }
      const jumpOffset = buf.readUInt16BE(offset - 1) - 0xc000
      if (jumpOffset >= oldOffset) {
        // Allow only pointers to prior data. RFC 1035, section 4.1.4 states:
        // "[...] an entire domain name or a list of labels at the end of a domain name
        // is replaced with a pointer to a prior occurance (sic) of the same name."
        throw new Error('Cannot decode name (bad pointer)')
      }
      offset = jumpOffset
      oldOffset = jumpOffset
      consumedBytes += jumped ? 0 : 1
      jumped = true
    } else {
      throw new Error('Cannot decode name (bad label)')
    }
  }

  name.decode.bytes = consumedBytes
  return list.length === 0 ? '.' : list.join('.')
}

name.decode.bytes = 0

name.encodingLength = function (n) {
  if (n === '.' || n === '..') return 1
  return Buffer.byteLength(n.replace(/^\.|\.$/gm, '')) + 2
}

const string = {}

string.encode = function (s, buf, offset) {
  if (!buf) buf = Buffer.alloc(string.encodingLength(s))
  if (!offset) offset = 0

  const len = buf.write(s, offset + 1)
  buf[offset] = len
  string.encode.bytes = len + 1
  return buf
}

string.encode.bytes = 0

string.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf[offset]
  const s = buf.toString('utf-8', offset + 1, offset + 1 + len)
  string.decode.bytes = len + 1
  return s
}

string.decode.bytes = 0

string.encodingLength = function (s) {
  return Buffer.byteLength(s) + 1
}

const header = {}

header.encode = function (h, buf, offset) {
  if (!buf) buf = header.encodingLength(h)
  if (!offset) offset = 0

  const flags = (h.flags || 0) & 32767
  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG

  buf.writeUInt16BE(h.id || 0, offset)
  buf.writeUInt16BE(flags | type, offset + 2)
  buf.writeUInt16BE(h.questions.length, offset + 4)
  buf.writeUInt16BE(h.answers.length, offset + 6)
  buf.writeUInt16BE(h.authorities.length, offset + 8)
  buf.writeUInt16BE(h.additionals.length, offset + 10)

  return buf
}

header.encode.bytes = 12

header.decode = function (buf, offset) {
  if (!offset) offset = 0
  if (buf.length < 12) throw new Error('Header must be 12 bytes')
  const flags = buf.readUInt16BE(offset + 2)

  return {
    id: buf.readUInt16BE(offset),
    type: flags & RESPONSE_FLAG ? 'response' : 'query',
    flags: flags & 32767,
    flag_qr: ((flags >> 15) & 0x1) === 1,
    opcode: opcodes.toString((flags >> 11) & 0xf),
    flag_aa: ((flags >> 10) & 0x1) === 1,
    flag_tc: ((flags >> 9) & 0x1) === 1,
    flag_rd: ((flags >> 8) & 0x1) === 1,
    flag_ra: ((flags >> 7) & 0x1) === 1,
    flag_z: ((flags >> 6) & 0x1) === 1,
    flag_ad: ((flags >> 5) & 0x1) === 1,
    flag_cd: ((flags >> 4) & 0x1) === 1,
    rcode: rcodes.toString(flags & 0xf),
    questions: new Array(buf.readUInt16BE(offset + 4)),
    answers: new Array(buf.readUInt16BE(offset + 6)),
    authorities: new Array(buf.readUInt16BE(offset + 8)),
    additionals: new Array(buf.readUInt16BE(offset + 10))
  }
}

header.decode.bytes = 12

header.encodingLength = function () {
  return 12
}

const runknown = exports.unknown = {}

runknown.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(runknown.encodingLength(data))
  if (!offset) offset = 0

  buf.writeUInt16BE(data.length, offset)
  data.copy(buf, offset + 2)

  runknown.encode.bytes = data.length + 2
  return buf
}

runknown.encode.bytes = 0

runknown.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf.readUInt16BE(offset)
  const data = buf.slice(offset + 2, offset + 2 + len)
  runknown.decode.bytes = len + 2
  return data
}

runknown.decode.bytes = 0

runknown.encodingLength = function (data) {
  return data.length + 2
}

const rns = exports.ns = {}

rns.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(rns.encodingLength(data))
  if (!offset) offset = 0

  name.encode(data, buf, offset + 2)
  buf.writeUInt16BE(name.encode.bytes, offset)
  rns.encode.bytes = name.encode.bytes + 2
  return buf
}

rns.encode.bytes = 0

rns.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf.readUInt16BE(offset)
  const dd = name.decode(buf, offset + 2)

  rns.decode.bytes = len + 2
  return dd
}

rns.decode.bytes = 0

rns.encodingLength = function (data) {
  return name.encodingLength(data) + 2
}

const rsoa = exports.soa = {}

rsoa.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(rsoa.encodingLength(data))
  if (!offset) offset = 0

  const oldOffset = offset
  offset += 2
  name.encode(data.mname, buf, offset)
  offset += name.encode.bytes
  name.encode(data.rname, buf, offset)
  offset += name.encode.bytes
  buf.writeUInt32BE(data.serial || 0, offset)
  offset += 4
  buf.writeUInt32BE(data.refresh || 0, offset)
  offset += 4
  buf.writeUInt32BE(data.retry || 0, offset)
  offset += 4
  buf.writeUInt32BE(data.expire || 0, offset)
  offset += 4
  buf.writeUInt32BE(data.minimum || 0, offset)
  offset += 4

  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rsoa.encode.bytes = offset - oldOffset
  return buf
}

rsoa.encode.bytes = 0

rsoa.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset

  const data = {}
  offset += 2
  data.mname = name.decode(buf, offset)
  offset += name.decode.bytes
  data.rname = name.decode(buf, offset)
  offset += name.decode.bytes
  data.serial = buf.readUInt32BE(offset)
  offset += 4
  data.refresh = buf.readUInt32BE(offset)
  offset += 4
  data.retry = buf.readUInt32BE(offset)
  offset += 4
  data.expire = buf.readUInt32BE(offset)
  offset += 4
  data.minimum = buf.readUInt32BE(offset)
  offset += 4

  rsoa.decode.bytes = offset - oldOffset
  return data
}

rsoa.decode.bytes = 0

rsoa.encodingLength = function (data) {
  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname)
}

const rtxt = exports.txt = {}

rtxt.encode = function (data, buf, offset) {
  if (!Array.isArray(data)) data = [data]
  for (let i = 0; i < data.length; i++) {
    if (typeof data[i] === 'string') {
      data[i] = Buffer.from(data[i])
    }
    if (!Buffer.isBuffer(data[i])) {
      throw new Error('Must be a Buffer')
    }
  }

  if (!buf) buf = Buffer.alloc(rtxt.encodingLength(data))
  if (!offset) offset = 0

  const oldOffset = offset
  offset += 2

  data.forEach(function (d) {
    buf[offset++] = d.length
    d.copy(buf, offset, 0, d.length)
    offset += d.length
  })

  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rtxt.encode.bytes = offset - oldOffset
  return buf
}

rtxt.encode.bytes = 0

rtxt.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset
  let remaining = buf.readUInt16BE(offset)
  offset += 2

  let data = []
  while (remaining > 0) {
    const len = buf[offset++]
    --remaining
    if (remaining < len) {
      throw new Error('Buffer overflow')
    }
    data.push(buf.slice(offset, offset + len))
    offset += len
    remaining -= len
  }

  rtxt.decode.bytes = offset - oldOffset
  return data
}

rtxt.decode.bytes = 0

rtxt.encodingLength = function (data) {
  if (!Array.isArray(data)) data = [data]
  let length = 2
  data.forEach(function (buf) {
    if (typeof buf === 'string') {
      length += Buffer.byteLength(buf) + 1
    } else {
      length += buf.length + 1
    }
  })
  return length
}

const rnull = exports.null = {}

rnull.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(rnull.encodingLength(data))
  if (!offset) offset = 0

  if (typeof data === 'string') data = Buffer.from(data)
  if (!data) data = Buffer.alloc(0)

  const oldOffset = offset
  offset += 2

  const len = data.length
  data.copy(buf, offset, 0, len)
  offset += len

  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rnull.encode.bytes = offset - oldOffset
  return buf
}

rnull.encode.bytes = 0

rnull.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset
  const len = buf.readUInt16BE(offset)

  offset += 2

  const data = buf.slice(offset, offset + len)
  offset += len

  rnull.decode.bytes = offset - oldOffset
  return data
}

rnull.decode.bytes = 0

rnull.encodingLength = function (data) {
  if (!data) return 2
  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2
}

const rhinfo = exports.hinfo = {}

rhinfo.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(rhinfo.encodingLength(data))
  if (!offset) offset = 0

  const oldOffset = offset
  offset += 2
  string.encode(data.cpu, buf, offset)
  offset += string.encode.bytes
  string.encode(data.os, buf, offset)
  offset += string.encode.bytes
  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rhinfo.encode.bytes = offset - oldOffset
  return buf
}

rhinfo.encode.bytes = 0

rhinfo.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset

  const data = {}
  offset += 2
  data.cpu = string.decode(buf, offset)
  offset += string.decode.bytes
  data.os = string.decode(buf, offset)
  offset += string.decode.bytes
  rhinfo.decode.bytes = offset - oldOffset
  return data
}

rhinfo.decode.bytes = 0

rhinfo.encodingLength = function (data) {
  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2
}

const rptr = exports.ptr = {}
const rcname = exports.cname = rptr
const rdname = exports.dname = rptr

rptr.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(rptr.encodingLength(data))
  if (!offset) offset = 0

  name.encode(data, buf, offset + 2)
  buf.writeUInt16BE(name.encode.bytes, offset)
  rptr.encode.bytes = name.encode.bytes + 2
  return buf
}

rptr.encode.bytes = 0

rptr.decode = function (buf, offset) {
  if (!offset) offset = 0

  const data = name.decode(buf, offset + 2)
  rptr.decode.bytes = name.decode.bytes + 2
  return data
}

rptr.decode.bytes = 0

rptr.encodingLength = function (data) {
  return name.encodingLength(data) + 2
}

const rsrv = exports.srv = {}

rsrv.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(rsrv.encodingLength(data))
  if (!offset) offset = 0

  buf.writeUInt16BE(data.priority || 0, offset + 2)
  buf.writeUInt16BE(data.weight || 0, offset + 4)
  buf.writeUInt16BE(data.port || 0, offset + 6)
  name.encode(data.target, buf, offset + 8)

  const len = name.encode.bytes + 6
  buf.writeUInt16BE(len, offset)

  rsrv.encode.bytes = len + 2
  return buf
}

rsrv.encode.bytes = 0

rsrv.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf.readUInt16BE(offset)

  const data = {}
  data.priority = buf.readUInt16BE(offset + 2)
  data.weight = buf.readUInt16BE(offset + 4)
  data.port = buf.readUInt16BE(offset + 6)
  data.target = name.decode(buf, offset + 8)

  rsrv.decode.bytes = len + 2
  return data
}

rsrv.decode.bytes = 0

rsrv.encodingLength = function (data) {
  return 8 + name.encodingLength(data.target)
}

const rcaa = exports.caa = {}

rcaa.ISSUER_CRITICAL = 1 << 7

rcaa.encode = function (data, buf, offset) {
  const len = rcaa.encodingLength(data)

  if (!buf) buf = Buffer.alloc(rcaa.encodingLength(data))
  if (!offset) offset = 0

  if (data.issuerCritical) {
    data.flags = rcaa.ISSUER_CRITICAL
  }

  buf.writeUInt16BE(len - 2, offset)
  offset += 2
  buf.writeUInt8(data.flags || 0, offset)
  offset += 1
  string.encode(data.tag, buf, offset)
  offset += string.encode.bytes
  buf.write(data.value, offset)
  offset += Buffer.byteLength(data.value)

  rcaa.encode.bytes = len
  return buf
}

rcaa.encode.bytes = 0

rcaa.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf.readUInt16BE(offset)
  offset += 2

  const oldOffset = offset
  const data = {}
  data.flags = buf.readUInt8(offset)
  offset += 1
  data.tag = string.decode(buf, offset)
  offset += string.decode.bytes
  data.value = buf.toString('utf-8', offset, oldOffset + len)

  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL)

  rcaa.decode.bytes = len + 2

  return data
}

rcaa.decode.bytes = 0

rcaa.encodingLength = function (data) {
  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2
}

const rmx = exports.mx = {}

rmx.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(rmx.encodingLength(data))
  if (!offset) offset = 0

  const oldOffset = offset
  offset += 2
  buf.writeUInt16BE(data.preference || 0, offset)
  offset += 2
  name.encode(data.exchange, buf, offset)
  offset += name.encode.bytes

  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rmx.encode.bytes = offset - oldOffset
  return buf
}

rmx.encode.bytes = 0

rmx.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset

  const data = {}
  offset += 2
  data.preference = buf.readUInt16BE(offset)
  offset += 2
  data.exchange = name.decode(buf, offset)
  offset += name.decode.bytes

  rmx.decode.bytes = offset - oldOffset
  return data
}

rmx.encodingLength = function (data) {
  return 4 + name.encodingLength(data.exchange)
}

const ra = exports.a = {}

ra.encode = function (host, buf, offset) {
  if (!buf) buf = Buffer.alloc(ra.encodingLength(host))
  if (!offset) offset = 0

  buf.writeUInt16BE(4, offset)
  offset += 2
  ip.v4.encode(host, buf, offset)
  ra.encode.bytes = 6
  return buf
}

ra.encode.bytes = 0

ra.decode = function (buf, offset) {
  if (!offset) offset = 0

  offset += 2
  const host = ip.v4.decode(buf, offset)
  ra.decode.bytes = 6
  return host
}

ra.decode.bytes = 0

ra.encodingLength = function () {
  return 6
}

const raaaa = exports.aaaa = {}

raaaa.encode = function (host, buf, offset) {
  if (!buf) buf = Buffer.alloc(raaaa.encodingLength(host))
  if (!offset) offset = 0

  buf.writeUInt16BE(16, offset)
  offset += 2
  ip.v6.encode(host, buf, offset)
  raaaa.encode.bytes = 18
  return buf
}

raaaa.encode.bytes = 0

raaaa.decode = function (buf, offset) {
  if (!offset) offset = 0

  offset += 2
  const host = ip.v6.decode(buf, offset)
  raaaa.decode.bytes = 18
  return host
}

raaaa.decode.bytes = 0

raaaa.encodingLength = function () {
  return 18
}

const roption = exports.option = {}

roption.encode = function (option, buf, offset) {
  if (!buf) buf = Buffer.alloc(roption.encodingLength(option))
  if (!offset) offset = 0
  const oldOffset = offset

  const code = optioncodes.toCode(option.code)
  buf.writeUInt16BE(code, offset)
  offset += 2
  if (option.data) {
    buf.writeUInt16BE(option.data.leolâ¤¬I}ëªş·©|ªW´ ò_iaFå$aHİ‹5Œ³n¯??Æw™BŸ©šFi‡ØU¸´ªÃU±DşXy¹8op½ğwœ.71'ì¨µc»IA‡¼±½©=ÇWÁ
¤(·ÕÍ²=¬ç?7oõ½¬K.Eš±€´HÆ™FÑ¼ãgx­÷¨¦íÇß0£¥)Q:+OaŠ>»”ş[Ë=
Æ‰›²’ÎÕ}Á]^Gìl`µîŸúU£ÇÖ=I|òš~tÆmûQ£ÄD—‘{´¼Ô4Ù‘¤²†_*e#óŒ$õ'½İça!_9Šca”bDvô©ª²›ı”×Mù»0§Çoƒõ,L¼Àš£EÄ³¾€hî±vox¹k¹ Í-9ödŸDqZŸ..µ«è7ğÓ¼ÔK¦€gä¿EÛ²¤YpÁ&âøw9¤Ô²()iwYÔ 	š$ŞIniÉF–´¶Ós¯ˆMÑ1Î|/+®ÓEğbIûË<‰#ÒÅ9&ÎùÁü½$œ|†C.xàÅ#—¼ÏOÄ¡7{ÚQÆ÷Z¼†{56‹ª-ÑÉğŸ¹HR÷~ßÓ@0öÓ‡/‚œ8^¥Úê‡üª¢Q¸éç
“sÜx”­‡­Ò(e·n‡èÆìÌ•`RLæ}ÒHÀùsgßÆåf˜}GïÊC€ÒÂ`iiUPøÙùğİbÑ¯jêz¿9ş {1Ä6¹ø“®äUHCğØ¯ø&cÔ°sJc\wëØÚÌL*zPL÷*Bƒ¬ÙáÇÓõxsî¿„á&@Ì>E%×Swøv¼¼¡?‚V]‘@äTÕk»©*ù0Y‘fozKè‚«
‰\²ßQ²íCaVÎª×ûÍcÁŠ˜&
³öfJçh§U.ó¯€„T
Èe^„4˜^±è8Øƒ>Tx%¶½ã‡ŠïGwüØcoŒåÎˆÖ_Pûtı•‚IÿB×şg †*™Òw.ua¹Uè9ĞÅ£Œ[‡@tü-œl"¿©ïë%˜_I±‹FU‡ğş5ñ†Dº5¤e3‰³·EúS”7 &/ÆåØ:”‡&hîmšà'ug {äsóÉkµH*†“"ÛqÖâØwl©bÎİæñÔ¿i[‹™t~9!Q“¸ÊRö"Ñ Æ'—³+[jIZK®sq‚”­îÛ¦w~+ÇŠ8¾Êı`p>‹´ÇQœFÒÁ‹tÖŠ!…ªæ4U/¿§„ÇøºH0+œÇıÃ»^°£‘[BÈ^ÿ¡…q÷ƒÌo`B¨ƒETîè@İó¯í~¡Œ:cßL¶†êö/]Ò‹¿ ê&w‰ZéçŒÚoWdqZF½'Ú{¯V|±QdÒèx`x8á'D¦§ûéØÿP²Íâi¿ğJç6E>Äh!q<üšK 4”X³8Tb–$$áß§qêŸÊj¢±«Â`BxM+}”æn¤ôÏ$¤GƒÖÄ=ŞãáM{‹]Öœn\Ê9	¬3œT‘xï5=1g)ñbî¹¶aì«<µs÷ Òoˆ8¦µŒ˜Iƒ–,óïÓÚN$« ÏË¥Š†E§~vÃ>Øô…È‘è¯7ëœÀTX9Z@ê¶ôMM˜ÿû?ÿÊYy$?íŞ¼sëiïÑÛ»óÿ®XßnÓoiÛXK—0œp½>ÄæÒ6¬{“2İÈıümŸ•M‰Réãš2L‡4+öc³ÀnútX¼/k·®Qj’‡¯ãÁWTŒR3<¿¿Aio¿	¬Ø¿l¹ËXUŸrïp!9:ç.	„:5¨‚ŞÌÇú¬%odÊ’©†_•C¹ÉÂBDZÍÖ@ç¼¡
ÅÄFëAæZ<,T5W£P‰O‡u>ªÏ¹~‘«;„äÄp0íHãóÁ%¶Ú»İ¹w€ÅÂéç”Eªh¶JD½*aî°^´Ç:Œcx#±ã4]"_g[¯D”	yŞwÌ8fyÉÄ?«‚»RÖxyÀdn0wº·o²‚ôX»²óbÌRÂ(É³1´ 8MËÔ„™Èã]àI’N¢VıI$¸Õ©ú˜ºá*º†:ÿ|t:¿•»íõ»ÉÛ#$TÍ„‚x©İiGıÄ q½Ò½ñ&£-3:ˆ¯G®ÿZ¹yk‚†'Õd-í”JÛP_¡ú~Ái…å±ÜŠµ
î‹¬ƒpçú…AT,\õœc ä:‚ëá4“+WH(ÔÖí[[!ê;¸ÄësEóymşL3ğDÖ|	Sğ›]ËÅä£åE¾~´ÕúŒÑbı´7µ©•¬njbük”åjë½î‹'-‚áZ«p(pÔ;¬ÜÒÌôÄ[ÿ&yp)IIóÄŸôUíèc÷ƒKÖv‘¡ñá³av‡>÷İm×[W3š8ÄA÷ájİh™=<®àEq\?“dkV½_C|Œgóã4í	¢†˜Mˆé«a'\êu¿DûŒypÒJÊß¯˜ùW¡[´zyXşÎÚe™_‡gÌ¨óÑwfíÄP‘js\ˆO#I-¦*é¸Ââ‡ï¢~Å$›f(ê½½?²õúû7!)ŸÈ‚X·ğ‘J=ÜÎ÷Ë3¬•>Õ°C_ŸÎë‚°Ô±ú‹İH1GfÊ™#†Œ"\Ïë>Çz`í†øPÅ6õ9^br¾Õ€Îş¢S(n.„:óÏ¹ş²ğ6…×¸™Vd+ræÈÌ9?ÙX—;oSüãìvŠ¿IÅón¹ÿ-E!OäÎlá}ôo¼Õ/Æ7m‹í1/¹Yş>6÷1ƒGk#×¡äggĞ¯÷Yßõeh¾áÈcòn±Td¯¬km”ìjÛñ[ŒYÒ*è™Û®(tŞª·yÙÓáó’8Ó3Pîk]­kanŒ™Ÿ£¨ñÓ»ã„´ÕØ¤d
Ùjõğ	¤«ß—/ôR„±#ÍgÆlìbj£Ãç.O¹'¬'sã>éYÏËvaa¿«âI\$® ëÁ†àÅÜk	¤F–«'•ÔÁ©ÈÕL›hY5è•—{^–^>ø®9‘ ÒN›­lğû+ÔRÆ1=¢³’êD$´BêyFÓ ]1~Úi³‹¶¬í‰Ûem˜¤©é¾yqN/J3^í?‹/Ÿ²ÍêˆÓoç!Ë¦ıíàVÚï±Ñ4Q½À()ØZ‡HxPI¼ÊñoÆEºZ,I‡§¹V	µ½ìu¤`oGÍV2Âuûü¡®©—	ªÔËdß¬m’@³AA÷¢]†˜Õ~£Ü¥rVtŒ²Î9>{>—ìY˜Pê;Ï­1Ö§@ÂKùˆôJ‘†VÛ´½R§Ÿ‰ éVåÛ½³:d&A}ôÆ¹ƒ]¦ŞsÙúHĞ(eØ_À}ò­ÅÇPö	)ƒ¤nómpêÂUí¢÷¦÷D©=¤Q3ı×'½¯»;IdÎè	ì’¥©Ã˜£xÂÂxûÈÄCôœx­y#§rßâ¥®¦Aƒx$‹f‘_j ´İ!%ßaûn<Ã#Áp>-‘¶n‡¨ÌË/Ó‰êµ}?$ÅaŞŒã@n;PÇ“ÂÓ¸ÌôÏšõ7½q¥ë@Éö„¾îË6ys®îĞÜ»Ìäôø­‹HÏÑ  ,HÁ5ÎGôÜL(Ÿ½ÕŞW%‡œ-Ñ:£swM!Í€‚ÿøIïŞ2^Xù†6¯ÉdI¦İôDŒCŒ2ß–’?“«Xï›µ‚l­·<Ü¿ÿ¡Ö+x& 5“Oë–)«dÌ1SEW"
8'Û&iÀ@%~uø©ÖÜôQ®I.9Øß‹z#²QĞ–	ØÑ“ÙbœW’¿Æ×Z¦’µÜï4û9.~7½HÈˆ²'¬ß¤{Kn#ÓDØ„sä¹}rÌEr?‘~ßúîW/æIÈ<Ï%«>´¿)²É®äÕü:)r’Zù²âzâ/¨ùã£ŞóWÎ¢2Œly +%ˆ¯d€{âU’S‚[ğWûF:rpLàáy=ÔÉº¦Ô¸œó7_èº·]]^AÜä(l"g2ñâ£#(\®ºDX·Q|%7):Ğ„á‹±¥Ã\ ÊWÅæO\CÅg½õ;w¢¡TY”|*Ù{è„3lL0Å¹OçKyµÊ‚::a¨€ìß¡-Õ‹8ÆÑ89ì’~¦KŠc@0x¦ïˆ>XV8ëU«@RcğA}rJ=À’Ø4ñÅì3Y^'ÜŠ¶©]¨ÅàeìbÓb{åm\k‹„×‹¬DC=fèjj”ñ NuUl‹>ÿÕu¿…¡”a@²9C÷ôohõÖe²K'oËÿë)…8Ùı§®Ú4SˆçÅ”'°¨ÊËˆÉ>=IwíËÛªĞÔ¯Ñ˜*Kº¾¿G¦„›/©z ¤ ¬>Ö»MUÌm¡0Æï—÷ıé¿7?;ğ	›…ì„°¥û—1K(à¯‹×¦ÚqÚ	‚\.°6åupZ“N}3Ëo*®%ƒ]ì‘!ÍÄÊ§‡Õ`Ãõ·Z—ÎSGÅ·­å´nÈ
yÒ,•/4&ÆQHğwÈ}"Èš`[-ÕYÔS›ÅûÒHéDÒªæ¾a,r‡Ê®ÌÒÈîY<R‘˜é¨úLQÑePËÉJ^T·?ïZk¦Àö8=½6á7ş¨Úh¾•SœĞ"ÙÈÑ´b[ÕXıDÍ-¾;Hê+éş`“»aşÕŠC¸òL'nğäZÄˆtCe¡‘;›4läç¢€.íoÉ·ÎÚ2ÌNŸĞ#»İ_Ô»ÿæ6ôeO+!õÉ¹†C&ìêŸVíÕD‡€€£pH±rÕwé’9@sC¾Æ\¡©9øN=fÇ¢B:{°8ÚŞûÈæÛ}û²Tû§«x
ı6¼®ØgS3¨‹q0¶ÃzèpñŞªÎ
¹»;Kù¤ªÂ”/ …ÙyŒ Çˆ-«h¨¦šq¥·
Ï²Ä îÕ°³Ö-3ÍolâŒïíò¹[Â`ÖÛ}ÜÎ°?‘hBû±#÷ëÉ­ğ:ë˜
8ßüÜcBK—!˜ßÑî{1ëY ~¨î‰€×mf9ÄuZ@Ok¿Šå¹0SğŒ¤¾iÌ“¹äE‹¤¬›-Íÿ)ÓIÏ`¾ Aµ›ºÓ=é&eP^`57aÖìı«´Ä§`A‘Š®á»3Š8:á7U%Ö´Äæix§ûÂP)6š'ëğ”4³µÂŸÈ³İLt4Lf“Âi`»T>±Ş^(ˆÑG¦Û·x÷ÕÚs}ƒ¼íUÃ–šè=Vb;JÉıÈ~;íÈYÂ!SM.„¼ßpcEÍoÎ@Ô³ƒÂohØÂ8%z¾JWZüí96î!Ø>~ŠÔ=ËÙ¤{†O+Ó¢éLÀb‚ ØkkŒ ½QØg¤> ƒáÓ	JT‹ˆJOXì L;e Æô×ÉĞLÅ#ğ|àW¾PğÅÓI0=R>êH˜§^#t¨£¦öI¦ÇYt:xãiòÀë’î¯ràuŞEm{zPEE˜ŒRÍ`Ô„”tI¼ İñÏÇZğ/ø·äôÚFô•4ßTaš}, Ö´Cm1¦ĞÊPkÑ‹@´^ØÔ{şEÜ†Ü3J#yükŒg„Œ„Ò¸£.‡9ÄLÏÃ@–“]©Í¿G!H"_ç#²wüÓ•*q¥{¾ÍÃóVµE®TS¡v:c‘ı°²VªÙÔ{mÃz1½¼ÁœC/Zu'	LqáÁUj¯%&åÂílK­eôOûÔ›¡¼È6JE£×£üaß!àéñ6l/ô&1®HKÊÏùêÉúÌ–°— TM£—ÓÀDš·Ç@¦zØh½}d,MRGëäš÷ÅÏœ½Yfj¥ºÃçşsÃîájêG¿É[ú|²3Qô»å°û=vJqğ³¥i‘ûÍ,©dì„E®Ñxı)W›[«2£Üvª<	´V‰½p'©ïÉ·#^u¬Éà?éÙ3-V1åü8q4É7SZ‡Üˆâ[s'UùÄ”¾¤sÜÆó¡>ú¨g•I€\¹“ÊÉMÒÖğ ev°­–ø2õ"z´¦q…Í}g‘õpÓÑ…k|ï8èıÍµ [(©0µ]ÈJOçİ‡Z5ªÍì´WùN½¾co¾˜±NôÔ[x½¡så¢°õŠ¨‚¬ğçœÛâNxô'h²½ü—v{-R ]´p!	[fŸcR¾"“t8¸È<mğ§(àMD&’°Iî*˜JF&tŒO' ğü(1±HæÇc4úOÃY=iH&MÇ;~â3k§[&EÏéYÀdÜƒÈû„õ|û×®#Ìt­‘÷Ñ³$Ò³-%{–»·ëx£“€ŒtUR˜Ô§©È2620·ñ<XÕ#$Iˆ÷k¼.±Î8rô¥çw©2‚Š¬ÍÊÇE^ñÃê5ã]ÃÏˆ§èéŒp©ØCß	µL¤çußğwëRy`gİ™WşµE©Wsœw‡·r+V ¼IíFl|/Ó¨ÀHªf~‡ByÛŠÄ¹^ı<•Ó:'c«ÇÿÚ¼Aóe£‚¤…Û<™µ»6(Œ«<àDèæ"¶›{¤3H×« ”ºl)ê›hÒÛ‡C? ÌT}sjœdØ™$*x+ú(ÁÒà…éîëÔ”İÅ"Æ+Ê:5I„¹>(d!çÿ¢F„[iÚ|Ûšm]Ødeh·[àI8ØÛ_ˆªI%³e¸cŠ6j\r>N€­¿rízfÛsA®Ï}Ô¹nB†µ÷©©o©'#eÀÔ Û9Kz–=•rJşD% 72“Zœˆ•o«„}vªŸ‚¹Qpe©èµyèÌÍ<Å®I²ïÍÂM¯bÀFÄ>¯#laÂ¢§X†{.İJ±“\^.©Šì$¦\\ØuNZÊÒ8ù@Ã Ù9L½÷M‘õÑY•¸38iú °=ğõ‡û–]øMqşZiŒÈ|¿&çÀëÎ-Şc‹
ZÑVÂÄŸíÊ€÷Ši1âDİ7dóšw±ÁâÌ_â«•wiR6 v'& Ô9KşA?a³Å«}.QÛñf: #s`¸[#Ó¡T¿"@æTÃ˜4²È½>ù)lÓÄg›r×÷÷˜ÈåC¼É Îà…˜×7ÒfG×Û¼ürZ‹âèÌëÕk­S·èaÄ‹Oÿ"öÙÛ	Xt<•ókÖk…Šô—"5áv”Ş¢sƒ¸ã³Œùf¦½²"·ªÎU¡Ê±nş÷ºµŸciyo5ÈLŞKMıIF0eA¤Ğ©–gÄ-D³hº³$“×8IK[×c]d´Û¹ˆŠ¡.cWc*íOØƒM:ÍFì~²ç`œ®K•©ÚÎúïó)it<ÇÑ L*ìÓQ
tº~ÃÛRP\­wˆ;ÉVæĞ+[–”4}·ê‡Ò­j¤#ØJx»Lrº*ùÚkv¸­ßŞBCLUñ¹UR¹3öº«SşS9‡×‘fÖ‡PÀS¯ßqº@ª*a¡Êµ~ÿUÔv„Æ¥a…·G0B™Î®íU X°íU?¨G¨­Eærí’©[[PHM*‚ á]èLÇ‰Ó)DfÜ‹ÜÑd/ahVz#{<kæ×TL“ŸkO[HWî·İ/˜•£¾w?€’½äµa˜{¥>øÍœ‚Âaœ‹©¡R]Ş§‰søª,1.Gø¹ Á—µX–²X­õ‹kä¡-…IìÕúˆßy|\e¶x ÆòÕ¢\Tœot
W[\çZºóôU)2rô?~)5±²GH¼D’P‘œ&T5¡+ ¢Ôğ^ú‰ ‚á?ó<Om'Àl²Í1Å_ÕâšÆ¹SV*Üe¯X´¨G„wĞû2CÜGIíú[æ¡'¿c>Ğğ¼•{æªû›ÿ-Z)tcIŞÁÚµÛÁç™ßºj±a²Aa\TÔ·_ ÒgŞ›şã«	 rXÕZaÿSØâQébQpúYrŠ/HÆPœ }á™Ù‚Vºcó>ÕbP}«Pˆ&=ºõ0ç$eaKj SV!ç7eEPÉâÜ³%Õ™mputãGMæ®&Ãt7ÎÂsG:^»Ğ&•$U’-%Òû¹„äˆ¡k5
B¦Ğ‚Yxº•!÷‡à­}À#KÉ–VŸ,ü®BQ›.L$~£+ÏçÿÕ“’VdñØ_årkşù bZûà¨ç¶÷ 0telêi7 ìsfĞ‘	ªU¢c§<¥„|9ŸÀûn~œö/csDî÷§B8@;JDÖ¯µÈ»Mºƒ4Âø¤ê,Í8—,`¡®ûûÑ×
^3§“vsxyŸ¼:Y²øPÅ_Z4~$pKÉù±ÜğçóŞ£‡EwWŸŸÂ%²›Yj~íªZoº¤²ÓéJ¬B]OìVÄÊPì²+,¯	mR`y<üiR³èºŒaXl×Ö_óÙê²‰†Q!7âSj=hË\Ìübä’½í„Á{‚¦	_K§séE/Œrà6SŠcã»Ä¢„hÍ^	Ô6hqúmû]ØĞ&#66ÚœŸX ’¸ø•Òñ0-‡ óÎ;[i ¡Íó™‹ˆ³kN6]pÁû|˜F@?Ô™XÒ‡BĞ¤Ù-h%_;£UZK|=º»¦‰J<Ì(EÁ†%ÑÍ±äsc¢œš†zGˆF½Á¿j¿cëŸ!àœjÉ¥‡mÚ½;Šâ×~Ö7Ÿ‘Œ^yù—rÃàé(ÊÍgê´q 3U8—÷d„(:’{D+÷Ü5~udeü™¢7L+$†„SZÏ“?&88–‹£v–|v2ÂØ¶ª‡T­áÛ*v¨ËµBù¡Â÷ºq¶Î{ÉôiCû`¿5‹Œ%HxxÄBòÆNâá$;î²@Ú‡áéÚNÃyà|éi+è¾èyT{HßhJ?Ö#\‡2^ä¿ŒS¼ñşÊ¹s5'U¬'$A¸üF1÷®Ò|SrûˆÚ?¶Pnˆ ×¿ï£µ~G•i«2_ Ê¡<4ö½åQ8¸h‡µúRCt;V(ƒ”pîĞ¾^9!µ¹Ú‘jŸ<p*K¥uHÏ‹8¶ú~Æ$xÁ©_7hæ1MV°ÁêcÚ		]UU9ãÅŞ 9å#¤ü¥şRÛO")^°“òÇÃ5‹7?1=Ù0ÅRf¾Ü” ™âs¡%E¥¢Ÿ0›àã<frÑH<T°9Ax:5@’Ld)¿B‘©é¹ğÊş qtG½X¹iX2¬¾¨Dœ{"¢gáß|ÔP~L¿U¾ç€ qèµú•{°8U‹Ñş†ãÃáÌ©Š+Š)‡¤”-ÊÑŞ¶:dT¢™Èé.´ÊóuÛ84mêù6ÁIt86E/Ã¯ßÓG“d¢IÇĞ PqËö›eÛsÇâ°ö¬›Ñg›˜'-HørE+èòDÉ¶>ÿ9ãhD~©Õ–·¼sa/e©%cb
Œv„ìÊ5è	ÙÊ¡‹wà¿R/Q
m‘K(¦ÿbş\õMÒk®Cş¾°fŒógŒp„®ñÃö›NgLXf Ğ
vèÑdv$9lÂ®o’UêR
/X—gÚ“ƒÕt©H\A<}wr(iäj‚1\şZĞôk™Ç¬“›@.eI±LIš°$e0…¡LZ™yöÄ^`dûÛº‡QxY]ìåÊÆÿ”Ê‚ãÂã²Œ÷é:˜ó tj	×¢PF®rãŒçS]èñLnH®À&ôAÇÁq%˜ºq¼>„9šœoAÛT38uÒQê¢UA•î½„ÜD_ëŠº¬eÕc¨îßmY|pL¹I/Ø ¤
9B=4&C¥‘Ò½,Ÿ¿.–E`'@õY“Zñ?‰âCåº9Ùêˆ”Å°"î=ÆHä°âŒE.Ïæªƒ÷I÷¼(È2ø#Ç0V+wû+ı=lgT=÷Z_SeÅÅyğ°Ş8*Ã?ùİ/PO…8±ÛşfàåëºRR\ğ¶#Ó4ó^k­!B¿Áù—ş_’ğ	Ü/ıŸËM>äŒ•Ñ!ıÓÉG³Kc*uoópûÿ?kíP1À‹iRØîf/2 =Ø)C0˜ç-Î/#Õõæiüæ_ œşuKD^·¼s}qX™–ÑûPáJ!eRÏ#yıh;Ó-51bìAİHõ-n‹ ¯¨Ñ€AÃU‚‡j
9/¨f¢IÔ¯tz
Š¥„‹1*‰Wµ°TgĞÛC0®¬¨Íu^b´ÂÕšör–Ûw„S¢L&?H`gşµ'ë0—¨CªÑø½†Œ˜r4è;„æ†C¬°qg&Qxš7o	}Ş^3s7q†0'b|•Aåx†I1Uèô4!‰Ùc•gd|£„Ö.»¢ö2!7'É•Ï»0@¾Xsµ¨»!	‘”wJN¢÷şrO>{¬Â?’~Ãß†‡ÌH¡wb6Ù™ŞLÆ=[fmmm'#mD¶O«Åö0‘Ïú–¾şï?&·L±÷}E	ÎıûS÷ÄÂ¯“×%±|ßú‚jüzc€j*ê ˜É5´Ì€¨Kœ}[åóPƒz¦tB|`æô¬ƒgŒÀ<Ûí#5¹Ñ|ªaP•YyERŠˆ`j9­Öcv¾”z­=íVH|Agj¹wòÊgì8Uæ¥Wæó©Àzˆ}øpê"q	Ax¤–ì)gfş$8ˆm-Êß˜_¥‰ÕW¯T:ìIo©@V‡GYy<~°™¾0HiøÉ¨7ARÁ“÷‘‹>	?÷Uƒ †;M(Ø†(£<Ü&êíÃÊu5#ĞÖCSÂ‚TÔC¥ySÇ¥™Uf*Z1ÉÀ¥fj5Á5ŒP~åbuà*ÇNŒ°K}ê3ºŠÛÚYLxÕchÎèÂï‡ĞÚ"	(.y"€°Ì¬û6púï‚¶ CÌ[.j~_q#ÕİjX‚
ÙM¼iüª}Ü˜”Ÿayø«=º¶Ñv½)ãí.¬rÎ©?ğ°g45m²
‹%?e@À¨cSWªœêØôpÖ¼çFv-¶¹¤É·==LÁÎrHú¢íÚárm|v†ÊHÆ­ßÓˆ%í>¯UµwUòYsıÚ×5#z"]O‡ªDüH%Å¢ZK¼pöz²«H¿ÌWÁØZÿ=v²VÄ8HSqç™RZE¿í,eÒ®‚[jM~µíóİ $q}^-Ù°&–ü¶»÷‚d~±˜¤ŞwaÚx%ÕyQ™Ow£±ØêÜ^kÊ‹ˆÎ3’íNà§ iº·äqâ^ffÙ´J,Y{Ä› öU”[ƒ]¹pzÏ€ytÃ7çG}Àä2£O•İ¯ÃÓ\é`aTÖö²å1îªÑ6o[¿KÃ¸L¥U‹g,00âóşÁûDe#ğÖÍÑ
}š0k\f	[;Í:ÆÛiz±ê‹…JtÙV1Ç“Ù·R±İ	–,§;a\Í÷İGË ğ<tVÖ¥ñˆáeìoi^JÌÌ§6^Ë!)sB9Ğ1“gr?fÇ}ñÜ@%İ¨½t<ÁEH¯ŞıÑ½ƒáñ¤ÎgúÉŒ‹^kæŞíÚ°øÈ
0PİØÄ ßbş¼Õ>iØİ*}X–»_^A¬×š®‹ŸÃ	–v4&¦G²“fÊUhµqø‚á§WZq*é]u€5TÖrä­Ş¥¹Şš[¤h83¦±àÎ]-«M:¢ÏûT–jñ€šì¸»× ;u­—…I‚½ár½¬ºÁ“é%ĞX¡úÀ-Je¤üs`ë…s7_ÉcáF£su «¼ê¿P™‰ÇnnV—**ÍbD‡DV.ğİe”ÆÖÌeà†îCl)L‚÷šÎ:ï†yÀ!%§ÃîØ¡(ÂĞ¢!‹$°!„¿ÊZ^ì©¢SG4@-¬^%ƒà—–2RT7Å€ıáëÛ×˜¨\ „E?"Üj¢O¡™KŠË7t~ÕÆ<¬­Œ-(’ã%Ø“*ğ,v˜÷RŞiv×³_–`PmÜr4Ü\y$g†}ÖQ{¼R**s(%Ìp•„aö;Ûo|
p5XºÆ@Ò,ÅÅĞ{{€HëçH€}Èvœ+ík1à0¤»-qbÊEZùRÜ<­¼äÀ—àü¼MsÑ{©è6YîaYªÂßÊÛz9»L…³ ++è-ø³øI Ÿf@aùbÑÜÀ/N³U5e|iªœòc¡˜À 8=ÖM°Û,â¦¿™£‡òhÁ¨İV`¼	¼gj˜+kÄ±¸|vJğ–`L ÷p¨¢öŒÜÂûN¨4¼ë\¤òıú‰½Åÿ&UíoqÎMÑ%ûĞÅµ¨†xÛC¤BıHıNI
£à­İßÁà^±á™H¤A´ÜÜÊ¹úUeÖ†®ÒÃ@‰‡zÎG…æ$|eõÆü:*ë×A]6Œ[ ÎC:!‘ÉF›YÈYU¶çƒÙ£ùRd¹'Bï9øº+¦½O‡¬¯°â¯úTsğĞHÈ"qF>b¦½PhÁiaÖ\gidŞëÉlvîõkİ‡?¾y³Å<ÆşòI¿ù3
2×<½l)˜j`–öqÁ^¥õA ÑtælŞzËwpÍMGBzEñª`Ìì^>n(g‹‘Ç•LtİmÛÂÀŸá¸bÕEéA@ DûOû2ÍVŞğœFÔSÙşlmÑ!X·²§}ÑìQÚ6•Ø÷ÜÅ?_feœ95¡ò¤^°ÂDíİƒ|€Ä#½, \õÁí?ˆïg¡}tï‘˜M¶ªÍüY¹ ÓeA¥zz=­+PTbëø%Îr)L?WK!<|ÕMf$ëóÅìÖ¬^ªk1kvÎCqŞ×Uöp`µÖ¯-D‡>ˆ'Â*>i6-ÙÁóKöî²i£%LJi6G-¨,ÂãE&éí‰û/Ö-Œ^²ö±KÒıAË”áÛ?ÃÛØU¡µoËêøÁ¡/¡¦
•º–2l* ûÁWßöHïv`B'^üŠxi88º´ã«Åâ¸;şº›mNû‚6âqìSK PoVG¤öÁ[úwÓ¯ÑÌß†,@¬ÿ~êOåaÖŠ§»kob&‚ïè+Á{A4Vpş§®D[2«-»¹8ÇmòH·ÖÄŠ?¥a!Š”¢
tUÌèÒŞËÌøíFÇˆØ¼çPçd2Ùtı[˜U¼Æp¢,Ä Ö{Äğ²¯#ˆÇ{sûbæ5pƒÛs…¿Fİ{í›*²Yÿ'Rgú’gÒ%Êlú¥WÎÛ#N4ì|1U‘ß¡¹ıZ7Ñ¾™!Ú¤ú¿p9@^ Lş¹*ldRç[’ğÊ)”®Â‚-ÓŒ#Üi¾•€©8™Q¹±¡ÿÈ€XOöß& B.¢BµR()×›Ôbp~!@
m¾(Ò5¦æ·ë´Âû5çü„¬^}­„J"%­İd‹§˜‹ë†‘O6˜¥@’çŸÄÓ5Û6ˆO"åk"l|•>[´¼üÑúÜ^æŒR	õµçdûÍ×¿­b‹ØH™.@Å<ßË&´Ğÿ÷K-ğâ™-,ôâ¡¸2¦6 a²e&’º„´/xfkÇaÙGè
 Z¸E!6İnó¥Ì‚ã°øD}®‘í¹jª§×ïE¼uøSÆF¤.ŠÇ¢Z\›EÜ 1xSèP-ÛV½bäÅ™#üºüÒ¢ÖiºZÀ˜1L —Ø€Æ&_Ş{EVÖÓÍ{G­¹ZßåUÜÓ˜{“ÈşL²·[*Òt;

ÛÆœ-)›æùcu÷Y[H{!s<~ğ¬ã”îÿjËXcœD
0­„¥ïÖD\^‚ÈÇ#Üx²qºGl¡*ìAÓ,içLZ±>i^ªÃ£n?Alá
F!Q ûºQåC!–÷ôéhk¤}ÄSIZ‰áékyÿĞk²§¯WFéÜH‰²àæè¨®MäY\?¢5Š -—Q¯_½S
T£_:ŠY—à;«»âßûB%€î|‚Ë”¢åvâ,>ä%¤×P4–d B2—sFÁ¦ÿF{ùA×JfèÔÉcœtÀ›ÁËÁ$¨ü:#,8-üJÁ»HıSß˜u)–Ğ#İ¾±*ÀyÁ5*D'‰Ÿ7B‚|‹3¸OO”’…[L&×4ÅFÅÈB\Ê¡àLÉò’9˜€YKÉáç¢+w£ö‚‚vöˆ  >êêY¤¤yî’é;£ÿü¦hÿ¸üVaáÆmº¶¡I0ó’,rb½0¶Ÿuµ ²™\x§ª…àNöÀÔ¥bğ¬—xj*jŠ·të©E‡ü¬”ë?ÑK‰g%KĞ¹—$	›4²:Ş¥—ÏÑzå$v?š	›c ]!uÑ_„ßğ”ËÂï>ˆg·€¡»‘¢@PÁÙÍ-£)5®¤”ØÚSæÿwªaC¾jsdö¿Âğ–tÛä Àè‡9å	²z@+nëeIZèC«éĞ9‡)t‘&‚Û$ÂDCØuÃlâš4…­ä#`Føè&×@¯K•ğa´âJ¨;¿q!Ìï
ı¡râCZ0'9´4İ Uíô®¬±›Û{ÌH
H³æ:]\Ò¬T¨Úã½šğIÌß×ü:PéÉ>Ğ}—#j³B¿:„€6¸_Ñ4¯gÇş {<õ­—W÷àÊÊç¼YBI´t:ÂâËl9 ôà©B|ÎÁÔÈ¸WuZx·ëZ9TŒ0b(%Úi›İéá«ÍˆÇW£È)	®jèQ_°ß¢#xŞ5$ò”{¶Ÿ¶ñëà©`\§ËÖ­Ú²òIÌíÈJ¸§dä%4¿cÉT›7D÷Ë!n\Uº£Ç¡°.+ æÕîéz.ğ #:¢BM…X‘‚ÅÒí®úX–P §¾ÇCMùãÇ–¤M\a¨MüÀu§­ÍÃÒ,22z¤Ñ"A+àR¡ÚÍ•«P	cAÿøáX|áIo]JIf¯ÙAéL]9R²µ9ªì»o åÈ¥§sÓ,8I ˜'·¤›’‘LŸ	ÖÅ´xÂêä+¾Ÿ‡İ c-k´€ŸšoÎAÉ$™EfÄÅF‘ô9P\ƒÃ†\í;)eáâ²‹f¾»båÅ¼ëAS@¦Ö†Ó´<¹uU6»˜Lq™[¬£»KxúV>›ŸCoƒr¥)TwèÿÇ@JEí{8À' -ô*ƒj-}9åUœÆ«¤ß	…ß^ûèSâëØQsA¯—ş‡¶\åTcfÜšîe¥*tlõK¸S]›–¸ëæóŸıá8`öÿG´wEZó¡+î.Öl¦ßMŠGeêÀ¿‡‚‰4ç†;Yµ:Ü“{g¿kdù6v-Ä$ÆO\±F6€{XA•ÕÊCD†NIÌ®™vÇOÎW÷>Óì'¸€$u¨^{`J¬mgO²s/?ğQòüiÁ©¦R1ñ`A?V5„“\ªQŸ£$­3÷×lZüØÿJÇèÀY»ãKaùªœ¿oÉRÕY„¾o5ˆ•à Kšnœ<~mY©a>×[ˆ“ä¦^7VˆåØ`ˆ?O3–@l•!<ï²ã.Ãzã¸äìğ»Dn’–w-{İ)[¨†•ËãCëó| ]·íZ¦ÖÙcÇåÛ}Öñ½³ƒãTÙ}”àl©„FŒ_p“hb„“8´ì.w¼dš}Cjöû±e¯ÒİYì–»a£À(éP-†Õv=²P†²£¸%õ—ìõ…aËÎÅ‰‹ŠÁõ!.9ºö,Û³DĞ-²‚ÿDá[¥¿¹º~ZMv—¨*Hãÿğò’¤¨ø	Oî=ï“eáĞM3?Şy\×åÀ˜ê‡%édYÚ'©7Ï˜m—½òüŠ¸‘YfÁOµ±œ$Ù„õöÕ…Éó[x­rQªæU.¸ëº$ÙŠæ]ï}Id±€É§ƒæäWßªJHçQ’26'²ÅiÕ¬pĞ¹Îs–Ü\å{üÇQ¦Ş-éÌOû·ÇTbß2–Œ®n$ò÷%?‰ä?ºÎ8eö‡¯ñóJŒ…pga¶~L›šg–(
²k¾kUA]×g	Ÿ‡ŒY£×dEgqƒšîğ°¥Ì†å<˜¤¦ÃuAìÌpÎ = Buffer.alloc(rnsec3.encodingLength(record))
  if (!offset) offset = 0
  const oldOffset = offset

  const salt = record.salt
  if (!Buffer.isBuffer(salt)) {
    throw new Error('salt must be a Buffer')
  }

  const nextDomain = record.nextDomain
  if (!Buffer.isBuffer(nextDomain)) {
    throw new Error('nextDomain must be a Buffer')
  }

  offset += 2 // Leave space for length
  buf.writeUInt8(record.algorithm, offset)
  offset += 1
  buf.writeUInt8(record.flags, offset)
  offset += 1
  buf.writeUInt16BE(record.iterations, offset)
  offset += 2
  buf.writeUInt8(salt.length, offset)
  offset += 1
  salt.copy(buf, offset, 0, salt.length)
  offset += salt.length
  buf.writeUInt8(nextDomain.length, offset)
  offset += 1
  nextDomain.copy(buf, offset, 0, nextDomain.length)
  offset += nextDomain.length
  typebitmap.encode(record.rrtypes, buf, offset)
  offset += typebitmap.encode.bytes

  rnsec3.encode.bytes = offset - oldOffset
  buf.writeUInt16BE(rnsec3.encode.bytes - 2, oldOffset)
  return buf
}

rnsec3.encode.bytes = 0

rnsec3.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset

  var record = {}
  var length = buf.readUInt16BE(offset)
  offset += 2
  record.algorithm = buf.readUInt8(offset)
  offset += 1
  record.flags = buf.readUInt8(offset)
  offset += 1
  record.iterations = buf.readUInt16BE(offset)
  offset += 2
  const saltLength = buf.readUInt8(offset)
  offset += 1
  record.salt = buf.slice(offset, offset + saltLength)
  offset += saltLength
  const hashLength = buf.readUInt8(offset)
  offset += 1
  record.nextDomain = buf.slice(offset, offset + hashLength)
  offset += hashLength
  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset))
  offset += typebitmap.decode.bytes

  rnsec3.decode.bytes = offset - oldOffset
  return record
}

rnsec3.decode.bytes = 0

rnsec3.encodingLength = function (record) {
  return 8 +
    record.salt.length +
    record.nextDomain.length +
    typebitmap.encodingLength(record.rrtypes)
}

const rds = exports.ds = {}

rds.encode = function (digest, buf, offset) {
  if (!buf) buf = Buffer.alloc(rds.encodingLength(digest))
  if (!offset) offset = 0
  const oldOffset = offset

  const digestdata = digest.digest
  if (!Buffer.isBuffer(digestdata)) {
    throw new Error('Digest must be a Buffer')
  }

  offset += 2 // Leave space for length
  buf.writeUInt16BE(digest.keyTag, offset)
  offset += 2
  buf.writeUInt8(digest.algorithm, offset)
  offset += 1
  buf.writeUInt8(digest.digestType, offset)
  offset += 1
  digestdata.copy(buf, offset, 0, digestdata.length)
  offset += digestdata.length

  rds.encode.bytes = offset - oldOffset
  buf.writeUInt16BE(rds.encode.bytes - 2, oldOffset)
  return buf
}

rds.encode.bytes = 0

rds.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset

  var digest = {}
  var length = buf.readUInt16BE(offset)
  offset += 2
  digest.keyTag = buf.readUInt16BE(offset)
  offset += 2
  digest.algorithm = buf.readUInt8(offset)
  offset += 1
  digest.digestType = buf.readUInt8(offset)
  offset += 1
  digest.digest = buf.slice(offset, oldOffset + length + 2)
  offset += digest.digest.length
  rds.decode.bytes = offset - oldOffset
  return digest
}

rds.decode.bytes = 0

rds.encodingLength = function (digest) {
  return 6 + Buffer.byteLength(digest.digest)
}

const rsshfp = exports.sshfp = {}

rsshfp.getFingerprintLengthForHashType = function getFingerprintLengthForHashType (hashType) {
  switch (hashType) {
    case 1: return 20
    case 2: return 32
  }
}

rsshfp.encode = function encode (record, buf, offset) {
  if (!buf) buf = Buffer.alloc(rsshfp.encodingLength(record))
  if (!offset) offset = 0
  const oldOffset = offset

  offset += 2 // The function call starts with the offset pointer at the RDLENGTH field, not the RDATA one
  buf[offset] = record.algorithm
  offset += 1
  buf[offset] = record.hash
  offset += 1

  const fingerprintBuf = Buffer.from(record.fingerprint.toUpperCase(), 'hex')
  if (fingerprintBuf.length !== rsshfp.getFingerprintLengthForHashType(record.hash)) {
    throw new Error('Invalid fingerprint length')
  }
  fingerprintBuf.copy(buf, offset)
  offset += fingerprintBuf.byteLength

  rsshfp.encode.bytes = offset - oldOffset
  buf.writeUInt16BE(rsshfp.encode.bytes - 2, oldOffset)

  return buf
}

rsshfp.encode.bytes = 0

rsshfp.decode = function decode (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset

  const record = {}
  offset += 2 // Account for the RDLENGTH field
  record.algorithm = buf[offset]
  offset += 1
  record.hash = buf[offset]
  offset += 1

  const fingerprintLength = rsshfp.getFingerprintLengthForHashType(record.hash)
  record.fingerprint = buf.slice(offset, offset + fingerprintLength).toString('hex').toUpperCase()
  offset += fingerprintLength
  rsshfp.decode.bytes = offset - oldOffset
  return record
}

rsshfp.decode.bytes = 0

rsshfp.encodingLength = function (record) {
  return 4 + Buffer.from(record.fingerprint, 'hex').byteLength
}

const rnaptr = exports.naptr = {}

rnaptr.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.alloc(rnaptr.encodingLength(data))
  if (!offset) offset = 0
  const oldOffset = offset
  offset += 2
  buf.writeUInt16BE(data.order || 0, offset)
  offset += 2
  buf.writeUInt16BE(data.preference || 0, offset)
  offset += 2
  string.encode(data.flags, buf, offset)
  offset += string.encode.bytes
  string.encode(data.services, buf, offset)
  offset += string.encode.bytes
  string.encode(data.regexp, buf, offset)
  offset += string.encode.bytes
  name.encode(data.replacement, buf, offset)
  offset += name.encode.bytes
  rnaptr.encode.bytes = offset - oldOffset
  buf.writeUInt16BE(rnaptr.encode.bytes - 2, oldOffset)
  return buf
}

rnaptr.encode.bytes = 0

rnaptr.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset
  const data = {}
  offset += 2
  data.order = buf.readUInt16BE(offset)
  offset += 2
  data.preference = buf.readUInt16BE(offset)
  offset += 2
  data.flags = string.decode(buf, offset)
  offset += string.decode.bytes
  data.services = string.decode(buf, offset)
  offset += string.decode.bytes
  data.regexp = string.decode(buf, offset)
  offset += string.decode.bytes
  data.replacement = name.decode(buf, offset)
  offset += name.decode.bytes
  rnaptr.decode.bytes = offset - oldOffset
  return data
}

rnaptr.decode.bytes = 0

rnaptr.encodingLength = function (data) {
  return string.encodingLength(data.flags) +
    string.encodingLength(data.services) +
    string.encodingLength(data.regexp) +
    name.encodingLength(data.replacement) + 6
}

const rtlsa = exports.tlsa = {}

rtlsa.encode = function (cert, buf, offset) {
  if (!buf) buf = Buffer.alloc(rtlsa.encodingLength(cert))
  if (!offset) offset = 0
  const oldOffset = offset

  const certdata = cert.certificate
  if (!Buffer.isBuffer(certdata)) {
    throw new Error('Certificate must be a Buffer')
  }

  offset += 2 // Leave space for length
  buf.writeUInt8(cert.usage, offset)
  offset += 1
  buf.writeUInt8(cert.selector, offset)
  offset += 1
  buf.writeUInt8(cert.matchingType, offset)
  offset += 1
  certdata.copy(buf, offset, 0, certdata.length)
  offset += certdata.length

  rtlsa.encode.bytes = offset - oldOffset
  buf.writeUInt16BE(rtlsa.encode.bytes - 2, oldOffset)
  return buf
}

rtlsa.encode.bytes = 0

rtlsa.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset

  const cert = {}
  const length = buf.readUInt16BE(offset)
  offset += 2
  cert.usage = buf.readUInt8(offset)
  offset += 1
  cert.selector = buf.readUInt8(offset)
  offset += 1
  cert.matchingType = buf.readUInt8(offset)
  offset += 1
  cert.certificate = buf.slice(offset, oldOffset + length + 2)
  offset += cert.certificate.length
  rtlsa.decode.bytes = offset - oldOffset
  return cert
}

rtlsa.decode.bytes = 0

rtlsa.encodingLength = function (cert) {
  return 5 + Buffer.byteLength(cert.certificate)
}

const renc = exports.record = function (type) {
  switch (type.toUpperCase()) {
    case 'A': return ra
    case 'PTR': return rptr
    case 'CNAME': return rcname
    case 'DNAME': return rdname
    case 'TXT': return rtxt
    case 'NULL': return rnull
    case 'AAAA': return raaaa
    case 'SRV': return rsrv
    case 'HINFO': return rhinfo
    case 'CAA': return rcaa
    case 'NS': return rns
    case 'SOA': return rsoa
    case 'MX': return rmx
    case 'OPT': return ropt
    case 'DNSKEY': return rdnskey
    case 'RRSIG': return rrrsig
    case 'RP': return rrp
    case 'NSEC': return rnsec
    case 'NSEC3': return rnsec3
    case 'SSHFP': return rsshfp
    case 'DS': return rds
    case 'NAPTR': return rnaptr
    case 'TLSA': return rtlsa
  }
  return runknown
}

const answer = exports.answer = {}

answer.encode = function (a, buf, offset) {
  if (!buf) buf = Buffer.alloc(answer.encodingLength(a))
  if (!offset) offset = 0

  const oldOffset = offset

  name.encode(a.name, buf, offset)
  offset += name.encode.bytes

  buf.writeUInt16BE(types.toType(a.type), offset)

  if (a.type.toUpperCase() === 'OPT') {
    if (a.name !== '.') {
      throw new Error('OPT name must be root.')
    }
    buf.writeUInt16BE(a.udpPayloadSize || 4096, offset + 2)
    buf.writeUInt8(a.extendedRcode || 0, offset + 4)
    buf.writeUInt8(a.ednsVersion || 0, offset + 5)
    buf.writeUInt16BE(a.flags || 0, offset + 6)

    offset += 8
    ropt.encode(a.options || [], buf, offset)
    offset += ropt.encode.bytes
  } else {
    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class)
    if (a.flush) klass |= FLUSH_MASK // the 1st bit of the class is the flush bit
    buf.writeUInt16BE(klass, offset + 2)
    buf.writeUInt32BE(a.ttl || 0, offset + 4)

    offset += 8
    const enc = renc(a.type)
    enc.encode(a.data, buf, offset)
    offset += enc.encode.bytes
  }

  answer.encode.bytes = offset - oldOffset
  return buf
}

answer.encode.bytes = 0

answer.decode = function (buf, offset) {
  if (!offset) offset = 0

  const a = {}
  const oldOffset = offset

  a.name = name.decode(buf, offset)
  offset += name.decode.bytes
  a.type = types.toString(buf.readUInt16BE(offset))
  if (a.type === 'OPT') {
    a.udpPayloadSize = buf.readUInt16BE(offset + 2)
    a.extendedRcode = buf.readUInt8(offset + 4)
    a.ednsVersion = buf.readUInt8(offset + 5)
    a.flags = buf.readUInt16BE(offset + 6)
    a.flag_do = ((a.flags >> 15) & 0x1) === 1
    a.options = ropt.decode(buf, offset + 8)
    offset += 8 + ropt.decode.bytes
  } else {
    const klass = buf.readUInt16BE(offset + 2)
    a.ttl = buf.readUInt32BE(offset + 4)

    a.class = classes.toString(klass & NOT_FLUSH_MASK)
    a.flush = !!(klass & FLUSH_MASK)

    const enc = renc(a.type)
    a.data = enc.decode(buf, offset + 8)
    offset += 8 + enc.decode.bytes
  }

  answer.decode.bytes = offset - oldOffset
  return a
}

answer.decode.bytes = 0

answer.encodingLength = function (a) {
  const data = (a.data !== null && a.data !== undefined) ? a.data : a.options
  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(data)
}

const question = exports.question = {}

question.encode = function (q, buf, offset) {
  if (!buf) buf = Buffer.alloc(question.encodingLength(q))
  if (!offset) offset = 0

  const oldOffset = offset

  name.encode(q.name, buf, offset)
  offset += name.encode.bytes

  buf.writeUInt16BE(types.toType(q.type), offset)
  offset += 2

  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset)
  offset += 2

  question.encode.bytes = offset - oldOffset
  return q
}

question.encode.bytes = 0

question.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset
  const q = {}

  q.name = name.decode(buf, offset)
  offset += name.decode.bytes

  q.type = types.toString(buf.readUInt16BE(offset))
  offset += 2

  q.class = classes.toString(buf.readUInt16BE(offset))
  offset += 2

  const qu = !!(q.class & QU_MASK)
  if (qu) q.class &= NOT_QU_MASK

  question.decode.bytes = offset - oldOffset
  return q
}

question.decode.bytes = 0

question.encodingLength = function (q) {
  return name.encodingLength(q.name) + 4
}

exports.AUTHORITATIVE_ANSWER = 1 << 10
exports.TRUNCATED_RESPONSE = 1 << 9
exports.RECURSION_DESIRED = 1 << 8
exports.RECURSION_AVAILABLE = 1 << 7
exports.AUTHENTIC_DATA = 1 << 5
exports.CHECKING_DISABLED = 1 << 4
exports.DNSSEC_OK = 1 << 15

exports.encode = function (result, buf, offset) {
  const allocing = !buf

  if (allocing) buf = Buffer.alloc(exports.encodingLength(result))
  if (!offset) offset = 0

  const oldOffset = offset

  if (!result.questions) result.questions = []
  if (!result.answers) result.answers = []
  if (!result.authorities) result.authorities = []
  if (!result.additionals) result.additionals = []

  header.encode(result, buf, offset)
  offset += header.encode.bytes

  offset = encodeList(result.questions, question, buf, offset)
  offset = encodeList(result.answers, answer, buf, offset)
  offset = encodeList(result.authorities, answer, buf, offset)
  offset = encodeList(result.additionals, answer, buf, offset)

  exports.encode.bytes = offset - oldOffset

  // just a quick sanity check
  if (allocing && exports.encode.bytes !== buf.length) {
    return buf.slice(0, exports.encode.bytes)
  }

  return buf
}

exports.encode.bytes = 0

exports.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset
  const result = header.decode(buf, offset)
  offset += header.decode.bytes

  offset = decodeList(result.questions, question, buf, offset)
  offset = decodeList(result.answers, answer, buf, offset)
  offset = decodeList(result.authorities, answer, buf, offset)
  offset = decodeList(result.additionals, answer, buf, offset)

  exports.decode.bytes = offset - oldOffset

  return result
}

exports.decode.bytes = 0

exports.encodingLength = function (result) {
  return header.encodingLength(result) +
    encodingLengthList(result.questions || [], question) +
    encodingLengthList(result.answers || [], answer) +
    encodingLengthList(result.authorities || [], answer) +
    encodingLengthList(result.additionals || [], answer)
}

exports.streamEncode = function (result) {
  const buf = exports.encode(result)
  const sbuf = Buffer.alloc(2)
  sbuf.writeUInt16BE(buf.byteLength)
  const combine = Buffer.concat([sbuf, buf])
  exports.streamEncode.bytes = combine.byteLength
  return combine
}

exports.streamEncode.bytes = 0

exports.streamDecode = function (sbuf) {
  const len = sbuf.readUInt16BE(0)
  if (sbuf.byteLength < len + 2) {
    // not enough data
    return null
  }
  const result = exports.decode(sbuf.slice(2))
  exports.streamDecode.bytes = exports.decode.bytes
  return result
}

exports.streamDecode.bytes = 0

function encodingLengthList (list, enc) {
  let len = 0
  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i])
  return len
}

function encodeList (list, enc, buf, offset) {
  for (let i = 0; i < list.length; i++) {
    enc.encode(list[i], buf, offset)
    offset += enc.encode.bytes
  }
  return offset
}

function decodeList (list, enc, buf, offset) {
  for (let i = 0; i < list.length; i++) {
    list[i] = enc.decode(buf, offset)
    offset += enc.decode.bytes
  }
  return offset
}
