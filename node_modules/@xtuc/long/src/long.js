module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @this {!Long}
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @this {!Long}
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm["mul"](this.low,
                              this.high,
                              multiplier.low,
                              multiplier.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @this {!Long}
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divis¼"ójŸeqfÅÁ™tB†Ú‡Š)ALBE¡	Jæ—ç
“r×~DCÁÄL¬¢Ş±Pş"“
‡EªoŒƒ†K}´¡¾ Ç¬#-ä¹%6t"<¦Ç“k]J±­‘ıÂ:'_¾™Áõ4m½NJ‹*±TeqµâÍ8+±5D–i\é`ËlM=ÌèïÀøXç¼w1¥"h±…âª¹Ìç2x5Vß"SB‚ŒşnÁE>T)Ğ•Rå½ªò#c~8ÉU|ıdùÍBåËÓÌ{fw
ª,±Ûû© MæPÔ²ÏÁ
¦æh…ÇÖkæßa(Hû9D†XÌO‹ÍZ_:d`6Ø5‘QôüÇílhQ}e)7 µÁçÑ­ÔŠêŸ(µÕ ò„XÖÄmXÉÏ^EË£'‰¯¤ûŞ»‘*¦g.„ìµù­ñ÷[ÆùÆßÛ\€¶£™-…-¨ú8Y‚ñåŒºèl']nL±IŞïBP‡•À>æk7!x¡¡Ò¹®˜UÃÚK’Â5`\Ö¶ær·.é<]¨1t•=^q¡—©Fª«¹0É¨Cßa€Şöö8eSs%p×È¬TÖÆlÔr¥¹ô Ûne¢ÿvXÜa“\°/¶HBÁmÕ(-\Œ‡é–¤ïÊhàİÓ®²¼=ºc…opYHâõÌ˜ãKë¬ĞxVd?¦ès×]ÆÕ@* ÕÜÄe°ºìHò©Ä‰Y3gjÊYISÉ‚9,Î­e‡£n0ä—0ÁÇ³/giJ³¨Á}´Ø×Â¿$¦UâRø`/Æ~xíòÑû„µå?:hµ=_=©çvºÒıÿu f5÷raùˆÑÄ™YÀÒpZÆŠŠÓÆe¼sÎ+—¢ïüwŠ°‹K“Å‰Cy,ç1>XÌüâUÆĞC›Y)ë¯¢-!]>¾ÖævÆ„”¢E/O ¦«K€°€iMÉd³Ü"öúWl[P`³‰Í<Ñc±¯ºì*èW`# äË¤0²+@õqôQˆm¦ko*ä³&õRÅ<İzÉõşwôAQbXâ%2Û03ôÏŒùûÅ¹ Ã%<:DıŒ_ 4Šªâ¯ş¯}˜ X¤¿ˆy÷ĞÜÇÿÿ‘¹±ßœ°ósÌ%‰mÏe´I™B@Ş”RÈÚ)È3ôÉØ’k-/ÖÆ¹./˜ÛRğ•Ş±"hªùdp–Ë—7ş•¿èğ~ÙénMMÛ%yGÙzv‹¸¥s"ìEbÊWr DzÂ¤.’®†,Ç,«PñKŸ ×“9‰[Z…AkŸl$×µJŸÊã†—†úPEj²mR”7ÇGW­É]µüìÌ¶,¢ĞÎ©¶à8Òºõ}_L¤‰ól„µô!î‘,¹bÎQ%—2ğ#EóóL\¤0:ÉM	ªccŠ„áˆûsõÇ>ˆ$)¯,ªĞKxÁõzë\lùŸäŠ‹{ dÑô©Şˆ"Ã]_’~î~äFRc³Ğ/¸2¸•Lƒ>c?ƒl™~Îè0vd}üCº
4­Ì:˜™Ó¢scmBmL»A§³njãNi961»ì.p8Éº±”tÌmî#Û#²c¶DşŠòcy`Õ½¿ı°9eÄt«~ªƒV(Ôş[ YŞ”©^z†I®L·õ‡OÂ¢á®•W /A½¶ÿ˜ßÁÎİjøJqbÑÄò©‹^^±
>~Í(°fğÖè·³¦^Ø|Ê°C¾¸ÉëœPÛöö”šÔá}£¼–Æ}»zÅÅª`ì|²şPˆ—ÏpÑ€û‘@î§kÅpş_Ì|ıIbÿõÔìy|C.®Ø>sân2’ûJ(3Jüˆe|Ë2F(}U  Î–¸øQl[ØIÍ¯èÆ>]vé‡bğo³$ë{qšµËé³]Ëû]	}ë÷4bÅEaÇ?£Ç†…ƒü0¤o­„€O¦[^D|40Û……3Âød—«yÉá{–%àÖrØ²ç=”P‚nÇXöoË²xÍ¥ÛaıİD³¥ûè¤H‡÷pË±2¨X¸¤PÂ-¾ËÆãıØÛÌ/m6ë¡s;Ó[˜İÇÙç~Æch]¯êi©á-×5Õcµ…ÊäøÖÍÄ°Àü•Óv¶»¼jé¸©¿«N^€WÏQ%˜ ©Ÿ~‹âns:˜jÎV²à 6PÔ[¶6îåâÆ.w¤æN&u‚FaVÕ
r–BI-±Ÿí~¤ãË–GÒ9©
±}ùf ñÔn€˜‰X/&Ñ8œÂô…ØãLU=M6BŠöeAYX¼
¢¿U.ÌæŸôÁ<ª]?´ÈÅøgûõ©Û6C7?Ø·Çy˜†ôØvµS”æ—<Rx°˜¿ÀêéŸGÀBŒê‡ÒgÈ©[Z/Â-œ–ê!u”4G'°ï|£ÜÊye!&›ÜF"0UÌ¿•6ü¹í9nxáaZ1NÎu6485º²ÒÌÉ×u€F´ñ½WÏ§¤ ½à]¬icïØoÀ¡’%ÊŞ#¸«ŸØ`0|'æ³Ê‘P!9•|0òsRÆF~w[gõCvÀÀ‡<f½¼<krÿø:fPÂÈßÁ²êÿ?Wı-¡ÕBÿÿ§ˆü 4‰Ïg$5, 
YK ·}O‘îútª)2?ê	•°~68ZÖFVÍÊ«¸v"{ïá·F§lõ·‚Ã*¾O%b’òrşšŸ‡WMû»sŸC_ñ·}h»Â³Ó¸µ±Ğm -héÒsÁj{°Ù
3R›ÍZ¶ëeÏÎw;µ?Ÿàë,¹M+•tˆ/WîØr”¸‹³©ß¶ç4hÌi¦ùĞÓ[‹W
B"÷ø'f—jÈ¸†Nùk4ğ°‡ë¼ãˆĞïWØ}ôCçqÌª—ÀŒm2k‰Exı³…%³î¯ãXĞbâKt˜J«{.yW‰'cc°vò‚öY»·BHTºn!e‘ÌÉI³kSƒ¹8–ôÙ¼×¢¿pÌ_£ßo]‘ıô€Ÿµ-FÁ\r[k6BÂ+‡öådÄ.üŞç+35¿j (•ÍÆ­^”Ÿ?½å°û†% l–öˆ¼ŒüH¾6ÌÍÏå7î3ÙšsJ×ƒÌŠ5Äô”4¾Ş¼DîP!Zkå¢¿MS<•U^C——s y!õƒ¾°F»;)qmèt'P,lèßâà‰bÅ†'YK{ÂèÙÓ˜W]
.+Í láî¹jØ,`qÜ}RóÖpğÆà™jÌhà§EûDKÅ dŒÄ{FCõáG‰2h jMÑ“‚¦ )ÇÅeá0£>Ó9Ã°"ïÊ8Ä+vE/Â¾W5ñ6Î’¥É3›gQÃœŞ¥É–ÖIô“ñ-‡ï`²…ÍjU_¿cúŸêU\?D4ÄuÖ(ğ‹«!SO2-DÊFh-9Ú¥ZW¥Ÿc—G®`O~TÙ)OçSvw%·ŒuÔ'yR]†¯óå~æYí1øğRZZ™u ³5fßÒhñ_ŒxRˆ)ª$1·E™Á6ÔÕàÌ¾Mû$ºôµt°LÓT€³æñLbÃúŒÛ<¾ïËg7‰ iŠÜ´¦nBeáŸ_EvÙƒ1ı3¡F+}'	74—?um–rìksq
):¦ngöìçVÈ¼pÕö0b¢›ƒo:[É‘1dÚÀ¡Şd¤.øS‹¬ÉñQ¹Í™(át'~ß´ı©V60Şî˜OÃ>ñ¤Ö(PôĞ&yfŠ¬{ÎË<ÌríÕº§ŞvXÏ(×…ò)¬îØE\©t}vÉlKè³¼åÇ}W0Òø°Úwís?Ö³læ}ö¾N!¤ø>€JDôIÀ’›{ìÀ÷$Múdñ…i©õ7­&ö>vöp—ÍÁùèĞ<v–h^ÕÜ°‹úšûµÜÂ¶|˜}YÊîª·¿!PéË ¸œôş`îÿ]Éğìß4ñÿøşzş…w”uSƒ“nş“l©L#es\Cë–íşàâ(è×7”X+
šãR…m7-29EC›=ÖŒHa(L®};[o=o~}sw­F˜Ú¡‡°0ÕBGKjFá“– ËhEú±È¨(7pî‰Á¾pÊçZŸ­­†mCÖ”qMk•¡®¬«ÍYÌ!
?#këàİ9µ®ÑçÍYõœu†şCWïlA+Ñµ¨şHp>Ö—/çi‰T­òùV‰ŞôÙø¾­tÄ÷GĞœ®f¼>ôµ3%ù%¥mx¿AÌ¢ó“óœY@s®$3MTs¼ÀY“ª‰Ä/×7„(­ QfÓf¼+xº)†±‡/?ÉîÕõGsï¾¨u_…¼H‡¾òªƒ›•VÄqè â‹ÁÎ/=Ê…)Š‰|„„—±DRüE¹×±·…V.ÖZK°zXÅ¥Â
†Ä1œ·òd“ú¥:šüF2LÚh<[Âµ°>;\š¬;ø^›™*õåÓG§G§†¶—Ø£(ÇÕ2H‘l–d*Ÿä!/P¾üØÏnÌ¾ï’(Ÿ mœ 3dÛ/€Ò(¨Ø?’ƒt¿ Ì
mNìƒ::¸¡Ô##&(¶Kš-q­|,ûMd*°T4Y|TP<´äâo‰E	q0ÿ$Á!uğÔ:†Ll>ò+t–'É?œ…0%ùù?®;›1©YH?öÅWv¤á @È^}F\ <@rƒöÊ%	å`=¾~EšzCß]œ!Æ°áfY/÷Êÿ¦ØSıÂo°ŸéÛı±ÉÚıÿ®*Àÿ^ÇÜ÷Ÿûÿ—­«WÌ}Øİ!PXîxY¡“`¹ï(N†+‘ˆ÷³]é_~GÏePôø?™÷rôÜıÕPñdp‘D9
®ÁÖÎãÌU½½ûŸ7¼ÒüìÈIñÃ,êáƒ©9ü;òe¦ÙÂûÄ‹q>’)A„Üã›n—µ…eæß)wZ«š©Åá®Åå<9JÃD=S½{táµ­z¿NÙâ^‘ÇÈ®Íh”£&“ğô°ŠdùB”£(´-~CA€İí×J²]&£½Á bs%º+”¯V1À¬QØæãÖ¥†úÖ:eÁà)ÂQ/“øœîJw¿×K—ûçş¯zÕÙ§óå÷µ”(‚f§AİÇï1ş=k	˜×nÚn<¹™(ºÑF¬ã‹…<|›³G»Ò±i…}´ÀË?Cm)ºiŒü,Ú¨Ú˜tsKvµ[LM&ğjè¡tà'ìUsöÊšÆİ""MVØ1ß”Úâ5Ì(ÍV{­İĞoóN€›Æ»`¯¤Ä»È¯™fªİ‰ . ±OáÍï¨…ÀQ.+†V¦q2ŞI‡rkÇâÉZÊ‚ÿ3÷ÂÅu(}R™ä=V7–Ö(Åâ)´<[†æ!¿] ÿÑ@ŠŠ×ºÜpBé~;Fòh6åZRööA,ÚÈv_&û”G”ºnĞwûí¹ıß…¹ù!tk¯Ô•´Şw:üå×$.5ñ±¾ƒ?êcäÌ+úñâusEë‰Ö´N7ÑjBn€u¨Ñ41ú„¢˜s©ìˆ6	ÈKlNUÎÀ½áÁ„s99\0a0´r·É?™]Z‚}˜|Ñ˜÷ËHg[ìgO…gãç`Ğ&FEHu“4iE'wL€,÷~âì.9ÌA^›ş•sÈy|£©ÿE9@õ}ïßAĞĞ%eÅ?«ïR÷üÛj$ÿà¸*Ë‚®“z†„&C³!²†Ïx– G>°ñ‡ÙÓÕÒn_›iœG‡„ ıt`ÎÎŞw ÂŸÕg¯×–ƒúvDÿ_®—L‰A0jY©—†Ğú|O:¢õÿ†Bfde±•ÆuØŸ™Émê\S»ëÒ¿ˆ…ıØ¸”ç?<¾/£1 ÖM!Y'yËB6¦J­“Ë‰dõ‹DBnE_F†eô³aõ¢é*[‘<cÙßÖV¬u@ìq¦Ô®U„§ (ÆpòCí:ºËuÅÈfe6LST®(ïG´Â>E…É“Cu1Uz=¿ü”ä^ƒŒ#$OLóo‘~’îMgj‹}Ìu³düØºPƒàXvÔZ5Z|}¡j|ànU±zS2îp¦0_@èËšKğ[›¯ÅH¤Á±WAN —<ãŒ)ê¯¦àÜì_Ò×akÎY§ˆ¶›¸{üÌ³ÆwÁs¾IzîÌÚúğ)/_q„36ÂL\$dkfÑš üñæ,3¾º£ÌÔ?ïl´š¹éàz×R¨z©Ñ,B}ç—•I™Y?TTíØÅnsùÎââñ»±1d™•µ¬'ÍJ 	Zò¤ã¤/ör˜£HœeN-¦WˆßâæJ¹uõu»)¹§¿§jm½\Š×gs¾õ‘Ó5îcÓp~”åxjú^”¥­1ø`Õ‹ù(`Zs¶ÚZ¯Àú¹°Î=‹ñf¶‡6ŞNa;¥ß–/>›¨—½"ä•7pÍ"a´M”;ÏŸBC´’|Gó1f:wCÂ^·­ñ¥?İ¢= Ä{­ìŸ›_‡3—¸uòa_~8p­èRZé>ùc¦Díôæ¨3ãâÛ”ÊàW»¤•$éXB6O¦‰œ	ƒƒÀ	P÷­G¢¨9ÿ° Ò‰KÔê]ã­şùnşS$Nñ¿½Hş¹²íÖea¿AšaÉ:§0‘\tÂ2¢ë´¯f(‰¾êZæ&Š7ŠEğw<$
¼°üe¹Xõq´ŞZj[–—‡>_£>q«ŸßæòËÌdùÏÄnçL†,]±uY`Q¯Ë×¨àEï³ ´p2EfÙ›Tµ¯¡ƒ ?±YóœwâÒK‡™Fêì­áz£‹ñ¦çmif˜f¡{(¨tÔb|ÎZë‰%®-98 àÜÁëhòx €¹RÑ$³×ŒÊ1=Qr×qe5'Úóª7m©’Î‚à_%êK¿cíz €aº4¢y”hÒ¸>=òát­ ÖÇ•§S4ª3M×^ßê1šû›1(Öò!}*šº†Õ°œĞ"*5²´È_=7Ÿ”­Í­jPJ"¸ûÏSAf$øF²2®0‡¹ë›S4
õhe´µ–ÛŞ¤½ö4g|´"]h0„õ®Íî{ü†áXÔïmà¢¦1G3¢ ê3à•à†ÍvÆ¼±mª)_’L5‹†Ë1`ö—åÿËÅØ¶î­-!SöHsÅ8pÑQ.Y‡yRhF°)¬ÚówkúP#Oßßnyñcm¼Êù¤1 Ô›œß¤7î÷~9Ğ+œ¹ç.qma|±!ümg=ĞSTÀzÄ¼6Ù›Z³8>gG(•@Œ”ä—
÷9cÙàì`{:wàYg!ûÆPw'Î¼Ê…§ñ/8µŠãgíI©±JíÄ÷ bL—&¼eA![¼ÙGrr¼ôu@tŸZ¢åfóQ$ÉØû‹h74nºâ—ô@¢>_ô_(¤ÇJTj¤Wˆ¹%BĞòn‰Ì©(•ÿ“´ß÷ÒÂl*Šµ ìeC†4øQÊ©íq¼àŸ(‘$8QÊ|í
şèUôt2R$È®qß(õâí_õ·¾¤›ä;¨ñG=qÜ6ó@Ùıy}Ö;BÚu·±–!.-¾«°îCü0Õ¹ÇkrĞæµ²Ã=j@ë]Of×(w2n@³Ï\£"‰Ğ€<k™‘¹¡Ul±gëÓ5µ¡P´0RÌ¢ ³$ĞõÇzÒ§×ı˜Ÿ^
õq_UºæËä’hwº2°mš ?2}gtÄ	oŒó­…”pg?H+ò0\‚€¤aı$ì«¢^ëâ"wÏ‰qVø³ãõ¤Qû.å‰”’1ØcÂ4?Øø‘ĞfS-ß„¼.¯KÚ¸Óû¡l¹AŸäcrŸ!Ö‘n<è_­N(>›ÜÂº¬q&œºÜ¦ó> åF‡*Å¨!é¶}(`^wñÏŸea¨İl.hç7şÈfÂ’C”ÏĞ‘ìmáĞ¦¶ÏüñÈèzéş…±#ÿVózó?#rçõæKÀç¬‰Æ+@CëA—R?J ™PĞ¨X“†dŸ ‹GıA—Vôüèæ×H@ù2£ R„C®ßõÛ;-ûzº]òŒ’Fkh1WÛ­:öîîúÿ¢¾ãÿ.ÑwCÓ±°Ü£ÎÓ!‡Ëß š‚Z‚5•)k‹p­…(ÊïÍLeNbÄÅŞÀßŞ#eEeÌÚñ«ªq-†¸âe÷ÅeÀĞ‘Ça{ª~5JVèÍó´¥tuVA„Ë,åÕüË\Ë”Ø.2MZ øEî€´v‰ĞX1D×G™Ri%¤ŒË¬‹ŸjJ(]ªqíGB‡5×hBšÆ%‰š‹Ÿ´¸œYå/3º>ºwëÌøS”Ô’WhHY:Í>…H­rìtÆğr
j	$¿y_¬&Õ“rĞº^‘ŠõãW.«e¦2‰†Œ`S¹è,XÕƒd ûEwæÚb~…ç“²UîT„äÃ’½†ñ©¥çÁt:fÉ˜Û¥Nª„
a¬•‚ƒ–™cÅU:õ:]Z²~Ä¬Ğ
"KZj|Y@Jƒ±s,ê€Ä¢D Ö‘åü¥á¼æÚú5‘å:NdJ0¾‹«™·ÑÃ1÷;z=ƒJƒe¶+IÿLd5Yø.}Eâ½…†æà”0UŒhO 9(¤ÔiUãZêX}uĞ&JI¦).ÂbUZıƒàÄÕ,[ñ‘ˆ¬g¶Vué­j€Ë?`w^­ ,%õr|Äz+îxrˆİPÃŒ0÷šY”Ç*Óõ-(±B±õÇÄe7›Psñ!—,èI}z”ügª¬­øX×3¾‘•<šg°½Ïq>)U­¬‘tt®¶U¶œ[N,bP2NJ^'p*^ò+ı±–}™ĞĞ€]+Ù×p¨g·ú¿@D„@T'9Ğç¥F)û€‹T¸Ü\¶{?!
„¨8°Œ)’Øèª;ÚÄ3:ùQÑpÃ'»ğ ¯‹kAPjÕğMÑëøJ
zÑ{n.1¹übH¦Á…è¸|Ø_Œu*Ê~N·Ğt±Qá¼ ±+Ş”±$ÒÑ»R…møº2OV—°‚iŸ¼Ït‘iÆQ×=â\Á†ÚÂ=ò[jÍÌúâå¨ùætŸŒ
y=t¯Y¸áÖ%y‹J;dl,’p8õé‘«~$k@8ËÌ)æ•/ô®ê—Y©”gûu’;Ğ<ò]~%ãK4œè5)zû?ºœÕªE48/¼+±JX‚å¨¯ÃŠ6®áÛ=:òXà™“Å(ö»ëÙúî;,ÛñGZ–™5Ò¼şŞ&™®Á5Uà´7ÅN–nº¾°ú¹Vì­qvš¾X"í´ŞøÕİg¹y`?Mïüè6ögø‚†Ù€€z»]ı…¬Ü¾€äšŠVŞ   =ÊÃhÚëŞ,›C?™±àL²ßŞEşØ¿à‹‰Şïòexğto}·²p-(néXñ›lÔ¤.0—ûÔü( şî$\Ñ9-¬RÎ^”b¡V÷ñ%´SÄ¢yFáN[yw"Êmà@iüÌàvU‰®)ª‰@ÒeÅ–K¹¦]İ Yd¬2ÀY¡XÌ#ÂKøä>ìP›y­?lÇ6Š-§¬O
ouì1;"Ø±´‹‚ËÉu@Ït×ÉfÖ(ş„µpÔï:Z¯ÕoIßÀ¢z^ãß¯0,ù¤ğÄ§ÿ¸oç« œv\±¬¯««´XíÂú“Ş3.¤ºê²§Ÿš¬Üs_rU‡{İ_ WiøòI¦É›:ãH“Ù„!“µyñ3¸U5İ—Mã¯İUÔÒw4‚7Ø*×‹ú¦ßêµU'öB±¾öOköE7üâ^z16ôÌ.M¿‚"ÍôÆäsö;Í@­¡ŸŸpâìûq?=f™ªPºì¡kÍXY[
3†>¤PÉRĞô¤'¾}øs‰Ê
8#rXRHŞô‰ÕèvDÖmMœŸvwÅÈ ÏbÚp§òvD•çì#a©“Ì¼m¬ßOX€ÕnÒ†Ç:€—“®Û'¿ÉRÖ¡äÂHÊ¶MZ6À€îºgzJBE¥Á°<o6ùÂ@Ÿô»„ƒ€¾¨h<K’¹¤®¸ÿ¹4ˆ¥ºæÄgIz)ª‡x2ª}s°ú¨$`†«³^ÈB%„*÷ÈP VÛUBáNKCœ–ß²p¯Ó!°¾×eı™c3n*Ñ”aó3TLy—áÊOâp+¥õèÑ@¤
5˜ó¢èÛoè€/çÕ¥Z´çoâíÏ.K5k‚ù…>Ñu+.QãÜã¾1œê·~Hü•fÁ‰”xŠı'­”«E,_'ˆ”†š…ÓmPôv,ò‰‡EóÕUôB
×(ïùH–Fi#vrtØå{!bVe¤ÏDøÅ­é°p9ráä'*½‹Ö@ |2•mÈ¯ÜıÇ«üØõâÍ”_¦	³
%U:ƒ—ŞS4'%ÇÎ h½¯ğ›§†¡’›[ùñx8Æ³!‹Fš1K^Qw¶LØ…–üx+}Xu „oV¥U“’£©Ó1±WX£Y«ï§p&/&{j~Rƒhò¼Ü¸î_' ­ğö9µ nnä ËıN=İb	ĞTò _´‰S¦abÅã:øÿPˆLó8Ã†Âw;æƒuÆÚV‹¸Lõ÷–O)áq2™dêÃ>'µ:ÔTU=Ôâ6^q2‘CUÆNœˆ¥xr˜şAEØ5(:ÆJq§.£åcGŒvó÷R²ªmª]¯ÛÜo+³ÖMğ‘øŞ¢ ¢İØÿÏPm©ïiúğ\,Ò2•¥zì²<WØ¥@İâª««ÎOÊéÕûÑ)‚¨AoÃw…b¢%NWå„¢WµoØ‘ù{Ÿ×âB›Ğ‹9iEÃ³RØ
“ªúƒÅ^±—µŠg€ş'¾ÛtìË]ß†Ëaı1xiĞ…İ¿á4¶àFqåÆ%FÕ¤íA<.øoa7>uÍè¤éÈ¯‘)¯ß÷	Ş=59ØeŒ}Tø7áFÃ®lÍF5_ÏàAì“˜«İb,> 8äÒJ›W–DkbŞ@°u7Ş?È W‹:qŸ;şpÕ%_\5îEäºaÛßÔ}äìë¡&{2V÷x“v: ‹ bÁÓ$"¬v¸¹0ÜÖ‰JûÜ7–s7}‘ş»c’Ÿ·Ğ†yrQós`@~¯g_Al§ÏS.İq eî“e'nAâo¤i½LÎI„i*!9èb{†,á¸»ïŠ"m\4w¸.+¬w™Î.øFçú­e¯t
MĞ»‰nXz»CN¬ÜWå»÷7èI&½¡£ÑümJïÁà¤ÌèıµıŒFF~&ÍE6×ã"şÈ/¹ 1ëñı€Şğ2£Îœ¶ãÄß/«½fñYéÆİş`¯‹û½®ï>á«
š!HAşg8W„ÓÂv]uÒ.}9eYõ ¹ŸœYjqõÖˆ"ü¡'ùi™Kv‡ÄUÚ<ç‚âŠ£'‹-pw•uLmÀ^ÿ8YTÎg¾7LŸ(ÅÂNÓ_/}-Æ™×¶‹pë5—æ=ì?Fô±vt´ºe1~6]İë¬ø
½—xûñmãQ7çÚxèğş5?ş‘kôâŸêïÃµ{"bÆ¿ÜÄÅF …Ü':Ê€ĞJşAêÈd3ëÒBğQÉ«‰‘Hå¶œv›Æa={`j†Å&[±mÖ+}Í–º5^¦[‡Ÿİ*fm4»#B;Î^·‹¬ÈO\?Ö™¿™¯ÿß¶_®ÿÈfÇ-ûØ«Ğ0±ãc2tß;P*`ã­pQŞ­¦¿½38'ä	çû¬ó¶îé-t»ó·6Ùí:†2¹üm2¾I?èï¨ÌÂµøxÖ6óöÇ.s¤“&0¥Ó×ùQ`¸·æ‹¯]÷ eÇ5PĞ/^Ñ`°ií6Õš\ÇİËïçÆdŸWzø£À×Çw$áv°˜¶õé¹ş<ay
yH'Ü´dpDIÑH|œT+G&eYk›±(	º²¥Õf¯#%â¶¡»ƒ~öD TÆÃÔø–Æ\*±¨éÀP¾Uô9ú|«N0G»’ÄdºKFÖğîtØõÂ‘¨5	[°èS#o!İØ	Wğy£t€G¨XšèåÕ—¼Œ*xÃ´“U„x[`Ğ}&áE±Î§ßÊvg°>HANoÛ#2îÎA3ÑMìAü^S†Öø3dÖÁÑÖ¡ú±k=R0™ªd¢$®T½şçHÎ×HZbñà‡÷–Ò¶åÌé™ˆEh¬ûK8?fšU>¾ŒYî­Ÿ'ply9*?ƒ€ìÃT\SÜŸKÓªè„èNÊƒ4|R¬:'úÚgsP‹+p>ôƒ©Shé}UùZ)õoı
¨u®Ü×Oâ”ü\‘µ­á CyG{{àp¿R*4~Kã›ü4Á¬¥à«nØ–,^ÑÔBŠ±¹ÃßŒC«€…¡
¤Ï×ææEE€š1a&@—TY»¿UZz×Q2PRÚ[K°£CîI_XÀ$<baï"ÆL+Q%ñçìîHè~È¼ NzAjÕĞƒÅÁh@ÏˆiˆQ_¶•stC´BeÎf^øb#¢ºÈƒV¥’s!R2Ø–ùø‡ÎĞ]İi„Šò†óTË«ìñÏÅõÉ9ï’~—uD«‘ïEÏé-ˆéA”Ñf‘‘Ar,æ¦¤‹¦}x7ßí¡ö™RÊ®²ûX@û$Íî/ ÜÀÃ¼{e@¥ÒDÉ·TÌ#‰‡é·J¶²ã­×Ìß~%şWê~ÀƒXğkæR¤vk‰á~i%>
ï”-åsVÙBîCi9­èæœ)?ê'œ²ÏJ3ù¥4îI‚)Ø°}E'¼J4-Åğ]IÅ„	EÃ‹Z£HAEÁÕŠÇ¿ıDÓÚZ{dY,2“ï¾Ä"c=oİ¼†qB]$Y$ş×PSV·0×:Tã~âpÿDÖ‚´LšÌ –T¿+}pkºß¼
ÕkÅZ—ëĞ€á5u•º8g„4üÊ/É4s/KaøK9Å;ßÍŸ›©˜é«±#BİÊçì™Ò›dÕø©“ÁšmØiV‚%Œ95%
LzCX=~ÌZD(ÕO1k*@]²±Òcl/î–ëî6 O±CPĞDÆ›€¹ÕrŒFš\°¶.™+bôE£Âµú¢°Y[´»˜~´¥ë0’¦–D¡ibzã9
QçpN]C£2@«gwHSS›< a;/MºÅÙ-E¨¯n“‹Å£ªVg
º:éÆ]z;*?Ø´|4ôXşØ»Ô9½¤ÄÛY*á›¯ÁşšXÛw/ÓÉ©÷‡|(êŸ¸ÕYå,dm¬`£ñû™~ÜÏ˜Óˆ¯@ÒwÇÄj\ş,b™dDšJW™	Çñ°˜™Áê»0nP‘¸"e|Ìò$”`¹’¢nı.Xõ`ˆ¬7}y<AÄ[ßÇ´4„W³¦t¡Å«÷Å&H¬üU‚S@Ô‰`S‚Ò·c¿Z·¢€$Ö
aÍ‹E»U7)
†0*Un›Ô°4¿PÚ—†N([-
óC”‡såSJ<î!Z¼Şš?¯¿Ç7Ù€ß¶V*YZâŞ)µ’Ø~f	©Q®h)ÔÜ¢Ã9$²¯¨Úy‚~aX«êìReaíı
İng:ä¿Vƒ_ƒğƒaœ¥ºÍQ±‚çõğÑon§¬«”†Æ“1‘¦\cÜµvUˆv'$)-ÄtQäwÜBèJ¤¶1u0	vÔhôC³`°ˆ+ü8Mêu)1Ef«¼à¬u(‚6¿Zt åp?[’ÅÓ_ò¾ğ…(İ…/ûıbT‘wKoÑïÆL&™z*{¤øEšÚı=E×Â÷(]<b¦»À,ú½>Q#ß„‚İ©¶·ír/º÷éDZéÅˆ=ôpµEN+»= K5”!"°lFs¡œÊaš•fR÷÷Á»Sà3’ô©å‰Í†¾±&Œ©Apx	¸Kouã{öÜë±‹Ptb]/3¦·$…ƒÓ4q53Ö³¼¾Ù²ÄH‡­O^á!‘™å…õhë:xÅ¶6<ø\æ°@,¯€³&Óä†ï²b8œ¯Ã/ZéX}&F«+×³'Yx1ÄQ
„‹ËXmFoPÍ}¶{2D.AŞÑMZÔw‚÷™İê¤ö4S¤¨eÇWFW.Ê|G ÉÒ,÷•(æìÍ!È¥kö©ÉK:LÄAi‚Ç’Â K.Ÿ9@9TFä§O=×Œø
ùò&Š$^:ŒĞsdoìráw¾µ¥e±ÔV‹©ô™ç1æ¹~ÖQÁáßç¢¿aG—hä	ô8IH ò:Ø¹z§™¥²î%PÈºfü.%§¾Sw.²¦^1RLRóÌ€>±Ç#¸¨ 
&MÄf(šöˆûy($cELÄ¦ĞæTÈsæHb]ÎÑÈ§;øu,8W…revEbcô™Â
gûšY¼™¨gØJğäƒ~r`LPs8+ˆµ¸ÎNÍ­‘«‚ ÂúZ-núìÌ¶Ló+`[; ÓãÍhò)ÜQ2j[Æ[Îô7&x~”VÓÂÔûßÜ‘èÛÏ“¶(fÍ}Ÿ´8¸¥àÒ)tu¼X2Îd›ÔòRzÒôF\GZ¤zCR§F¤ÔIZ}½Æ¸cšC‰ÌûéeD+ØL0 ¦*‘kıJªR0ñ¦!‘1nªôd0ìlo<ÓAtrÔæ>d,úıWÍhÍnQG¾)‡4„Iêiº…ƒÄ10İ˜¥Ûl‘¬ÚYÚ–Ã}å…_Â,j(İN'ƒùÖ}ˆL¡a¢¬š‰)qÖ¦=¬/T*‘)±¨ÿ‹ÑÏİœ³ì÷XL¥d×6ĞÕ$ŸIQò27§Cãâ·Ë$ªhl"­ihoÄ¿Rwöj»k(¡ƒ
¬t•ùŠ? ³¡x)<!¹ÏûË	ø‘©Nò ª™Å?`¤ı‰3Ó%9xp#Ø²§€•ZËµÇ9Làˆ24C®³³“âN’oÚËtKjLWÜ`ã´<mã×ç%åêËA £[”øR0­Ø8.K}ÁFÈr:ıÍ5™+„„¸KG®Hş«F@¡S®ÅãË’´àpŸ`U¦ÁI|`v|9²^ÀÌœ%k²°ûTö©#³¯Øl¿ pİg &~/¶Z&ƒ®;„Ïâ1@Y8‚?'­\äÀä¿O,>5Í÷šİ¥—Î0‘£³PQ¥K‹ğ¦Ô(11·9…Œå‡Tô/êéÖC’1³÷1™±İ„`›õÎtáÆ….mã-¶ÅSPaOš±y”ÿ%ÀK¦sW‹Â PáÔ%ğwM¼Ò¡’Öç… 	È•®[|vÌC½÷%jJ†‰"‚ óŞÂæØ¦i'ùx¶©ÛÊX¦”#Xécö!~é·ª]xïáÒzteªšHRğ­w ÆYeÊ¾é¨š‚X‘ Óñœ÷.ƒ	ë yĞ€#5ØØ»æ–pèC*Õ(èv«ôAN0l+Êé²Ady[IşpK«VÂ-} µâSÌ8ÿ©>³ÏçXæ¿ı…'Û€<œ›ŞˆúÌt6TùÎ€­}efp–ñ›—ÜŠI€FĞ‘6<çÌwìÇÂİ~ö”¢_6Ÿ“™—ÄUë )6wH?o0Y<éÈ.VÌ­¨âiÆõÇDË³º×¢GWm&n÷µ¹Î¼bkA¸eŒ¿ë~~” b×wö²ÉÃâß‡pSõ~áô­.ª|AÃÒªzVo“ nS€óŸm|Šûõ! ÍÛ»¾jÅÁî:3²`†ÎˆoèºäÂÆxËi8®$¿­71¥Hzãh×¸Úi²4{>Dt™,Ø‹•À¾FèÍHâ±·‰±D1ìÊúõú.R†¶MÅ'd:/q@Ş‘@rw_c¾VJ}¤wIÌ_ÀSˆHG	IÀ.`È¯Ìb›ıÓŞM®ƒ‚Äo»ÍÚ>öÇ›"„g_a¿„–*Âz{ï¤ÌIØC‘¥‡;>=6´\sİ…X#g¥œ;!l”ØLA6ÏİHxùŸT{YpİEr‡îº³~K˜ı€á bá±³.ÕéÚìö[´ùuÚ¬Rö(Ü_ Û?v¿n²WäÜ}îã“È*İ3¼ÊZQtáE”?ï91µ OóV1•*Ø´À„?B­¦Ú\ÍŸÁÅb.ì<}­^Íê/^¨ï¿?³^È†)¯d„`ÏÛ†c$nA/Ú8A¬@È|’Ò…ë	ÈîòÚ)rœ¬–ºÁò|³L„üÅbOƒÁW>wJK8™Oìä¼~db@ĞüÇÉzDë­“ä¥í¶5ıs£¤gaáqUU)~g˜‰>T20?L×5"<&aÑ÷Ş0}]xqz˜¥”³:êİHuJi&z«®Ÿá?ÅhØùØ’48™ÂÃïµŒ]:êÙz½â$±LLå/ñ$+¦u™ÕacwÙ“E¹bıÕ›ïê±ü‚Âtx,ïØ{©Š2\O8=ÏîmY¾_•ƒrîY‘†9ìöq-â78‰¢^ÏÛú°#¾ùrL¥ênê™‡ñ^I4ê´K½ê\Ä¦}¾+±öÄ¾{¯>ÚµP{Ò	ˆ3øëHÄ«Á—õGÉí@”+¸2îŠ³‡ñÍi$´ŠıdCõæ²=ëbG5&4ü¶°lîŠô íQ†;O¥èóì¸Ğ,cŠ`;#X`Gh5ŠËàÁ Ñ®lÆß·¨ÀâUíí£