ma byla odstraněna.Tato reklama v zařízení používala příliš mnoho zdrojů, proto ji Chrome odstranil.Přesto znovu načíst a zobrazitAkceSeznam položek v historii$1 - $2Jste si jisti, že chcete tyto stránky odstranit ze své historie?SmazatPřidáno do záložek$1 $2 $3 $4 $5Nalezené $2 pro dotaz „$3“: $1Na stránce <a target="_blank" href="$1">myactivity.google.com</a> mohou být k dispozici další druhy historie prohlížení zaznamenané ve vašem účtu Google.Více z tohoto webuZde se zobrazuje vaše historie prohlíženíNebyly nalezeny žádné výsledkyVymazat údaje o prohlížení…Sbalit seznamRozbalit seznamProzatím skrýtOtevřít všeOdstranit záložkuOdstranit z historie$1 – smazánoOdstranit vybrané položkyHledat v historiivýsledek vyhledávánívýsledky vyhledáváníZobrazit celou historiiNeznámé zařízeníWeb $1 říkáVložená stránka na webu $1 říkáTato stránka říkáStránka vložená na této stránce říkáBránit této stránce ve vytváření dalších dialogových okenOpustit web?Zavřít aplikaci?OdejítJe možné, že provedené změny nebudou uloženy.Načíst web znovu?Načíst aplikaci znovu?Přihlaste seDoména $1 vyžaduje zadání uživatelského jména a hesla.Proxy $1 vyžaduje uživatelské jméno a heslo.Připojení k tomuto webu není soukroméUživatelské jménoHesloPředchozí skladbaPřetočit dozaduPřehrátPozastavitPřetočit dopředuDalší skladbaSpustit režim obrazu v obrazeUkončit režim obrazu v obrazeZtlumitZapnout zvukOvládání médiíStáhnoutPokud se vám tato stránka zobrazuje často, zkuste využít tyto $1.návrhyK otevření této stránky není k dispozici dostatek pamětiZkuste uvolnit paměť tím, že zavřete ostatní karty nebo programy.Zkuste uvolnit paměť ukončením jiných programů.Nová anonymní kartaJste v anonymním režimuStránky, které otevřete na anonymních kartách, po zavření všech anonymních karet nezanechají žádné stopy v historii prohlížeče, v úložišti souborů cookie ani v historii vyhledávání. Zachovány však zůstanou všechny stažené soubory a vytvořené záložky.To neznamená, že jste neviditelní. Anonymní režim neskryje vaši aktivitu před vaším zaměstnavatelem, poskytovatelem internetových služeb ani webovými stránkami, které navštívíte.Nyní můžete procházet internet v soukromí a ostatní uživatelé tohoto zařízení vaši aktivitu neuvidí. Stažené soubory a záložky budou uloženy.Nyní můžete procházet internet v soukromí a ostatní uživatelé tohoto zařízení vaši aktivitu neuvidí. Budou se ale ukládat stažené soubory, záložky a položky na seznamu četby.Chromium <em>nebude ukládat</em> následující informace:
        <ul>
          <li>vaši historii prohlížení,
          <li>soubory cookie a data webů,
          <li>údaje zadané do formulářů.
        </ul>Vaše aktivita <em>může být nadále viditelná</em> pro následující subjekty:
        <ul>
          <li>navštívené weby,
          <li>váš zaměstnavatel nebo škola,
          <li>váš poskytovatel internetových služeb.
        </ul>Toto nastavení se ovládá v nastavení souborů cookie.Blokovat soubory cookie třetích stranKdyž je tato možnost zapnutá, weby vás na internetu nemohou sledovat pomocí souborů cookie. Některé weby mohou přestat fungovat.Anonymní režim v prohlížeči ChromiumCo anonymní režim děláKdyž zavřete všechny anonymní karty prohlížeče Chromium, vaše aktivita na těchto kartách bude ze zařízení vymazána:
          <ul>
            <li>aktivita prohlížení,</li>
            <li>historie vyhledávání,</li>
            <li>údaje zadané do formulářů.</li>
          </ul>Co anonymní režim neděláAnonymní režim neznamená, že jste neviditelní:
        <ul>
          <li>weby a jimi používané služby poznají, když je navštívíte,</li>
          <li>zaměstnavatel nebo škola mohou sledovat, co si prohlížíte,</li>
          <li>poskytovatelé iion data as a binary-encoded
 *            string of bytes, for 'GCM' mode, (default: none).
 *          tagLength desired length of authentication tag, in bits, for
 *            'GCM' mode (0-128, default: 128).
 *          tag the authentication tag to check if decrypting, as a
 *             binary-encoded string of bytes.
 *          output the output the buffer to write to, null to create one.
 */
BlockCipher.prototype.start = function(options) {
  options = options || {};
  var opts = {};
  for(var key in options) {
    opts[key] = options[key];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge.util.createBuffer();
  this.output = options.output || forge.util.createBuffer();
  this.mode.start(opts);
};

/**
 * Updates the next block according to the cipher mode.
 *
 * @param input the buffer to read from.
 */
BlockCipher.prototype.update = function(input) {
  if(input) {
    // input given, so empty it into the input buffer
    this._input.putBuffer(input);
  }

  // do cipher operation until it needs more input and not finished
  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&
    !this._finish) {}

  // free consumed memory from input buffer
  this._input.compact();
};

/**
 * Finishes encrypting or decrypting.
 *
 * @param pad a padding function to use in CBC mode, null for default,
 *          signature(blockSize, buffer, decrypt).
 *
 * @return true if successful, false on error.
 */
BlockCipher.prototype.finish = function(pad) {
  // backwards-compatibility w/deprecated padding API
  // Note: will overwrite padding functions even after another start() call
  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {
    this.mode.pad = function(input) {
      return pad(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad(this.blockSize, output, true);
    };
  }

  // build options for padding and afterFinish functions
  var options = {};
  options.decrypt = this._decrypt;

  // get # of bytes that won't fill a block
  options.overflow = this._input.length() % this.blockSize;

  if(!this._decrypt && this.mode.pad) {
    if(!this.mode.pad(this._input, options)) {
      return false;
    }
  }

  // do final update
  this._finish = true;
  this.update();

  if(this._decrypt && this.mode.unpad) {
    if(!this.mode.unpad(this.output, options)) {
      return false;
    }
  }

  if(this.mode.afterFinish) {
    if(!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }

  return true;
};
