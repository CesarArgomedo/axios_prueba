"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FSWatcher = exports.StatWatcher = exports.Volume = exports.toUnixTimestamp = exports.bufferToEncoding = exports.dataToBuffer = exports.dataToStr = exports.pathToSteps = exports.filenameToSteps = exports.pathToFilename = exports.flagsToNumber = exports.FLAGS = void 0;
var pathModule = require("path");
var node_1 = require("./node");
var Stats_1 = require("./Stats");
var Dirent_1 = require("./Dirent");
var buffer_1 = require("./internal/buffer");
var setImmediate_1 = require("./setImmediate");
var process_1 = require("./process");
var setTimeoutUnref_1 = require("./setTimeoutUnref");
var stream_1 = require("stream");
var constants_1 = require("./constants");
var events_1 = require("events");
var encoding_1 = require("./encoding");
var errors = require("./internal/errors");
var util = require("util");
var promises_1 = require("./promises");
var resolveCrossPlatform = pathModule.resolve;
var O_RDONLY = constants_1.constants.O_RDONLY, O_WRONLY = constants_1.constants.O_WRONLY, O_RDWR = constants_1.constants.O_RDWR, O_CREAT = constants_1.constants.O_CREAT, O_EXCL = constants_1.constants.O_EXCL, O_TRUNC = constants_1.constants.O_TRUNC, O_APPEND = constants_1.constants.O_APPEND, O_SYNC = constants_1.constants.O_SYNC, O_DIRECTORY = constants_1.constants.O_DIRECTORY, F_OK = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
var _a = pathModule.posix ? pathModule.posix : pathModule, sep = _a.sep, relative = _a.relative, join = _a.join, dirname = _a.dirname;
var isWin = process_1.default.platform === 'win32';
var kMinPoolSpace = 128;
// const kMaxLength = require('buffer').kMaxLength;
// ---------------------------------------- Error messages
// TODO: Use `internal/errors.js` in the future.
var ERRSTR = {
    PATH_STR: 'path must be a string or Buffer',
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: 'fd must be a file descriptor',
    MODE_INT: 'mode must be an int',
    CB: 'callback must be a function',
    UID: 'uid must be an unsigned int',
    GID: 'gid must be an unsigned int',
    LEN: 'len must be an integer',
    ATIME: 'atime must be an integer',
    MTIME: 'mtime must be an integer',
    PREFIX: 'filename prefix is required',
    BUFFER: 'buffer must be an instance of Buffer or StaticBuffer',
    OFFSET: 'offset must be an integer',
    LENGTH: 'length must be an integer',
    POSITION: 'position must be an integer',
};
var ERRSTR_OPTS = function (tipeof) { return "Expected options to be either an object or a string, but got ".concat(tipeof, " instead"); };
// const ERRSTR_FLAG = flag => `Unknown file open flag: ${flag}`;
var ENOENT = 'ENOENT';
var EBADF = 'EBADF';
var EINVAL = 'EINVAL';
var EPERM = 'EPERM';
var EPROTO = 'EPROTO';
var EEXIST = 'EEXIST';
var ENOTDIR = 'ENOTDIR';
var EMFILE = 'EMFILE';
var EACCES = 'EACCES';
var EISDIR = 'EISDIR';
var ENOTEMPTY = 'ENOTEMPTY';
var ENOSYS = 'ENOSYS';
var ERR_FS_EISDIR = 'ERR_FS_EISDIR';
function formatError(errorCode, func, path, path2) {
    if (func === void 0) { func = ''; }
    if (path === void 0) { path = ''; }
    if (path2 === void 0) { path2 = ''; }
    var pathFormatted = '';
    if (path)
        pathFormatted = " '".concat(path, "'");
    if (path2)
        pathFormatted += " -> '".concat(path2, "'");
    switch (errorCode) {
        case ENOENT:
            return "ENOENT: no such file or directory, ".concat(func).concat(pathFormatted);
        case EBADF:
            return "EBADF: bad file descriptor, ".concat(func).concat(pathFormatted);
        case EINVAL:
            return "EINVAL: invalid argument, ".concat(func).concat(pathFormatted);
        case EPERM:
            return "EPERM: operation not permitted, ".concat(func).concat(pathFormatted);
        case EPROTO:
            return "EPROTO: protocol error, ".concat(func).concat(pathFormatted);
        case EEXIST:
            return "EEXIST: file already exists, ".concat(func).concat(pathFormatted);
        case ENOTDIR:
            return "ENOTDIR: not a directory, ".concat(func).concat(pathFormatted);
        case EISDIR:
            return "EISDIR: illegal operation on a directory, ".concat(func).concat(pathFormatted);
        case EACCES:
            return "EACCES: permission denied, ".concat(func).concat(pathFormatted);
        case ENOTEMPTY:
            return "ENOTEMPTY: directory not empty, ".concat(func).concat(pathFormatted);
        case EMFILE:
            return "EMFILE: too many open files, ".concat(func).concat(pathFormatted);
        case ENOSYS:
            return "ENOSYS: function not implemented, ".concat(func).concat(pathFormatted);
        case ERR_FS_EISDIR:
            return "[ERR_FS_EISDIR]: Path is a directory: ".concat(func, " returned EISDIR (is a directory) ").concat(path);
        default:
            return "".concat(errorCode, ": error occurred, ").concat(func).concat(pathFormatted);
    }
}
function createError(errorCode, func, path, path2, Constructor) {
    if (func === void 0) { func = ''; }
    if (path === void 0) { path = ''; }
    if (path2 === void 0) { path2 = ''; }
    if (Constructor === void 0) { Constructor = Error; }
    var error = new Constructor(formatError(errorCode, func, path, path2));
    error.code = errorCode;
    if (path) {
        error.path = path;
    }
    return error;
}
// ---------------------------------------- Flags
// List of file `flags` as defined by Node.
var FLAGS;
(function (FLAGS) {
    // Open file for reading. An exception occurs if the file does not exist.
    FLAGS[FLAGS["r"] = O_RDONLY] = "r";
    // Open file for reading and writing. An exception occurs if the file does not exist.
    FLAGS[FLAGS["r+"] = O_RDWR] = "r+";
    // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.
    FLAGS[FLAGS["rs"] = O_RDONLY | O_SYNC] = "rs";
    FLAGS[FLAGS["sr"] = FLAGS.rs] = "sr";
    // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.
    FLAGS[FLAGS["rs+"] = O_RDWR | O_SYNC] = "rs+";
    FLAGS[FLAGS["sr+"] = FLAGS['rs+']] = "sr+";
    // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
    FLAGS[FLAGS["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
    // Like 'w' but fails if path exists.
    FLAGS[FLAGS["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
    FLAGS[FLAGS["xw"] = FLAGS.wx] = "xw";
    // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
    FLAGS[FLAGS["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
    // Like 'w+' but fails if path exists.
    FLAGS[FLAGS["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
    FLAGS[FLAGS["xw+"] = FLAGS['wx+']] = "xw+";
    // Open file for appending. The file is created if it does not exist.
    FLAGS[FLAGS["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
    // Like 'a' but fails if path exists.
    FLAGS[FLAGS["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
    FLAGS[FLAGS["xa"] = FLAGS.ax] = "xa";
    // Open file for reading and appending. The file is created if it does not exist.
    FLAGS[FLAGS["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
    // Like 'a+' but fails if path exists.
    FLAGS[FLAGS["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
    FLAGS[FLAGS["xa+"] = FLAGS['ax+']] = "xa+";
})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
function flagsToNumber(flags) {
    if (typeof flags === 'number')
        return flags;
    if (typeof flags === 'string') {
        var flagsNum = FLAGS[flags];
        if (typeof flagsNum !== 'undefined')
            return flagsNum;
    }
    // throw new TypeError(formatError(ERRSTR_FLAG(flags)));
    throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 'flags', flags);
}
exports.flagsToNumber = flagsToNumber;
// ---------------------------------------- Options
function getOptions(defaults, options) {
    var opts;
    if (!options)
        return defaults;
    else {
        var tipeof = typeof options;
        switch (tipeof) {
            case 'string':
                opts = Object.assign({}, defaults, { encoding: options });
                break;
            case 'object':
                opts = Object.assign({}, defaults, options);
                break;
            default:
                throw TypeError(ERRSTR_OPTS(tipeof));
        }
    }
    if (opts.encoding !== 'buffer')
        (0, encoding_1.assertEncoding)(opts.encoding);
    return opts;
}
function optsGenerator(defaults) {
    return function (options) { return getOptions(defaults, options); };
}
function validateCallback(callback) {
    if (typeof callback !== 'function')
        throw TypeError(ERRSTR.CB);
    return callback;
}
function optsAndCbGenerator(getOpts) {
    return function (options, callback) {
        return typeof options === 'function' ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
}
var optsDefaults = {
    encoding: 'utf8',
};
var getDefaultOpts = optsGenerator(optsDefaults);
var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
var readFileOptsDefaults = {
    flag: 'r',
};
var getReadFileOptions = optsGenerator(readFileOptsDefaults);
var writeFileDefaults = {
    encoding: 'utf8',
    mode: 438 /* MODE.DEFAULT */,
    flag: FLAGS[FLAGS.w],
};
var getWriteFileOptions = optsGenerator(writeFileDefaults);
var appendFileDefaults = {
    encoding: 'utf8',
    mode: 438 /* MODE.DEFAULT */,
    flag: FLAGS[FLAGS.a],
};
var getAppendFileOpts = optsGenerator(appendFileDefaults);
var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
var realpathDefaults = optsDefaults;
var getRealpathOptions = optsGenerator(realpathDefaults);
var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
var mkdirDefaults = {
    mode: 511 /* MODE.DIR */,
    recursive: false,
};
var getMkdirOptions = function (options) {
    if (typeof options === 'number')
        return Object.assign({}, mkdirDefaults, { mode: options });
    return Object.assign({}, mkdirDefaults, options);
};
var rmdirDefaults = {
    recursive: false,
};
var getRmdirOptions = function (options) {
    return Object.assign({}, rmdirDefaults, options);
};
var getRmOpts = optsGenerator(optsDefaults);
var getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
var readdirDefaults = {
    encoding: 'utf8',
    withFileTypes: false,
};
var getReaddirOptions = optsGenerator(readdirDefaults);
var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
var statDefaults = {
    bigint: false,
};
var getStatOptions = function (options) {
    if (options === void 0) { options = {}; }
    return Object.assign({}, statDefaults, options);
};
var getStatOptsAndCb = function (options, callback) {
    return typeof options === 'function' ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
};
// ---------------------------------------- Utility functions
function getPathFromURLPosix(url) {
    if (url.hostname !== '') {
        throw new errors.TypeError('ERR_INVALID_FILE_URL_HOST', process_1.default.platform);
    }
    var pathname = url.pathname;
    for (var n = 0; n < pathname.length; n++) {
        if (pathname[n] === '%') {
            var third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === '2' && third === 102) {
                throw new errors.TypeError('ERR_INVALID_FILE_URL_PATH', 'must not include encoded / characters');
            }
        }
    }
    return decodeURIComponent(pathname);
}
function pathToFilename(path) {
    if (typeof path !== 'string' && !buffer_1.Buffer.isBuffer(path)) {
        try {
            if (!(path instanceof require('url').URL))
                throw new TypeError(ERRSTR.PATH_STR);
        }
        catch (err) {
            throw new TypeError(ERRSTR.PATH_STR);
        }
        path = getPathFromURLPosix(path);
    }
    var pathString = String(path);
    nullCheck(pathString);
    // return slash(pathString);
    return pathString;
}
exports.pathToFilename = pathToFilename;
var resolve = function (filename, base) {
    if (base === void 0) { base = process_1.default.cwd(); }
    return resolveCrossPlatform(base, filename);
};
if (isWin) {
    var _resolve_1 = resolve;
    var unixify_1 = require('fs-monkey/lib/correctPath').unixify;
    resolve = function (filename, base) { return unixify_1(_resolve_1(filename, base)); };
}
function filenameToSteps(filename, base) {
    var fullPath = resolve(filename, base);
    var fullPathSansSlash = fullPath.substring(1);
    if (!fullPathSansSlash)
        return [];
    return fullPathSansSlash.split(sep);
}
exports.filenameToSteps = filenameToSteps;
function pathToSteps(path) {
    return filenameToSteps(pathToFilename(path));
}
exports.pathToSteps = pathToSteps;
function dataToStr(data, encoding) {
    if (encoding === void 0) { encoding = encoding_1.ENCODING_UTF8; }
    if (buffer_1.Buffer.isBuffer(data))
        return data.toString(encoding);
    else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data).toString(encoding);
    else
        return String(data);
}
exports.dataToStr = dataToStr;
function dataToBuffer(data, encoding) {
    if (encoding === void 0) { encoding = encoding_1.ENCODING_UTF8; }
    if (buffer_1.Buffer.isBuffer(data))
        return data;
    else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data);
    else
        return (0, buffer_1.bufferFrom)(String(data), encoding);
}
exports.dataToBuffer = dataToBuffer;
function bufferToEncoding(buffer, encoding) {
    if (!encoding || encoding === 'buffer')
        return buffer;
    else
        return buffer.toString(encoding);
}
exports.bufferToEncoding = bufferToEncoding;
function nullCheck(path, callback) {
    if (('' + path).indexOf('\u0000') !== -1) {
        var er = new Error('Path must be a string without null bytes');
        er.code = ENOENT;
        if (typeof callback !== 'function')
            throw er;
        process_1.default.nextTick(callback, er);
        return false;
    }
    return true;
}
function _modeToNumber(mode, def) {
    if (typeof mode === 'number')
        return mode;
    if (typeof mode === 'string')
        return parseInt(mode, 8);
    if (def)
        return modeToNumber(def);
    return undefined;
}
function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);
    if (typeof result !== 'number' || isNaN(result))
        throw new TypeError(ERRSTR.MODE_INT);
    return result;
}
function isFd(path) {
    return path >>> 0 === path;
}
function validateFd(fd) {
    if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
}
// converts Date or number to a fractional UNIX timestamp
function toUnixTimestamp(time) {
    // tslint:disable-next-line triple-equals
    if (typeof time === 'string' && +time == time) {
        return +time;
    }
    if (time instanceof Date) {
        return time.getTime() / 1000;
    }
    if (isFinite(time)) {
        if (time < 0) {
            return Date.now() / 1000;
        }
  @HB'C$H                                                        
 &   ÿÿÿÿÿÿÿÿ                                             @H–Eì;ìCh<¤E+H                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                             @HYEòDhE7G                                                        ÿÿÿÿÿÿÿÿÿÿÿÿ                                      <       @HA'Cò:øE·D1H                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                      $       @HB*CöE5G                                                       ÿÿÿÿÿÿÿÿÿÿÿÿ                                       `       @HBûEÜEüC(H                                                     ÿÿÿÿÿÿÿÿÿÿÿÿ                                    "  $       @Hž<BûE                                                        
  ÿÿÿÿÿÿÿÿÿÿÿÿ                                    #  Ì       @H C{;èDhD'B±A|>µD9C'B5H                                         ÿÿÿÿÿÿÿÿÿÿÿÿ                                    '         @H?dA/B6H                                                       )   ÿÿÿÿÿÿÿÿ                                    (  :       @H?;òC8D±E                                                        ÿÿÿÿÿÿÿÿÿÿÿÿ                                    )  ˆ      @H??wElDj>²D/H                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                      ,      @H??wElDj;äE$H                                                      *   ÿÿÿÿ                                    ü  ‚é       M s i D i g i t a l S i g n a t u r e E x                     .  ÿÿÿÿÿÿÿÿÿÿÿÿ                                    <           D i g i t a l S i g n a t u r e                               $  ÿÿÿÿÿÿÿÿÿÿÿÿ                                      ¿(                                                                          ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                                                                                    ÿÿÿÿÿÿÿÿÿÿÿÿ                                                The table reference of the source of the code.TargetExcecution parameter, depends on the type of custom actionExtendedTypeA numeric custom action type that extends code type or option flags of the Type column.Name of the dialog.HCenteringHorizontal position of the dialog on a 0-100 scale. 0 means left end, 100 means right end of the screen, 50 center.VCenteringVertical position of the dialog on a 0-100 scale. 0 means top end, 100 means bottom end of the screen, 50 center.Width of the bounding rectangle of the dialog.Height of the bounding rectangle of the dialog.A 32-bit word that specifies the attribute flags to be applied to this dialog.TitleA text string specifying the title to be displayed in the title bar of the dialog's window.Control_FirstDefines the control that has the focus when the dialog is created.Control_DefaultDefines the default control. Hitting return is equivalent to pushing this button.Control_CancelDefines the cancel control. Hitting escape or clicking on the close icon on the dialog is equivalent to pushing this button.Unique identifier for directory entry, primary key. If a property by this name is defined, it contains the full path to the directory.Directory_ParentReference to the entry in this table specifying the default parent directory. A record parented to itself or with a Null parent represents a root of the install tree.DefaultDirThe default sub-path under parent's path.ErrorInteger error number, obtained from header file IError(...) macros.MessageTemplateError formatting template, obtained from user ed. or localizers.EventMappingA foreign key to the Dialog table, name of the Dialog.An identifier that specifies the type of the event that the control subscribes to.AttributeThe name of the control attribute, that is set when this event is received.FeaturePrimary key used to identify a particular feature record.Feature_ParentOptional key of a parent record in the same table. If the parent is not selected, then the record will not be installed. Null indicates a root item.Short text identifying a visible feature item.Longer descriptive text describing a visible feature item.DisplayNumeric sort order, used to force a specific display ordering.LevelThe install level at which record will be initially selected. An install level of 0 will disable an item and prevent its display.UpperCaseThe name of the Directory that can be configured by the UI. A non-null value will enable the browse button.0;1;2;4;5;6;8;9;10;16;17;18;20;21;22;24;25;26;32;33;34;36;37;38;48;49;50;52;53;54Feature attributesFeatureComponentsFeature_Foreign key into Feature table.Component_Foreign key into Component table.FilePrimary key, non-localized token, must match identifier in cabinet.  For uncompressed files, this field is ignored.Foreign key referencing Component that controls the file.FileNameFilenameFile name used for installation, may be localized.  This may contain a "short name|long name" pair.FileSizeSize of file in bytes (long integer).VersionVersion string for versioned files;  Blank for unversioned files.LanguageList of decimal language Ids, comma-separated if more than one.Integer containing bit flags representing file attributes (with the decimal value of each bit position in parentheses)Sequence with respect to the media images; order must track cabinet order.InstallExecuteSequenceInstallUISequenceListBoxA named property to be tied to this item. All the items tied to the same property become part of the same listbox.OrderA positive integer used to determine the ordering of the items within one list..The integers do not have to be consecutive.The value string associated with this item. Selecting the line will set the associated property to this value.The visible text to be assigned to the item. Optional. If this entry or the entire column is missing, the text is the same as the value.MediaDiskIdPrimary key, integer to determine sort order for table.LastSequenceFile sequence number for the last file for this media.DiskPromptDisk name: the visible text actually printed on the disk.  This will be used to prompt the user NameTableTypeColumnValue_ValidationNPropertyId_SummaryInformationDescriptionSetCategoryKeyColumnMaxValueNullableKeyTableMinValueIdentifierName of tableName of columnY;NWhether the column is nullableYMinimum value allowedMaximum value allowedFor foreign key, Name of table to which data must linkColumn to which foreign key connectsText;Formatted;Template;Condition;Guid;Path;Version;Language;Identifier;Binary;UpperCase;LowerCase;Filename;Paths;AnyPath;WildCardFilename;RegPath;CustomSource;Property;Cabinet;Shortcut;FormattedSDDLText;Integer;DoubleInteger;TimeDate;DefaultDirString categoryTextSet of values that are permittedDescription of columnAdminExecuteSequenceActionName of action to invoke, either in the engine or the handler DLL.ConditionOptional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.SequenceNumber that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.AdminUISequenceAdvtExecuteSequenceBinaryUnique key identifying the binary data.DataThe unformatted binary data.CheckBoxPropertyA named property to be tied to the item.FormattedThe value string associated with the item.ComponentPrimary key used to identify a particular component record.ComponentIdGuidA string GUID unique to this component, version, and language.Directory_DirectoryRequired key of a Directory table record. This is actually a property name whose value contains the actual path, set either by the AppSearch action or with the default setting obtained from the Directory table.AttributesRemote execution option, one of irsEnumA conditional statement that will disable this component if the specified condition evaluates to the 'True' state. If a component is disabled, it will not be installed, regardless of the 'Action' state associated with the component.KeyPathFile;Registry;ODBCDataSourceEither the primary key into the File table, Registry table, or ODBCDataSource table. This extract path is stored when the component is installed, and is used to detect the presence of the component and to return the path to it.ControlDialog_DialogExternal key to the Dialog table, name of the dialog.Name of the control. This name must be unique within a dialog, but can repeat on different dialogs. The type of the control.XHorizontal coordinate of the upper left corner of the bounding rectangle of the control.Vertical coordinate of the upper left corner of the bounding rectangle of the control.WidthWidth of the bounding rectangle of the control.HeightHeight of the bounding rectangle of the control.A 32-bit word that specifies the attribute flags to be applied to this control.The name of a defined property to be linked to this control. A string used to set the initial text contained within a control (if appropriate).Control_NextThe name of an other control on the same dialog. This link defines the tab order of the controls. The links have to form one or more cycles!HelpThe help strings used with the button. The text is optional. ControlConditionA foreign key to the Dialog table, name of the dialog.Control_A foreign key to the Control table, name of the control.Default;Disable;Enable;Hide;ShowThe desired action to be taken on the specified control.A standard conditional statement that specifies under which conditions the action should be triggered.ControlEventA foreign key to the Control table, name of the controlEventAn identifier that specifies the type of the event that should take place when the user interacts with control specified by the first two entries.ArgumentA value to be used as a modifier when triggering a particular event.A standard conditional statement that specifies under which conditions an event should be triggered.OrderingAn integer used to order several events tied to the same control. Can be left blank.CustomActionPrimary key, name of action, normally appears in sequence table unless private use.The numeric custom action type, consisting of source location, code type, entry, option flags.SourceCustomSourcewhen this disk needs to be inserted.CabinetIf some or all of the files stored on the media are compressed in a cabinet, the name of that cabinet.VolumeLabelThe label attributed to the volume.The property defining the location of the cabinet file.MsiFileHashFile_Primary key, foreign key into File table referencing file with this hashOptionsVarious options and attributes for this hash.HashPart1HashPart2HashPart3HashPart4Name of property, uppercase if settable by launcher or loader.String value for property.  Never null or empty.RadioButtonA named property to be tied to this radio button. All the buttons tied to the same property become part of the same group.The value string associated with this button. Selecting the button will set the associated property to this value.The horizontal coordinate of the upper left corner of the bounding rectangle of the radio button.The vertical coordinate of the upper left corner of the bounding rectangle of the radio button.The width of the button.The height of the button.The visible title to be assigned to the radio button.The help strings used with the button. The text is optional.RegistryPrimary key, non-localized token.RootThe predefined root key for the registry value, one of rrkEnum.KeyRegPathThe key for the registry value.The registry value name.The registry value.Foreign key into the Component table referencing component that controls the installing of the registry value.TextStyleName of the style. The primary key of this table. This name is embedded in the texts to indicate a style change.FaceNameA string indicating the name of the font used. Required. The string must be at most 31 characters long.SizeThe size of the font used. This size is given in our units (1/12 of the system font height). Assuming that the system font is set to 12 point size, this is equivalent to the point size.ColorA long integer indicating the color of the string in the RGB format (Red, Green, Blue each 0-255, RGB = R + 256*G + 256^2*B).StyleBitsA combination of style bits.UITextA unique key that identifies the particular string.The localized version of the string.WixDependencyProviderThe non-localized primary key for the table.The foreign key into the Component table used to determine install state.ProviderKeyThe name of the registry key that holds the provider identity.The version of the package.DisplayNameThe display name of the package.A 32-bit word that specifies the attribute flags to be applied.CostInitializeFileCostCostFinalizeInstallValidateInstallInitializeInstallAdminPackageInstallFilesInstallFinalizeFatalErrorUserExitExitDialogExecuteActionPublishFeaturesPublishProductWixCAWixDepCAWixUIWixcaWixUI_Bmp_BannerWixUI_Bmp_DialogWixUI_Ico_ExclamWixUI_Ico_InfoWixUI_Bmp_NewWixUI_Bmp_UpLicenseAccepted1WIXUI_EXITDIALOGOPTIONALCHECKBOXcmpA1A63EC452943CBE27799338CF0A2ED2{8D42BAA6-8A2B-5977-9D2A-CB56EEFF532D}VersionDirfil07A5C4375E3EF1D28E117DAC32957877cmp5BA803AB93A2A9016954B6F7CACE2D28{9E5C9FB8-F946-5737-9168-EAA492092556}fil54C8BF6D6BC430BE9FDDC0762497EB66cmp672C96B0C00CC3641D58677C347BCD3F{63DAE216-883C-51B8-B893-9D30EDD9596B}fil413E8DDF499E9E589391FEB2089A7A89cmp48EE46EE987958E0BB5BC95BB5227D30{0AE7F1CC-33B4-5478-BD11-5BD8A629DDFA}filD72B4349B7D947A56499CC8320B1E106cmpA02EFFCFB76A78AB26CD968827D52173{5CF9529D-5CF8-5257-971E-70E9EB815BF2}dir3BBFF84B414055E4BEDAB7F8F86D2BB1fil7F988DB0FF80BF1CAA000D6B5811B797cmp5ACBB7678C8F7B7057264C28AA6547FF{92771D78-2C37-5ECC-AE50-5EC2573A389C}dirE736B675179980C7258FA65FFBA5E74FfilBCF2F729BFC7F574B151FD8AC2E210C8cmpE77D8B5123FBF94E3809C2600F1B6331{06034843-5B08-520E-9CFF-FF60ED20A385}dirC91DFE1B29C88D37A401A803433D7C02filAB0FF93F39619E53787D145AD7017EB4cmp227F0F8519E4576F60912BC81AB63C39{1C8AA183-89B5-5F60-B9D7-3D2E02ED3B40}filC9241C08D941E92C68D7085020B46AB3cmp3F01F58F342A1DD65967A33ED610369C{D88AA58D-BBDB-52B2-BCD4-1DCBDA62515D}fil52FDF36B3EE934D640AA747FD41D73D4cmp5BCE09C1A587D65C87A19BE25E48707A{2DF1AD18-1FEE-5C3A-917A-9EDAA91670C8}filE3CFBE02A48BD5F2E404E893AA933FEDcmp36D9DD9237D7235CFDFB8729BCE0178D{8B6D5C7F-F7A7-5B04-8C99-9D2CD0569E1A}fil03C84A0EC1C837EC172BEBBD9s);
        if (link && flagsNum & O_EXCL)
            throw createError(EEXIST, 'open', filename);
        // Try creating a new file, if it does not exist.
        if (!link && flagsNum & O_CREAT) {
            // const dirLink: Link = this.getLinkParent(steps);
            var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
            // if(!dirLink) throw createError(ENOENT, 'open', filename);
            if (!dirLink)
                throw createError(ENOENT, 'open', sep + steps.join(sep));
            if (flagsNum & O_CREAT && typeof modeNum === 'number') {
                link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
            }
        }
        if (link)
            return this.openLink(link, flagsNum, resolveSymlinks);
        throw createError(ENOENT, 'open', filename);
    };
    Volume.prototype.openBase = function (filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) { resolveSymlinks = true; }
        var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
        if (!file)
            throw createError(ENOENT, 'open', filename);
        return file.fd;
    };
    Volume.prototype.openSync = function (path, flags, mode) {
        if (mode === void 0) { mode = 438 /* MODE.DEFAULT */; }
        // Validate (1) mode; (2) path; (3) flags - in that order.
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path);
        var flagsNum = flagsToNumber(flags);
        return this.openBase(fileName, flagsNum, modeNum);
    };
    Volume.prototype.open = function (path, flags, a, b) {
        var mode = a;
        var callback = b;
        if (typeof a === 'function') {
            mode = 438 /* MODE.DEFAULT */;
            callback = a;
        }
        mode = mode || 438 /* MODE.DEFAULT */;
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path);
        var flagsNum = flagsToNumber(flags);
        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };
    Volume.prototype.closeFile = function (file) {
        if (!this.fds[file.fd])
            return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
    };
    Volume.prototype.closeSync = function (fd) {
        validateFd(fd);
        var file = this.getFileByFdOrThrow(fd, 'close');
        this.closeFile(file);
    };
    Volume.prototype.close = function (fd, callback) {
        validateFd(fd);
        this.wrapAsync(this.closeSync, [fd], callback);
    };
    Volume.prototype.openFileOrGetById = function (id, flagsNum, modeNum) {
        if (typeof id === 'number') {
            var file = this.fds[id];
            if (!file)
                throw createError(ENOENT);
            return file;
        }
        else {
            return this.openFile(pathToFilename(id), flagsNum, modeNum);
        }
    };
    Volume.prototype.readBase = function (fd, buffer, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd);
        return file.read(buffer, Number(offset), Number(length), position);
    };
    Volume.prototype.readSync = function (fd, buffer, offset, length, position) {
        validateFd(fd);
        return this.readBase(fd, buffer, offset, length, position);
    };
    Volume.prototype.read = function (fd, buffer, offset, length, position, callback) {
        var _this = this;
        validateCallback(callback);
        // This `if` branch is from Node.js
        if (length === 0) {
            return process_1.default.nextTick(function () {
                if (callback)
                    callback(null, 0, buffer);
            });
        }
        (0, setImmediate_1.default)(function () {
            try {
                var bytes = _this.readBase(fd, buffer, offset, length, position);
                callback(null, bytes, buffer);
            }
            catch (err) {
                callback(err);
            }
        });
    };
    Volume.prototype.readFileBase = function (id, flagsNum, encoding) {
        var result;
        var isUserFd = typeof id === 'number';
        var userOwnsFd = isUserFd && isFd(id);
        var fd;
        if (userOwnsFd)
            fd = id;
        else {
            var filename = pathToFilename(id);
            var steps = filenameToSteps(filename);
            var link = this.getResolvedLink(steps);
            if (link) {
                var node = link.getNode();
                if (node.isDirectory())
                    throw createError(EISDIR, 'open', link.getPath());
            }
            fd = this.openSync(id, flagsNum);
        }
        try {
            result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
        }
        finally {
            if (!userOwnsFd) {
                this.closeSync(fd);
            }
        }
        return result;
    };
    Volume.prototype.readFileSync = function (file, options) {
        var opts = getReadFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        return this.readFileBase(file, flagsNum, opts.encoding);
    };
    Volume.prototype.readFile = function (id, a, b) {
        var _a = optsAndCbGenerator(getReadFileOptions)(a, b), opts = _a[0], callback = _a[1];
        var flagsNum = flagsToNumber(opts.flag);
        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };
    Volume.prototype.writeBase = function (fd, buf, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd, 'write');
        return file.write(buf, offset, length, position);
    };
    Volume.prototype.writeSync = function (fd, a, b, c, d) {
        validateFd(fd);
        var encoding;
        var offset;
        var length;
        var position;
        var isBuffer = typeof a !== 'string';
        if (isBuffer) {
            offset = (b || 0) | 0;
            length = c;
            position = d;
        }
        else {
            position = b;
            encoding = c;
        }
        var buf = dataToBuffer(a, encoding);
        if (isBuffer) {
            if (typeof length === 'undefined') {
                length = buf.length;
            }
        }
        else {
            offset = 0;
            length = buf.length;
        }
        return this.writeBase(fd, buf, offset, length, position);
    };
    Volume.prototype.write = function (fd, a, b, c, d, e) {
        var _this = this;
        validateFd(fd);
        var offset;
        var length;
        var position;
        var encoding;
        var callback;
        var tipa = typeof a;
        var tipb = typeof b;
        var tipc = typeof c;
        var tipd = typeof d;
        if (tipa !== 'string') {
            if (tipb === 'function') {
                callback = b;
            }
            else if (tipc === 'function') {
                offset = b | 0;
                callback = c;
            }
            else if (tipd === 'function') {
                offset = b | 0;
                length = c;
                callback = d;
            }
            else {
                offset = b | 0;
                length = c;
                position = d;
                callback = e;
            }
        }
        else {
            if (tipb === 'function') {
                callback = b;
            }
            else if (tipc === 'function') {
                position = b;
                callback = c;
            }
            else if (tipd === 'function') {
                position = b;
                encoding = c;
                callback = d;
            }
        }
        var buf = dataToBuffer(a, encoding);
        if (tipa !== 'string') {
            if (typeof length === 'undefined')
                length = buf.length;
        }
        else {
            offset = 0;
            length = buf.length;
        }
        var cb = validateCallback(callback);
        (0, setImmediate_1.default)(function () {
            try {
                var bytes = _this.writeBase(fd, buf, offset, length, position);
                if (tipa !== 'string') {
                    cb(null, bytes, buf);
                }
                else {
                    cb(null, bytes, a);
                }
            }
            catch (err) {
                cb(err);
            }
        });
    };
    Volume.prototype.writeFileBase = function (id, buf, flagsNum, modeNum) {
        // console.log('writeFileBase', id, buf, flagsNum, modeNum);
        // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);
        // node.setBuffer(buf);
        var isUserFd = typeof id === 'number';
        var fd;
        if (isUserFd)
            fd = id;
        else {
            fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
            // fd = this.openSync(id as PathLike, flagsNum, modeNum);
        }
        var offset = 0;
        var length = buf.length;
        var position = flagsNum & O_APPEND ? undefined : 0;
        try {
            while (length > 0) {
                var written = this.writeSync(fd, buf, offset, length, position);
                offset += written;
                length -= written;
                if (position !== undefined)
                    position += written;
            }
        }
        finally {
            if (!isUserFd)
                this.closeSync(fd);
        }
    };
    Volume.prototype.writeFileSync = function (id, data, options) {
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.writeFileBase(id, buf, flagsNum, modeNum);
    };
    Volume.prototype.writeFile = function (id, data, a, b) {
        var options = a;
        var callback = b;
        if (typeof a === 'function') {
            options = writeFileDefaults;
            callback = a;
        }
        var cb = validateCallback(callback);
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    };
    Volume.prototype.linkBase = function (filename1, filename2) {
        var steps1 = filenameToSteps(filename1);
        var link1 = this.getLink(steps1);
        if (!link1)
            throw createError(ENOENT, 'link', filename1, filename2);
        var steps2 = filenameToSteps(filename2);
        // Check new link directory exists.
        var dir2 = this.getLinkParent(steps2);
        if (!dir2)
            throw createError(ENOENT, 'link', filename1, filename2);
        var name = steps2[steps2.length - 1];
        // Check if new file already exists.
        if (dir2.getChild(name))
            throw createError(EEXIST, 'link', filename1, filename2);
        var node = link1.getNode();
        node.nlink++;
        dir2.createChild(name, node);
    };
    Volume.prototype.copyFileBase = function (src, dest, flags) {
        var buf = this.readFileSync(src);
        if (flags & COPYFILE_EXCL) {
            if (this.existsSync(dest)) {
                throw createError(EEXIST, 'copyFile', src, dest);
            }
        }
        if (flags & COPYFILE_FICLONE_FORCE) {
            throw createError(ENOSYS, 'copyFile', src, dest);
        }
        this.writeFileBase(dest, buf, FLAGS.w, 438 /* MODE.DEFAULT */);
    };
    Volume.prototype.copyFileSync = function (src, dest, flags) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    };
    Volume.prototype.copyFile = function (src, dest, a, b) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        var flags;
        var callback;
        if (typeof a === 'function') {
            flags = 0;
            callback = a;
        }
        else {
            flags = a;
            callback = b;
        }
        validateCallback(callback);
        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };
    Volume.prototype.linkSync = function (existingPath, newPath) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.linkBase(existingPathFilename, newPathFilename);
    };
    Volume.prototype.link = function (existingPath, newPath, callback) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };
    Volume.prototype.unlinkBase = function (filename) {
        var steps = filenameToSteps(filename);
        var link = this.getLink(steps);
        if (!link)
            throw createError(ENOENT, 'unlink', filename);
        // TODO: Check if it is file, dir, other...
        if (link.length)
            throw Error('Dir not empty...');
        this.deleteLink(link);
        var node = link.getNode();
        node.nlink--;
        // When all hard links to i-node are deleted, remove the i-node, too.
        if (node.nlink <= 0) {
            this.deleteNode(node);
        }
    };
    Volume.prototype.unlinkSync = function (path) {
        var filename = pathToFilename(path);
        this.unlinkBase(filename);
    };
    Volume.prototype.unlink = function (path, callback) {
        var filename = pathToFilename(path);
        this.wrapAsync(this.unlinkBase, [filename], callback);
    };
    Volume.prototype.symlinkBase = function (targetFilename, pathFilename) {
        var pathSteps = filenameToSteps(pathFilename);
        // Check if directory exists, where we about to create a symlink.
        var dirLink = this.getLinkParent(pathSteps);
        if (!dirLink)
            throw createError(ENOENT, 'symlink', targetFilename, pathFilename);
        var name = pathSteps[pathSteps.length - 1];
        // Check if new file already exists.
        if (dirLink.getChild(name))
            throw createError(EEXIST, 'symlink', targetFilename, pathFilename);
        // Create symlink.
        var symlink = dirLink.createChild(name);
        symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
        return symlink;
    };
    // `type` argument works only on Windows.
    Volume.prototype.symlinkSync = function (target, path, type) {
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path);
        this.symlinkBase(targetFilename, pathFilename);
    };
    Volume.prototype.symlink = function (target, path, a, b) {
        var callback = validateCallback(typeof a === 'function' ? a : b);
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path);
        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };
    Volume.prototype.realpathBase = function (filename, encoding) {
        var steps = filenameToSteps(filename);
        var realLink = this.getResolvedLink(steps);
        if (!realLink)
            throw createError(ENOENT, 'realpath', filename);
        return (0, encoding_1.strToEncoding)(realLink.getPath() || '/', encoding);
    };
    Volume.prototype.realpathSync = function (path, options) {
        return this.realpathBase(pathToFilename(path), getRealpathOptions(options).encoding);
    };
    Volume.prototype.realpath = function (path, a, b) {
        var _a = getRealpathOptsAndCb(a, b), opts = _a[0], callback = _a[1];
        var pathFilename = pathToFilename(path);
        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };
    Volume.prototype.lstatBase = function (filename, bigint, throwIfNoEntry) {
        if (bigint === void 0) { bigint = false; }
        if (throwIfNoEntry === void 0) { throwIfNoEntry = false; }
        var link = this.getLink(filenameToSteps(filename));
        if (link) {
            return Stats_1.default.build(link.getNode(), bigint);
        }
        else if (!throwIfNoEntry) {
            return undefined;
        }
        else {
            throw createError(ENOENT, 'lstat', filename);
        }
    };
    Volume.prototype.lstatSync = function (path, options) {
        var _a = getStatOptions(options), _b = _a.throwIfNoEntry, throwIfNoEntry = _b === void 0 ? true : _b, _c = _a.bigint, bigint = _c === void 0 ? false : _c;
        return this.lstatBase(pathToFilename(path), bigint, throwIfNoEntry);
    };
    Volume.prototype.lstat = function (path, a, b) {
        var _a = getStatOptsAndCb(a, b), _b = _a[0], _c = _b.throwIfNoEntry, throwIfNoEntry = _c === void 0 ? true : _c, _d = _b.bigint, bigint = _d === void 0 ? false : _d, callback = _a[1];
        this.wrapAsync(this.lstatBase, [pathToFilename(path), bigint, throwIfNoEntry], callback);
    };
    Volume.prototype.statBase = function (filename, bigint, throwIfNoEntry) {
        if (bigint === void 0) { bigint = false; }
        if (throwIfNoEntry === void 0) { throwIfNoEntry = true; }
        var link = this.getResolvedLink(filenameToSteps(filename));
        if (link) {
            return Stats_1.default.build(link.getNode(), bigint);
        }
        else if (!throwIfNoEntry) {
            return undefined;
        }
        else {
            throw createError(ENOENT, 'stat', filename);
        }
    };
    Volume.prototype.statSync = function (path, options) {
        var _a = getStatOptions(options), _b = _a.bigint, bigint = _b === void 0 ? true : _b, _c = _a.throwIfNoEntry, throwIfNoEntry = _c === void 0 ? true : _c;
        return this.statBase(pathToFilename(path), bigint, throwIfNoEntry);
    };
    Volume.prototype.stat = function (path, a, b) {
        var _a = getStatOptsAndCb(a, b), _b = _a[0], _c = _b.bigint, bigint = _c === void 0 ? false : _c, _d = _b.throwIfNoEntry, throwIfNoEntry = _d === void 0 ? true : _d, callback = _a[1];
        this.wrapAsync(this.statBase, [pathToFilename(path), bigint, throwIfNoEntry], callback);
    };
    Volume.prototype.fstatBase = function (fd, bigint) {
        if (bigint === void 0) { bigint = false; }
        var file = this.getFileByFd(fd);
        if (!file)
            throw createError(EBADF, 'fstat');
        return Stats_1.default.build(file.node, bigint);
    };
    Volume.prototype.fstatSync = function (fd, options) {
        return this.fstatBase(fd, getStatOptions(options).bigint);
    };
    Volume.prototype.fstat = function (fd, a, b) {
        var _a = getStatOptsAndCb(a, b), opts = _a[0], callback = _a[1];
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };
    Volume.prototype.renameBase = function (oldPathFilename, newPathFilename) {
        var link = this.getLink(filenameToSteps(oldPathFilename));
        if (!link)
            throw createError(ENOENT, 'rename', oldPathFilename, newPathFilename);
        // TODO: Check if it is directory, if non-empty, we cannot move it, right?
        var newPathSteps = filenameToSteps(newPathFilename);
        // Check directory exists for the new location.
        var newPathDirLink = this.getLinkParent(newPathSteps);
        if (!newPathDirLink)
            throw createError(ENOENT, 'rename', oldPathFilename, newPathFilename);
        // TODO: Also treat cases with directories and symbolic links.
        // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
        // Remove hard link from old folder.
        var oldLinkParent = link.parent;
        if (oldLinkParent) {
            oldLinkParent.deleteChild(link);
        }
        // Rename should overwrite the new path, if that exists.
        var name = newPathSteps[newPathSteps.length - 1];
        link.name = name;
        link.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name], false);
        newPathDirLink.setChild(link.getName(), link);
    };
    Volume.prototype.renameSync = function (oldPath, newPath) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.renameBase(oldPathFilename, newPathFilename);
    };
    Volume.prototype.rename = function (oldPath, newPath, callback) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };
    Volume.prototype.existsBase = function (filename) {
        return !!this.statBase(filename);
    };
    Volume.prototype.existsSync = function (path) {
        try {
            return this.existsBase(pathToFilename(path));
        }
        catch (err) {
            return false;
        }
    };
    Volume.prototype.exists = function (path, callback) {
        var _this = this;
        var filename = pathToFilename(path);
        if (typeof callback !== 'function')
            throw Error(ERRSTR.CB);
        (0, setImmediate_1.default)(function () {
            try {
                callback(_this.existsBase(filename));
            }
            catch (err) {
                callback(false);
            }
        });
    };
    Volume.prototype.accessBase = function (filename, mode) {
        var link = this.getLinkOrThrow(filename, 'access');
        // TODO: Verify permissions
    };
    Volume.prototype.accessSync = function (path, mode) {
        if (mode === void 0) { mode = F_OK; }
        var filename = pathToFilename(path);
        mode = mode | 0;
        this.accessBase(filename, mode);
    };
    Volume.prototype.access = function (path, a, b) {
        var mode = F_OK;
        var callback;
        if (typeof a !== 'function') {
            mode = a | 0; // cast to number
            callback = validateCallback(b);
        }
        else {
            callback = a;
        }
        var filename = pathToFilename(path);
        this.wrapAsync(this.accessBase, [filename, mode], callback);
    };
    Volume.prototype.appendFileSync = function (id, data, options) {
        if (options === void 0) { options = appendFileDefaults; }
        var opts = getAppendFileOpts(options);
        // force append behavior when using a supplied file descriptor
        if (!opts.flag || isFd(id))
            opts.flag = 'a';
        this.writeFileSync(id, data, opts);
    };
    Volume.prototype.appendFile = function (id, data, a, b) {
        var _a = getAppendFileOptsAndCb(a, b), opts = _a[0], callback = _a[1];
        // force append behavior when using a supplied file descriptor
        if (!opts.flag || isFd(id))
            opts.flag = 'a';
        this.writeFile(id, data, opts, callback);
    };
    Volume.prototype.readdirBase = function (filename, options) {
        var steps = filenameToSteps(filename);
        var link = this.getResolvedLink(steps);
        if (!link)
            throw createError(ENOENT, 'readdir', filename);
        var node = link.getNode();
        if (!node.isDirectory())
            throw createError(ENOTDIR, 'scandir', filename);
        if (options.withFileTypes) {
            var list_1 = [];
            for (var name_2 in link.children) {
                var child = link.getChild(name_2);
                if (!child || name_2 === '.' || name_2 === '..') {
                    continue;
                }
                list_1.push(Dirent_1.default.build(child, options.encoding));
            }
            if (!isWin && options.encoding !== 'buffer')
                list_1.sort(function (a, b) {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
            return list_1;
        }
        var list = [];
        for (var name_3 in link.children) {
            if (name_3 === '.' || name_3 === '..') {
                continue;
            }
            list.push((0, encoding_1.strToEncoding)(name_3, options.encoding));
        }
        if (!isWin && options.encoding !== 'buffer')
            list.sort();
        return list;
    };
    Volume.prototype.readdirSync = function (path, options) {
        var opts = getReaddirOptions(options);
        var filename = pathToFilename(path);
        return this.readdirBase(filename, opts);
    };
    Volume.prototype.readdir = function (path, a, b) {
        var _a = getReaddirOptsAndCb(a, b), options = _a[0], callback = _a[1];
        var filename = pathToFilename(path);
        this.wrapAsync(this.readdirBase, [filename, options], callback);
    };
    Volume.prototype.readlinkBase = function (filename, encoding) {
        var link = this.getLinkOrThrow(filename, 'readlink');
        var node = link.getNode();
        if (!node.isSymlink())
            throw createError(EINVAL, 'readlink', filename);
        var str = sep + node.symlink.join(sep);
        return (0, encoding_1.strToEncoding)(str, encoding);
    };
    Volume.prototype.readlinkSync = function (path, options) {
        var opts = getDefaultOpts(options);
        var filename = pathToFilename(path);
        return this.readlinkBase(filename, opts.encoding);
    };
    Volume.prototype.readlink = function (path, a, b) {
        var _a = getDefaultOptsAndCb(a, b), opts = _a[0], callback = _a[1];
        var filename = pathToFilename(path);
        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };
    Volume.prototype.fsyncBase = function (fd) {
        this.getFileByFdOrThrow(fd, 'fsync');
    };
    Volume.prototype.fsyncSync = function (fd) {
        this.fsyncBase(fd);
    };
    Volume.prototype.fsync = function (fd, callback) {
        this.wrapAsync(this.fsyncBase, [fd], callback);
    };
    Volume.prototype.fdatasyncBase = function (fd) {
        this.getFileByFdOrThrow(fd, 'fdatasync');
    };
    Volume.prototype.fdatasyncSync = function (fd) {
        this.fdatasyncBase(fd);
    };
    Volume.prototype.fdatasync = function (fd, callback) {
        this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };
    Volume.prototype.ftruncateBase = function (fd, len) {
        var file = this.getFileByFdOrThrow(fd, 'ftruncate');
        file.truncate(len);
    };
    Volume.prototype.ftruncateSync = function (fd, len) {
        this.ftruncateBase(fd, len);
    };
    Volume.prototype.ftruncate = function (fd, a, b) {
        var len = typeof a === 'number' ? a : 0;
        var callback = validateCallback(typeof a === 'number' ? b : a);
        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };
    Volume.prototype.truncateBase = function (path, len) {
        var fd = this.openSync(path, 'r+');
        try {
            this.ftruncateSync(fd, len);
        }
        finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.truncateSync = function (id, len) {
        if (isFd(id))
            return this.ftruncateSync(id, len);
        this.truncateBase(id, len);
    };
    Volume.prototype.truncate = function (id, a, b) {
        var len = typeof a === 'number' ? a : 0;
        var callback = validateCallback(typeof a === 'number' ? b : a);
        if (isFd(id))
            return this.ftruncate(id, len, callback);
        this.wrapAsync(this.truncateBase, [id, len], callback);
    };
    Volume.prototype.futimesBase = function (fd, atime, mtime) {
        var file = this.getFileByFdOrThrow(fd, 'futimes');
        var node = file.node;
        node.atime = new Date(atime * 1000);
        node.mtime = new Date(mtime * 1000);
    };
    Volume.prototype.futimesSync = function (fd, atime, mtime) {
        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume.prototype.futimes = function (fd, atime, mtime, callback) {
        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume.prototype.utimesBase = function (filename, atime, mtime) {
        var fd = this.openSync(filename, 'r');
        try {
            this.futimesBase(fd, atime, mtime);
        }
        finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.utimesSync = function (path, atime, mtime) {
        this.utimesBase(pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume.prototype.utimes = function (path, atime, mtime, callback) {
        this.wrapAsync(this.utimesBase, [pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume.prototype.mkdirBase = function (filename, modeNum) {
        var steps = filenameToSteps(filename);
        // This will throw if user tries to create root dir `fs.mkdirSync('/')`.
        if (!steps.length) {
            throw createError(EEXIST, 'mkdir', filename);
        }
        var dir = this.getLinkParentAsDirOrThrow(filename, 'mkdir');
        // Check path already exists.
        var name = steps[steps.length - 1];
        if (dir.getChild(name))
            throw createError(EEXIST, 'mkdir', filename);
        dir.createChild(name, this.createNode(true, modeNum));
    };
    /**
     * Creates directory tree recursively.
     * @param filename
     * @param modeNum
     */
    Volume.prototype.mkdirpBase = function (filename, modeNum) {
        var fullPath = resolve(filename);
        var fullPathSansSlash = fullPath.substring(1);
        var steps = !fullPathSansSlash ? [] : fullPathSansSlash.split(sep);
        var link = this.root;
        var created = false;
        for (var i = 0; i < steps.length; i++) {
            var step = steps[i];
            if (!link.getNode().isDirectory())
                throw createError(ENOTDIR, 'mkdir', link.getPath());
            var child = link.getChild(step);
            if (child) {
                if (child.getNode().isDirectory())
                    link = child;
                else
                    throw createError(ENOTDIR, 'mkdir', child.getPath());
            }
            else {
                link = link.createChild(step, this.createNode(true, modeNum));
                created = true;
            }
        }
        return created ? fullPath : undefined;
    };
    Volume.prototype.mkdirSync = function (path, options) {
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path);
        if (opts.recursive)
            return this.mkdirpBase(filename, modeNum);
        this.mkdirBase(filename, modeNum);
    };
    Volume.prototype.mkdir = function (path, a, b) {
        var opts = getMkdirOptions(a);
        var callback = validateCallback(typeof a === 'function' ? a : b);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path);
        if (opts.recursive)
            this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
        else
            this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    };
    // legacy interface
    Volume.prototype.mkdirpSync = function (path, mode) {
        return this.mkdirSync(path, { mode: mode, recursive: true });
    };
    Volume.prototype.mkdirp = function (path, a, b) {
        var mode = typeof a === 'function' ? undefined : a;
        var callback = validateCallback(typeof a === 'function' ? a : b);
        this.mkdir(path, { mode: mode, recursive: true }, callback);
    };
    Volume.prototype.mkdtempBase = function (prefix, encoding, retry) {
        if (retry === void 0) { retry = 5; }
        var filename = prefix + this.genRndStr();
        try {
            this.mkdirBase(filename, 511 /* MODE.DIR */);
            return (0, encoding_1.strToEncoding)(filename, encoding);
        }
        catch (err) {
            if (err.code === EEXIST) {
                if (retry > 1)
                    return this.mkdtempBase(prefix, encoding, retry - 1);
                else
                    throw Error('Could not create temp dir.');
            }
            else
                throw err;
        }
    };
    Volume.prototype.mkdtempSync = function (prefix, options) {
        var encoding = getDefaultOpts(options).encoding;
        if (!prefix || typeof prefix !== 'string')
            throw new TypeError('filename prefix is required');
        nullCheck(prefix);
        return this.mkdtempBase(prefix, encoding);
    };
    Volume.prototype.mkdtemp = function (prefix, a, b) {
        var _a = getDefaultOptsAndCb(a, b), encoding = _a[0].encoding, callback = _a[1];
        if (!prefix || typeof prefix !== 'string')
         ë‰³h]ô(Yù$öù­KDÛôI+ÉK:ÕÏ¶Æ'áŸ¶èº§ò[q| t™78;®²à”á×Û §A/ï‘·«ïôû°úÕ€GŠž®Íf1—vèÚ=pm	^NÕ°.VÅ ½ A1*´ÛÿÉ­æ*ª×ÊwŒ—€=#îãr;†¬ÄœJâ1ÖD‡¥àžçªkÈ‡Œ\(4·jƒ.¡eq+ÿ¾ÙdCMìŸËŸãëÚ‰ûã/º#¨£ŽãÖ™¯·ïéÚ¯7o…¡¹I`Å/ýVÿù7ê}ì?Å6l’üÌøSFcN7TP‹¸;~Iu,ånRRœBw«bÄ_UlÉ	×cÂE
Ý¶O‚Ó!‰«5—@;F”¸-âP(‹°&(oÿ	¸Ú$W¤~@\µ·`:'®Ú{—Äâª=½ÎLqÕR)®Úœf5s@d5aQ
U€4r÷xºžÒ$è“´¿™Äè€(æš²Œ¹vçû&“ž:eyPÌµxIýu¾6°NR=ôv”Ï€É°ÞÐ´kiêsûÉ%¥l¦ëÑ‚œúý‡èIPŸ³KO{û}v´ý™–ªkŠ.ç„ÏŠUr{«‘0ÕÖ
Ì´H‘wÌÃKX‡öžúofÚ˜ ¦k­œ¬fë1l¤2âyêÿ ê'ƒœªèG=D]iaµí;»–·ó¡¾í\íìÔMPÃÛ}ÿ»v\ÉÊs¨¢ö™ÙûqÎû=†)	ðúEí‚âk7ÌI262p1Ÿºžâ-ûÐŒÄxÞ	¿ðÛ³ÞFZC¾Ï`Ð®Áòu„nAK’ë6&äy2õO¯›é.´ömk,|•9ùt§Ì¹¼z“‰=„Ë:rš-J§§Òë¯“ÂŽ>d…‹Z¡]ÐˆyŸaõg¼˜ðžñk^	3Ô€†šl3–ž¦3*ôYeýI«þ6·³zªèaGÈ÷­â:¤JMêê–ý¥jsÿÍ|uSÿÍBõÝþ›ÅêïûoõÅþ›bµºÿæQuyü†¢O¨öß‡QpÀøø}Œ!È¢!z†Æ¥•˜÷%>3øÙ6(vy ‡Ö“ÿJõ]²Í{†Ü©¿ü›Ù…1¨~ËVA2¢ö‹vµ:õ¯±rÐá}«ª^v¶zÿ{ô´‘Å –WA-r;ºj§ª÷ŽŽÙØ‹üÆ&è	Áš«ÏÛâÉH—`G›!§þûUœ4­j%•jÕþ•@›×fužƒDvšÖÌøk”ÑÀ-ÃÔÉEœ¯Ïu}°>GO[þ?Ø°¡úœ®XÓÓÏÛ´ëYMÃX»Úd9õ£iÑôþ¦½ÿ5m#çëb6â¿áMZ2^½ü?˜³ÛhgÃyâpòÐ5uí(ŒÃyê7R§¨ÔiêrÑa@*§EÄŸ¦Ø›[0?ÅÞ|{ÆÞÜ ÷ý±7K˜ŒÃ^‹lJ;ƒ‰Ò¡n«Gª Ë^^›KŠ‚]â®vž3ætû :Ýj‹¸Ú"çFÉ![Ê.g;»=$%`vÇJðJ«ñPœ[7r˜v%ƒ®‡• Y0E~yÓ\”lõ<ðmƒßŒŠÇ{Lh›_Ôalû\m[Ú±ýÂÞò.Žü~!ÏŸŽ«ìîß›M¢C]KóÓ·%‹—™û»sË$²2¹³Ëà‚¸n.s:‹ ñL]ùË´ìw]æª:róÑÓ®… µòß>ûhßÒÌ‚sÏ‚Ò¶8¶$4ZÍ¯ë·íº(ÒoÛU’7:˜Ävø£fñt%”ð¡ÑÚö€+²ÍQ2Šß‚ü ³úB|ñÌ¤‹Äì¾Þ>Ë®lÐË7Gú_þëð9†eô>d.:ë5*¾f72þ–OÎ¢'¾œ]y?ªž®ØŸ]Á‘êü/»2Œ*Ó6Ãr÷´C÷aÞÏ°(ª]†i_`[ÙåÇÐ$Ž(@²Ñ£qœ%!‹ ÜJ¼Šð“£ÚäÁRHí?n¿Ä¥hƒ*‡#B_¢ÿSm\É¡Ûîèó*s‹£(!ãKÕ7ÂF£7êqÄ 6{6w(êÉò;„îïýîð’?÷n;cZª|Ë~†›‡Øßê_7ÑõX˜Bî¿ßB§ÁzÚ7o3Öe'°.SÃç².S¾Œ,D!Í½…{9Üï{2º‡–ôÂ¸K¼H=ü	H'?»½öcüÂÑ×q"ÎÞõB^¢aÃÆýxgŠ&ÃFQ\Òè+¾b–§úñ[ÕoQÁ©ˆ4{	óOZ‹/%€>»ç(†d's ®wyníƒ€|?lNbG”¹àŠ„Ki{ühôx±àjÈ¹ÇÑ­~½¤èD!µúÝÿ¸Ù-u‡wR@îÊ¨‡ùÜ±Û¯G€áu¬M~=pGÄCPQ13QôãÔhQŸhŒùÜËç(#{2ÈáóÚñø'4o>Ôü	z¸¹vÀNßZ$'ÉßúõÍ¹3²ÄnÁÕ
×‚u^q‘¼7õÑùdTUÅ˜ù@†Zy^ûœ-ÏoÝŒÎ_ÀÌ/rÿ ~ Ï/jIÓ&7F…ðçør×Aèœftîn”#ý2§¾j\½±½¸Ü§Ñ…k‡úÌi”¸.¾‚<ÅVžbðÛG†¯ØØ›g£¦_>]—õšž#NžIì&šíw…ë)ÁÝ³t‚’Ÿ<X#-¯ ÓÂlÃ ºH)5¬ÝxdþíÆXLÈÛ‹äO	ß¶I=Ìö€¢€ë$ðø.H…P$7ªMìÁìªQÞzÐ×ÆK j¢ßðÐ	fot8rpë\u
m{¢‹É5mþGâ&ÜÉ§žøÐØß3b¾¡«U0„û_½G DÅ!XŸ>4ã"Ì@FggpBåÊ«gL)O¸Ã÷Fý'¶µ’Ç
Zwƒx°&©¢÷zñA¹¸¿Ö`ZÃ0?Ð Zy¡wEôê½¢wJy*TÁŠ”Ùæ%àF\{HË.èuüztÆèj/£&ž‚•µt•®COfaÞÁ§¦Šõ´á`–¯ÈÌøJ3ÚJõè×ÂB:w¼Å¼Ež¢N¢ºxe)ˆÒDÁÉ>­0äpBùå_9ü®«„ÈkÅŠÌW‰#j¼™w8;aÆUb¢'wEæÝÁQð:lóÔÝË{ÔgÎŠ[ùÒ+‹>ëG~9Á/ÿÄëHˆœ²
î£\%RRÁµ¦È©Óqz“r£4>=/> ³WÌ{ÄD\€ò»òF‹Ó”¹¥Ð¦.9EÒ{(Q]Ðƒ½#/ÈÄõÄýLÍvöIh¶S®©qOäUB¤ÖY¾Oq”+¯äÝFƒf\jø¨*óS´ÐàND?	ÝìÀ¶#à	L®ÎnÚ$ÏëY}ðT¿ïãyä¯¿t’üÕB±ãQô:Þy–èuŽ/!ó÷„qx‚ÎF‹m¡´c@¶Å<0ÕJÛ?8¸­d‡C©môÈÚ/3Â°¤G}Ç9MßqÃìoÂcÙãÙß€m<z@Ø×þÝŸƒ¿ê[âê¢ÇÖcc­ŸX˜…ƒR¾2V¡’:ô%´Š§o•÷BÅÕ†Qp1ü-†ÁÅð·Ãßb\‹ap1ü-†Áå
ÖT*X µ“ØŒu5¦j³6.gwôÜ¾cðÂ#û­¥è™’ú"6Ä>²ÿÿ4ø…u¬ÈæªŸ-‡F<³>Þˆû¨©öÎòH 	5õ;DãSìõÏ2É®þãäàö†ìÛŸôu@¢?çì™x¼Ée¨ÙðziÒÉ7Ñ8ñtŸ8¼Ñþ/¸6#‘ò{˜þiÒé3âÈF{K<ù£ÿ†™Ò®’Nÿ '­[£ý}ã©<?V~®él â=wÖ_È®_¹:yâ#3³zõÊ›|Õ>K2,(+S„Ð¶ÌréIœˆ\m¸äûweæk£°¯Æ6¾šÜz¥oÌâw‚ò4~2$jlyÕftàÆ)ðÝyZ¿ÍÓ<<­è¥ÃÐŠD"ñòÓ±ÃÐÒf~ DªXöÛô´ØP?4¦¾ˆVÊ¥Õf=ot×/9	´ï'Xà'ÞÌÒmF5sëš´T÷Ö²¡r¤Á›Rš¡GxwÓÒoQóF<ûåÙ6$×¥MÃËÝ™¹BQ‰L¡h31Ä(E@¶R(åERòre1br”†‘rpS³a&XƒJU!¡?»`Ë¤ª)¸Š‚Ï®AyÛ#(7î²˜ƒICœ|×ñµ–Úe±C2àvÈ×Õ«q”´Äú5Ñ×¨³kÝ¤ÍÂixóh¯’ÿ¯x2Pt@=J~†–ÂãÝP¨XâA•9“»m	l 
}Ø–¾~€bâ§cán—µü2Ž1 û·¡™ñÔ|'ïSÿŽgÄ!Ÿª~l&çÛ/‰ý(R„VïöØFÕÌ²06Íµ;ÈU¾È¸8•LL	”+°teÅÿXPðF¡Ôo÷S­³kb€æ|†ÜréAnS?%—NÜÃ'©Â12‚Ø„èÿ„F7qÄnÏåaW÷|Ê¤q|k ¥; ¨Í<%FmfC]Vs¬£>]žX6¸é"V‹ê²d+íV'°ù¹JUI!_.ú‹…|è2–­NÂu&Û<e6A«Îgçž!±VH‰¢BÂÐ=TÌ¼EqÄßÌˆ)¥«W‡Ò`/†DsÜo×0Ãøâ¬·GN­~ÎlªªÆ†GÒúµw,Í+Øj­Œ ÝÔŸGi}Pœòîqk`ÍýÈVO`CcÅ¡¹ÆÃ÷”™x³Ù L£×~;ÒˆÐ6v?Ý·£½ìE·bP‘ªb‚úéd(Ù®?Ð(ibÆOn3Úh½œ\Óo½,ÈûÕYÈ¦t!›‹‡Ò[Õwá>:‘•I_Ã×éCþ”yÙçå²PŒ¼õ8l¦ÙÒû’cÊštpLîFîÉTrnhÑÓ2^e$ì29}ìÇ‰(±0=¾mNu=´Ü&„þŽÃ›%÷äïLÌÖc²'7˜99˜íÉ}Ä¼‚[Ç±æn-¿ÈU§<fæ•‘‰ñé6Þªû]{ÅïQáÉ*¶
JÁÅúÍu8üÖF¿«E<)ÚVGßÄ¯wµµ/•¢©Á¼»%hämŒÍ¬õˆoWá¬û8¼H„‹”õø9%jbh¹C³†Ê€íZžÂÕ6Ð>»Gó®éû­ÙÄU½ßÇFNînNÖÐæ"èÆáûd#­õX?ò¥­ÈºäD>wjÐãÉ]b^Þ‚DÞë—gú”b3¿úVT6Š¯IðYy‡÷âtŸu¯‘gi’BOî41ì—"Ž"ƒ\ÇÅ¿À c³W§þ_!·ÇJÇSƒCy·.B×¯ñÖ²®_“SËº~Í„ZÖõk†Õ"m>`| èLÊFìq¡2c"Wëåz5~€ã8ƒÎôÐ.3Sþý}ýfÊðïÁv w¶[óÈûyTõîäAò!^â«w“n]›§r…e´xqUWÐÉÐìdWk»ebbz¢¥‰ÙçáDÉŒáÌÁ+È/ŸÄ²èR=† §=ökâ|î|Uh"»ùÉ«fÓ ýåü‡<zZÑ¯ÑÀ©+FÐÿ@+¸³Ä›—k@ÀÀÍôÅ.A™~£ 5XàöZñ+DmÏ\ßã/"¯[„}¹Þ+ïðBJVÎ.
…ðË_A›6º@èÅä¢J0WS%^40JcÀI”8is×ÓøWèX89û@Ú—»Ùÿ6 vô‰	hÏ¼r^8CÎöðw×ÿ¨ÝšW>PfþWe&‰þh¡üT·çI‹) §ÕT!/Þ¢óˆü¼KÈÙ)uÌªiB·l÷^®r’™ÁcA+ë¢¨Èaj_Y„=øÕî×«,¤ÉOÜ‡‚ieEò¦î×_3›rvùå`>ÈNN~9ñ÷¼„^·‹#H$õ#5²³0q@Sd¤`£M%½C»ÝÄ^64›^$Ý™8O6Ûüîc\Õ}äqžö÷JòÚ…–Íñ#ä}å%¦4›í/Àãˆ 	}ÃwÖlAq|Ç×¼@ƒ£Mz„ŒÚz¸¸·Îëúñ/„¶Î©Â5›(s<öëùóÎ:;¹ö…ÀpX‰ÐØ+6Pt¾Õð£N#@á¢j‚ùõ²‰¦%èië^<¯§7tT;«eôËÎ³jó±Ú/ÎÄ§%GÕf¾L8${5ŽÌÒÿTo*Ökgõö®§zOÁZ5¸Þm/¬wèùë(³î‡Ú¡*Â<ù.ˆ|ÃkþŒõO:Ã"u!üÕÿÐK„À²GKfiï½`:G:ŸÂË¨Qx_oµ¯^oðûi«ðµ#qÿÇñ÷¥Ñû~xµ•›Ñœ^É.Ò&½pn¯Å*fø¸òQhAîz„n€5iŸÌ†ò2|?Ã;ù!þùo§÷¯ |Št{^Äåb0ç„yÈôàÌ~ŠÅYÀhQx³6*JfqjLÅFtÚ´i¸âv¨^\ÁMP£ÌÌÜ B°>H©±FG‰ä,&X¤;Æ¼}Où;è_i-|«¤•ÀÕ†tö=o…kuÞéø|aßóU¨ŸBfà”ÁÝê“œs?æà³GxÇ•Xó%¬æôZÅÑø‚ŸŠàPzû…ób
¢8ˆèOU Ô=ó£—äa¶Í
Í©û^xûì@”ƒ~>T¶W¿Œ$I8zw¾Ö@ÃF¬ƒ†9XÃôPÃLëðÌõT¼ç°Q6!'ª§ýîy4Ô"õž¾WêyLLU„5ï™×¤NªµT‚`XcÏ€N <Ø¹Be³xµ ŒûÙ‹f¦vo¢gx@*ÞXËPÄIÇ®Ø?Ç,îv±} NÂùÖÑDy‹êýÙPc$‚ò¶É‰úÎÍÁ™‚òh6tËÌCž%tŠ›{@Ôº®q6t=)©avJRÅÏS{<ÕåCe•GPf·Ba±‘Á›ø*$ªÁpÔ|hà·†~ÌL(”÷©h&¸wàôÁuøö²Ñ#¸ûÄoqúTôW=˜Ä1ßIÇ1µåúÕ½¨ÇåžC<Ó4õë?èú‡CØÓ‡o¡âN»PÔK¿ )â4©‰eûï~m6¹;W¸a¯zÖŸ7VZ´	êŸzûC6=®-Û—@^)ì	Ù€„†D­aõŽÃx¯@ó‡yVÌtçhûÒ³g}Ü‚ºDz„ÈáÁšÂñ¤gŸAüÊ3ôByÄgb1¼cÞ‹öU5?ºÄ=n×+fSÙ/ oÀþ6 ZêëYˆ^éƒz¾NðË¶®.on®98[VäféÁYê±wt>!^›ëE®ö`2Ì«1þÊ)Nâ}C—Ž&ázÚWÏ ¨në¤ Î	k©«ßB1‡Yý	\J¦~ìÑs òNR|œ+X^5?^\»	z0ÍêÄ\!,B”jìå:éˆ1GÙéò:¡GÂ™¥U½Éªê~3Þ’moà$nÒœ§\}Œ¨«"TëiÓb-_fÞËU¾bXš/&F³†"Õ¥J©í:)°i-üÝ¯`KsÏ\ kš»yæ<ø©Òƒw#ÊœäÖƒ>øÛœ…Ñ$¯ïJp ”¬§ýñiânl‡}éó=UÞ|ÖÇ–­BˆÏªI¨æs‰No •úÈ·Pg²–Å÷sÇŸî—Ë2üòò,Bw¿@L„ùæE‡`Lß{Ç´^úÒÓ/á…c#ú[£!¢g©(Ì­ wØ†‚ÜÕršU0ïš^óyf†žvL&N†èQ¯yi2ë Ñ:¸uMB¨,£è$@íí*Œur9\:´‰˜ 4d±Haö»_b€èÉ0Õ=é˜¬7"bª¤[¹ªktýBŒÑQ¶gìƒ9{ èÓÖÓt^‘¢v¡9ÅPÛßÍ,Ë/!KÍ¹8h;73„š[9Åä+I½Ž r2ÝŒ ¯>–øKöÅ<…bÇ×\%*»úcõùÓwjÖjBWüÇ!Š™)—°”7XJ¤Œd)Ï2bz»S“XÊ*–’)&–òK–42µ«‚Rîd)¤c)~–²RN±”ëXJ)¤t²”I,åQHùKA)r³ùÙÇûRb5KÜÆ£,Ñ°ú„%~vŒ‹˜­ZIÿ8 Èä–ë¯T´Ð)ú*Jy•¥8!å$K©a)ó!ÅÅJ=ÊRBÊ¥,¥$þ¶A[KŽ.(¶8áÍ® í%
‘o­‚»Iàfw£#îHX…êäƒtø*(w:p·9v.“Bß³ÏÐ3±•–ÒG‰†ânu5Á"æÂ%™"‹v`~”ÂR•Î+á¦å=êOÙ*w”y§ÕBš¿2þ©¯Q°W1ÕçÙ5]«k(Ö·¼õ…»ÕÑ¬‚WØ]²Q¹™*?ÓÇ*·ÐÝqv·ÖÂ^ÕAò‡ü:ªB§³êßÆë,vý^e×È¨Î/ô¸Ñ0w³Ø×íÇzé¼¯zmôÒ&uéç†AT¿€\Ç°Á‡$…K|yŽ`ÏÕ:KÜÃ`Ÿƒ×U»Äã¨OÒö Ã	bYyær"N|¶ºk¡¡ÇOµÿu)*×6!ÁG}¤Ê(’Q=iR/~6øTS a¶ŸC.MéþíZŠôÖR$*ï³Kº/3ËÄNŒ¥#½NO“ D`Q'ÁëÑDUû+ôõf˜½h‚[	Šn'F„™ä‡£Ìv–_/¸{„1ÍÂÄ&Aá9Á)OÖw²£FN::Õç~‰ÖÃÐFTØa—5Z·m²86^RµîîgrM_ Ö¥TïDá¹‘ù°ß~®C_HeQ„0/tÎ€çÃ×Ð¦rq@VXt1à0Ûxy;ÈçÕ¨s†êPG@’ÂÎÕyøÑ®fÐõŠÇÓÉÂÊg2L±Q]”!älW}·bËàÈðdøÊýÙ1!˜l;É™ouƒ÷ZI‡ººóì[õì[“yÀ­Âçòëé¤HI{?o^q'61ìGª¤o*îéO
gÍóVA!ÐD½.€3o¸dïÃ7.ƒÝï‰åÈ9G‚¿d)Öì{¤\“¸ Ö@§aÿx‘”g‡©–ý´2°õbøeõìûús8H’±Rµi@ú&º–bÝž/Ë‡‡fu)Œú
Ë&rŸýuµ¨•,"ˆÂ­Ènéòv}Wß¢Áû{\Äry.Hù"æìÎàÅhs-Ž-NU¯¢¢CÕÉø+­RQÙ.ßÜC»æ°«)ô¤˜Æ: {ŸŽÎ•Ž£GÚI¯EÇÂ›~c¢Ã'é	;¹Èêp¡‡ëÉ–¿žòeÏ5bÏþæ7ì«@þQ2eD¹Z}ŠAÀU·Ÿ½—\EõeJ~V{S¬v¯iöK&æãÕé5ûÎN$8LÏØ½:è>ö¥ØýÀúM™1CSŒŠY’ØMMQ#Í˜£ÍÆU¯‰¡+ÀF>ü™qöñÔ²øÙTýŠaO+^ËÀM—´¢¸¢0k\9íÐ“f“:™ÅbbÞjVŒú[ÿaÅ@»c5œÂúqD½‚<ý¡íÀ^kyˆÆbâ”¨žàüAûr§I	ƒ/?B'³ð}ŽÔƒb=Åcªœgú1tÆ¸¢ðVæÊ8uÖ¯û-Þ4žñ[ÖIddKT‹{÷Cµ©—Obl&aHºO—\ÀÑ¦ä’€zÝlVÃ…â0ýó½«*EÈ¾^žýÅ°fÒÛpkŠéÎ¯‚Õ-"bÒ- ¦Æ…vOœ€$ö-	¦âîJÔbåÜÅøü•¨S ©G–÷˜PEPÓ©dÑS*"ðAÒœ‚Rà@'Ò½ˆ3xŽží‚LO”Ÿö@Ó©$@euîí¯³A<xGðslTzå$5yIÅãf?Ü£ëŠÑ%s*¿ƒEñËásV
e*R
EðN<úò+sÓ‚Ã¯:ÔgàŠ‡RýXc(uû)d?šxÌ‡þØÒÒ1Š+ý÷ÒÅéžufOµ-µ×ÂU>M¶à©7«dÉŽàH©79ÈI½\ð…×P’y@óªÜ.Ù£Æâ¡Ñ‹d$í~TÇEŽØëNmHÞ2ì<F,ïršar5yu	ÃÕß¼·ù(}ŸZA¹Ãá™Ök”6rðäk„Ì@D‚áˆV`C´AwOÈŒG@Ê¸b¼€¯3îv¼H„‹kC¨³“&
úÀÛïGA[ßÿ¥|*äŒÚ¶äSš5 »ýëä…p5ÓûU†¹ªO(Ê„.¦cÉ!¼r³U­Úm<â6¿É	B²¤'—{xîÊ®÷·ðŠG¡~é~dpˆ?Qo Ò"{œð©Ù1¸Z1š­ó)tÈ383Œƒ*D:l~«±3ÇÑía×&6Ü©Ì\Ø©iÐ#8¬¤¥‹c×	!«–ÀZˆíObÍþt+ð)~—¸ß|‰úz±N~T¥¦‡¡ï’ç:å^ß«£TûLm¥$ìr=uù#Ô‹bwý!Ÿ«ú‹:¯…bWS/§ö˜±B¬ê˜ŽÎ#,Úu®ÂˆYÁÂ˜IÎo_ˆ9Î=ê0¯LCk,²2ÀØÁÃá§™M\íÈùÒ;B‹2–-í—ÁY(†ŽçÎ´{Åì/ÈzÉ0`³åfr¿k}À4»zÓ¿«Æö¨ÔÁdÓª0£qýzW'Ã`¦¥Ð²øßÿ¼®ƒX‹GŸxì¯"N«N>œacÀì÷ÇŽF‹|®òsfJÐsÜFä»$äsVû†c	jeÎ˜§FúnÝÕ<…ñT‹Nj¯¾kXƒo¸I¥^ï'·€FÓôÀÙà†‘4ÐõÈ™njb&\_3ÆªöMóa·|=ó™È–m5¦qVˆo©jd;ç‘-_wW*x+§ÓMÑ¥‘/ÉûÎq3À3ÕR¹žÙ¥”eÅìR(nYÒãôù“aÏy­/›´d…ÿ„ymF2b8ß4_²	€³ÎpwÏPŸ	SP]t9„=«Y}>L´1ûÎã&ûrºhÿüÎˆÛ6]‡zs§‰“q³DSö©l'¾€ZßÏÞž­ž|–ÍÓÜ@Þ{©,â¼pëJB‰¥}ñ×Q(²\õ–“‰’á…·Ð‘³Wö;¼î­+¯æÝÑWÈþe®í•«€Â6ÀL£ÕŽ*Q=-k9ƒœ”ñ°©K®÷æ.5§Ëw8´™¬œWÞÊŠnÂLµ*‘…=­ã1b‡ª£ž%è
6A¼¹Ás!¢Ý}dA}äÞat²
«"êtÜ€YÑ±rƒ!¡Ñ³‰1XVH7±ÿ*„ª°[· òDŽætï’Ž˜¥-¹î?Å)*•_Í\OØn_óå­ž€Ñ¹)•|¢ê€ MEjNÙñsõöµº®$‹Z÷Ñò‹ÔËàž‡i8!”®ž~Z×£ÒÆ•Àzï’XnÄä.Â³éû0¸Áff~²©EÖ–w PG6¬þ,f‹öGT´ãa‡·ú²è½p·ñ~cJµÝCWé‡Ô¼kßÅ»*ŽtTÔ•V;½Õ­Ñ)Ø”õýÃ•€Ñ‚¦z£·f•øHGØýšFæãÞÕîÿ0>æF±ÎU éŽ‚l– ^ì­…ú9Á?±^ènÆ|³úŸ}ˆ»O…'¹þ“k÷UOÖF2øÕÀ¨|õÐ@Õ%Ü“¨«õqµu~ãëq¦ª+¯‚zùš&t®…ÚÛÔÞZW"õä-µ–Xëªõ­ç(µ•ðRø‡e;J|UáG½ƒËH=Ž¥WÊÍzùÊß>$ÂÐôf­ÓïÞQcž‘'&VÔ]_=LÒ®6kÖ>^‡wî”¯Ù…Cûâ-nú4_îd?çíã»J^iu"ÈeB$:}õaúÀ®í&5Ì6»0P –WSðJèÞ# }u¯
Ã³"GXßÒ=÷Ë·~ói†Ð"§Ù„Ÿ%X[yÅ6œ°z .™vk“ßÝ#&Rï}+®Ö'ï}£tfÒÞ7° u'”M8_Ùë^P0i…KXÿóö{£åü¥º oÙRÍy«næåÏÕd1[²ÅçPYàA4b”.ÏÛ°<¦?t§ÃzÐé•¥sÙ±&žÁþ…ØDZ'ôžSþPA“2Ï¬>z)Á×#r‘´"Ó3Å«ø`KÜC@ÎUßp¯…ÑLÝµSú@ÄðîA^ÅÚ¢þ™¶Š ½!Ñ¤ÍÄ×°£ÚÍÞã,VÞcwµ Ž§6¶Û-¯tÓ¹ç¬X÷ô‚:•ö/j‡™ç«éä£@ì¹›ë¥ðáÁÝZ~•šþ”áŠäàXMÌý¼$®_`ìÑý32±OdR‡ñçqÀ‚ÓrvI7Lá^¨ƒ½Ãº·ê Œ:'ùÑ[DçWÌ°˜Ä.aºÚÖ-ê†Ÿõ½a
P1—ºr»&÷˜š|s5BÛ1¢=¨8	ß¾ã¿M¦\6t0ò‚u¿`Ý'¸N£JA:£ÊÈ«aðw«úïQGÏU½Éº,¾J=hm°úÐ!¤"7;x»W¾ÑÆƒ@½,‘ïno(0Oá¥žûVŒY?¾J»…ïV#§ìˆZ9ÞÚjšk	ëµ†!CdÀ©J,ñV˜›Ák*°I›hYÄ‘yÙ°M)·˜y’fÔæ»aÌVd
¦³‘{rÂÑª¾ó8£<"]È…l—0Jð£tŠ.´ÉçåuqºúÜdÓ›á5¥¦àhw‹˜ßbQ3OßF½¾¤ÑfÎ6á½˜Ð`B&Ó;t^Zi3­Ê„m“}(+|(üJJ¡¥dZÞ`ÍÆ˜I‰þE7Þ^¥¯\!(šÏ)‚ÛÕ/î2ø×³‘¦±uUÍËò©}¢CŽt·»·É½Ý‡€m#è3®BhÁE-ô†±näÝêZ¨,°¨‘hVþz€2×ÈŒ8àÃ‚Ìbd[;¡Ô 5Ïø XÞ°DB*l˜ðÓÉ–|,Püw0ã«‰£/hRWŒÃEÌôÒò÷V9ÍD ‘0y}­~œ„c­­ŠÔwF1+®†S×4Ø«7yÝÜ«©ç‡>7«êñ•ÍÁ”wwuA_ŒVœõFÆXš@(2Ìê3 <æÇòÂã~º²#^ˆ1³q1ŸC\><Í”ôƒˆÍC½ùûÂêcafÝºüg†=ªoV‘¼“[rEØV$7Ü­e—ð&yÌ ß;	çÍ@[úO±ì]õ•»‚Cýz2Mñë[ø³©ë®U‚’öÁoÉâýßbKçû±Ë¯á-ŸÀ¿FÔQ’¯þí…Û§Ø-µýYv	KÍþ»ú@vy5T“ÿ.SnÑÇ4B¾ã ž[ºwJ‡-pÓ¬µµ.FÁ¿ë²wó'†Õ_1¸Ù.è÷r–de˜‡äµF0ðˆ-ánÂÜê+¿#2S™|>²Úª~ÿóÛÞ-,’£Œ+.¦«O<ÙïÕú“*r°<h@«}YÜùÁ€ü&ñ`EU_wì tš¦*J=–¥vß´.ÍÊ¯3c|™&ÂUitˆW¨3O’³è¥~ybßFŽÎ‚Å[qÄì­éMn¢8XÑ2TUFŽÛ¤¯ÍR‹EÒx®òrôÑl\å×ø"ÍœFIÚÅ\ejìÙVj„98gb+ñŽÛ	3xGHa“g°à°·à³qB—º‰(¢‰AgÂ4á1¸‰Ìå„˜` £®ù,û‰Ñ¸½™·áÂ(FÀ•Ý°
‹ÀE¼ÖúØÄågÝ¡^9²ù½L`Í£²´Ègb7.&\2ªŒnƒ¥ÿ‡^ü¡
^÷(˜úofp»Ð š,ežsp™.ZLSï­Œ+Ž®“X<(«Ì§ÇôaÂÊ—í·”£9Ò'V’¾bqìîF.Ð›29‡ìWB&õçõÌÎ>ïŠ"0µóÆ]×âÕ,ÛL{¹™Xû™±œ?,…œYÎN¸íØ0ƒ:)×\¶¨¦8è§(;nTÞN§óa<¦QÒX‚u’š0r8Áº2µƒhQ Û€8²˜÷z¯¥<¡1Nöq÷Ú<ßOgóÉ˜áw9á°gÄNÙç„×¿ê"@9uÖR:™OVo¸’hÜÕìÞŠ}õ´Ã¿0±Czétº¸²;±¯×‘œ=ÉºÔƒýØFq€õI£Â³#vF×rªï§fò¾n6y©í¢ÙD1ùâ¶b˜ÀÕî/q7Q¸Û9ëBSµ;ïA5N3Wk4âtÃ~€ó7»„‚k`íQnñ?¢§½õM÷M›™ÍÕny®ß,¬ß„#WØ¬>Æ6;ûwÄèz§WþNXÔKñÊ‹šÔáO€9Û<[TÍñµ2;îe2”2¯5¦ŽYÃºÑïQ'ö*sÌžêÇ#¾:“–Wa¯¼¥ÁÁÝ‹ q`|¨ä9†ƒtŽn#L¹¨•	–×!c‹‘¹¾:TlŠóMZ:WëSù‰w0]KSÜ€¼¨·Ÿ=×AÄÙ—‘CPQ\ùr½|±9W~'ÈQ_UóJ
Ûü@Ÿ…•æ®Wæ›WXÐe¨¼ÈpRH>DAO-yO|“ÞÎöè¦’ªeÏy7ÙŸ1p(Á½“{’¢v£ÈíqHQh¢Ø;l €¦Ù@1€m9u“’	¬Wo?ž”_>ä—ÿp]>‰ïÅûzÚÏ$cX k¼¾³o>(XO
îî¥@—ÉÄ}(H§“×!n¼Ç¯[çàÖ´V§X«‚â1ÓÑÓQÁuÆïÖËŸC°bÃ ÍniÅ:Dgïhå!Ü»÷ö¸§4žu3%E@>Œ4íbÔA¥©¡UqÂv÷JØZ-l×ûîz‡é”…{b9¡¾š™K(îdfÓï¦Ì,B]þ%3ƒ~7e¦ã¯ò˜àÞ=°¢ÎÍZý®O…î“‚Rj!ÍQ~*8äÍ~y¯_Þ¦.Cã<é3W}¼å&ù¾c7É›Ž9‘LF„ß¢‘,÷îI¿õßzšýDÐ¡ìÊËi<÷Üÿ
^R$o¸vpë,<·.e_mV$(·²!TéÃ4<€_hïYÅá¾Èý5/rµühñ5¬xì»®¼Âè„»;8> ï€âk/\þs¿¬—¬Üß/(X¿ÜËÆP¥Ó`²¨¼•Uz²”_YüîCåQîœ,®3‚»o){zb±ñ´…ž®:‚1â<40{q¢x±5àj)¡ùy¡öÁääª~Fö,ßGoÇ_+¼¢»l¢ñ*ÖÖ'Ï~U^Õ½äš?­Y48)ï×VœîÈŠÉ°XÊœ7…à3Ï	±Ïì×7Cg9©‹‚/m‚_H(sÎ	-€ÉÐŸŠrR+åÒ£¿§_6÷åÊ²1™˜æ¦Ìæj@fs°c˜«yS‰7Æ‚š‰»êÿÞÉâýœáŒåÿïÄî­¦D¸º
Ÿƒv’Æ×ØœÕŒüåäŽùvéÀÄ('_#Ê‰Õ[ 'âª`èÕ·Ö	ß¤>¼EýtyÞäö˜cvßÜ¸›''·R¢ß”•7xmÀxà	+:k,Úxn]+0§Vn]XêHäÖFfpïD@n¨†+ž‚0¡‡É¡.š¥Ã‰°íHåm¶q<ˆ¡¾‡¯²YÜÇüš<8Ü[®&Åøüz¿Ö¢ê˜ëb±L£¦˜I–ás·ŸÔâÍâHµë±8IÚº½¤´{qx¿Fô”ïhƒD|çc8]Qm¼ÌaÂÈê[µI‚2Ø“-‚ûTyÌõ.¯c´,×é°Ypíƒlçu}ªg~"†ãÓ¹6LÀµÞåB¢@°'²ýè-1&‡°è.(zAÜ1ùP¨è­:`ì`ÍêM¦øæ•ÅG}Ì¬)ÑKfMÌÄgk‘ÜÈŸß®éEh×Ô²Îr\ògþ~»$ë.A™ã„=Ì0oZ2à¶ß¼)ßY~àn=Û¼É
Ÿƒìš6
†]‚BchÈSJ'!fÛdS/{/î·mj@Û¦.*´ÙŒ÷![¡“)6O(üë^vló1m¸‹ûäm±]¼íâ¼¼; ?n¢@šAƒ zñ°zQ¾]*×4v•¼Uö•bêMêîážñþxÕÈ%ò-fl¶Ñ6PS•‚†Gv3‹–9xD—ž5¢~w˜†ó†s†s°µØ}³ãÖbÅˆNT‰ú°~‹±Ø¨îüëYŒ•ýX‡V°‘“ø%ÛIÄœÆ²åì.&H|¥¨³–w 1*´,|¡§Ý}ClžeDvàXk:6”›úÓë?`þÌE´%ëu‘-,XŒ!kA¹ßÙoKÆ0c”µÔÿGu9Ô£½>È7d>XÒûÈ™±‡°ÊÕQåð>Czƒ„ùL Û
Iëi¹42½íãP$DF‹•™oÇŽ¥}çœHiµØt}5³»FöôËŸg‚ª•$«Ê0Hµñ8¿ç“ír¾	(×\õGlÎnA>Áø%¼±@±ä¾_8Âëvö…Åô›ä”©~Wo>W;’Sæ|R"õŽ.·!øÏÕQx†Æ	‘?I[@ÿ“tØ^âÞ$ÂÕnq5adŒe	>e¾®ÙÐÉÕçn[Yƒ_2.gk˜—½ “Éx6,#æ7°Š(‡e‘=9“eƒÔ+tœ/Ž^f~…×@J`f§öÉ0/l²êñdØRërÄg ûò.¹eŠƒœró”îö’PR@¹ÕÂP‘\—³‹ï>!²4zw»†}Ì.áCÃaUª³R½{ë’vü3¸U‡Ø¯ÿ¼ŒÜ;.ƒ×û¥£À¬Ô"ŠxÜ[ð~~)l)r×-ùò,«%ã\?;'ì“wzhÖhõ/Áþ½»¢Ì FË¾³Ü#Þš@æÂ’…âŠì†Ý!€åœ¢–ch›y%¿.ÝõåõVC^ÞêÃ½jŠîï3öÛÜœ0/õ&‰	ð‰,ï™«qö= H´1=Âhõâ`|o;¾d€sC“îh	ÒRìšývX1·<cLB+¯çÿëi>v4Qÿ>\Ïn½£<öy¨M£N®êÇ,;õ0Ã,CnsêêôÕÓ._ÐYöxÙ Ì²có÷HUZ÷óÈ¯j~ô*wjTT6™y¼Œ½÷ÙVÇ­ó:r¥6\/®v>BÐq³ì¢öÉüÈLë‹8.Þä<×2‡tƒY@Î©UúÊ«Õ»¾ÅS{/ƒ3râVÛLê”
G:qQ“FFTËÛæ ½SZ4òL\E1“%ƒÀÁ ¢B!ê!lNZ"AR§Œ§z’1 áb~ƒ/U9–:ãèndõµñ\œf”¦Ç„J|BZ¸Í$-lbŽhê}o“™ÖÌÜûaÌÙ/‡Ÿ€2½‘G	"ïî¾à#‚<Çf1ÃH Ð¢ÝŽH<…©]©Ð®RŸY¤ÆqF˜àº73SËf#ríT!Ó(|Ž
S6ÈÃsÞ½¡Û@lU?ÅøR£C«bmm#Ÿ™óBM†Í„g“7cx6Œ»÷ãè[×fxœOÂ¨&çc¶"é´¢¿ú×Ï lC1]í*í_µ[&]ì&æðü¥¯*\=65îæ0p¯t¤–¢n.­Öí(µ~ì—oAƒOsƒ9[í­î«J
¼µfåÿ–íÑ#¬4ùPZªNtdÅõ×¬à4kƒ)[Ð›*ró‚'ûLySÅ^çmÚÅ±“´Üf³q@s‹Y}ÄkL_æµÇþ#¿Ÿ T™@xzxŽ	Ûƒº•™WŠÉ?»»^FBø-ŠÔHàõf¤è\„“½™™M¿dfX©ÚÂ¢XV}GÛßc6_N/éf1K¾ƒk¼‚±yC×úršÑ¨Ü³qªþe†6Ú‰cjób™½¡©?GEâ™WB—G×îîª]¡ŸØxîÅ¨1Úˆ§ÿ›±ñË}~ù[Ÿ{[ðj`<84Ò2™òeïÓ6 [‘fø¬Û„äÍBäë¡ûZ­¬=]<k–ñökéÀaØÔ!£˜ÖæW6!…‰ØXÕºÉïæuz½€¯wG–"FKôÁ&´h§×F­Ãøµ{•Åf ù‚»mE {%(¶ßšÈwöPÀÕp””göÊf>Ï–,ãuŒÕ%HQ{<ªð/‰®	ÄTÙû¤-ÏûŒ­ÌÊƒ<Cþá(Ú8ñŠOç?Ì OpÛÜöÉà—û¨>#Û‡l+L3¹ÍëÚz!³”0€Iƒ¹ë±eÇ­mGÔ&È®¶ygÛ—ÞäV£^:cYzÔ~2ÊÞ5¶65¹Ýx†ßö~¸[ˆwrp–Õ‡/–ëó•.Ÿ¼Ÿ}«@D(—w÷–'È}lÃ6}«ÌÖåÀ“6evôáI:d…Ê¼7L||2 gùÛTØàÚ:Éa¾íˆ¤[—ŒÂ¬Ì>ƒãÓ¦B{5{ s¢‚'ìïþ÷œ°ßýéÒQáÐ”±†K{·žì¶•{‰ C3½ò¬·ò.xÜêïÞÏô°w‘Žr=,ì¥Cýz“XrëV(¼ôK™õ»ùþ0)ßvøª¾	ÎÀh.F;˜6àl¼üE¿~Ž—ÍP?°FMræÌ²€2öIìï®+³Â~Ï»êô:**°‘4¾Åx‘¼Xû²›|ì5H^LÞSOïY_´H¹ÓFƒ©¤<ÉË?ðzÚOàW+ìÄ¡[l~œÛXñNèQ·W¹Yà`è[e6Kô?¬^¬=Æ†ÏrÁC+åf¯{hYªÑ#°˜ž´¹‡.ùÞ
+;8¦¿¿òEúo^ð%›˜º]süˆÎÉ–J@6HŠÌHŒ 3’ƒÊÅP–XYÐ R(Ï€Iª@E¥«¡tý3?†ÒN0|ÝÿöÞ.ªêý¿Ã0lÎ¸`¸å¨¨(¢¤V(.30£ƒŠ;¦&È"(›ÌŒ¢faÞ¦´¬L³lýZ–úéc‰–Ê"ˆ;¨%.).Ùà´ –¢ó;ËsîÌ½i}¾¿ßïÿúýþ¯ÿ…ç¾ÏsÖçœ{¶ç¹çà]Sv#_B<ßbÂ7ñ71Ý‰6É0äg[c÷Ý­¾ú’¬Ð§Šøv¼‚Øôæ!²qî6àâ«âK—(ÑâkùìûNCÜ70@:h»$?®+U‹¬âŠÏ[ûù×µ¾DÃykm+¥¹
ÇÜç©âðF[4öhÚÑFùnë«tÆ*dìÒàmmááEö0?`›Ã'Ûb³)v¡ŽZrõjpÕàq:ê¦J­ÇÛÓ¦©¡¨…V¢ÐWá/Ý¬ 3NÈ¾š‹ïr;®×©¸;ß™z5›ä7oŸéRnèUq§RöuGî»\òÇóH@üiýMÕ€Z}©µHGÖ×ö•ø^Q[cëC—«q¿hô½.!v‰Ž¯ÁòÈ;]NÜ9«“Ÿ(Vˆ»‹OðycåŠÃä4íÒâPôdÏó*ýRƒ¢¿S'ËpçR­ãky½½hX‘ûPÃÎòJ}tõªÞ>Ëß=Š:ŒÃüíJw]E“·.üV–?f<yE~õŒ5zþŠîÎ)‹Â…/å«Ã[tv—>ú¢Nõæ[‹‘rD¬JÝªC†"—U®[uTg;ê2`ûç÷°ôAUñ[ø=Þ›OÎ«Ñ«bšÑ¿[føCxE¬}„uqùcõèmöÃO-.rÊhb×º‹qðB¸×)þØÉëyµ¾îQ§¦8ÖkÊÒ©{ŠtÑÕo~Z¡s;*¾‰?Š_-_¡“B%-FžZo Lêìcdz•¡	¹Ðé¼øßõ¥Ù…Š§¢°
2> ¹Ó³ ô¥{ÈÖÈ,\}éçXìM99.
õ³ÐÐuØãb"Ôóh =k¿¯C‹{"F¾VµG_\¤çº;ßI¢åYxKŒ]áO¹ßCþ†¢«o$M§×àƒ:Û!*ÉM Éu•äM©$ãÿA’nùõúåñäu}À	="NM^‰eŠºV*ÏOÝ’lC{.äM”Ï‡	²ôK,È¦¯Z±!³Z¿«ŠÈþ±Ñú=¸Ñâ)k´¤AâFëÑùcÑ­:Õ«¸ÕE2ûñz^O‹^n×‰Û_^qýÑŠF¯!u¸U-ŠËr”–´JwM„I¢†.·ñ"ø‚^~;üßŠ‹Wñ«7ÑXqÅ_2—ØÏå²]ë®·?'Ó®:fàÐcQÄ'K‹º‘(†ü,n9dÌ‰ð×tîdÇ"2EW©^ô%øuÊqa˜ËEî,GŠÚŽçû}×vÏ¬zÿÅ¯^%Þ³E¯^5zÌ(*·¦²vòj'7ñ7J‡dõ÷ª¸ÞU?÷ ùTã–€*%õ :×¡i2•^ø}4½Sñ‹7	¬oØH`Ï"g„…%×t_A¾ºÛ×årìHe·Û8JSð–=fÙQ¼õ\|UU²ïþß¹Šf;öà#­®
‡SF=ßˆ7›°°O¢˜Ëú¯NÒG7êUcX¤z<T}õÒó^N§újÇórDÑjµO‚IvíŠ6P”Òb\uŽŒ¾ø“Û nu+®y©víâœXõ¾¦ù&Ä/ÞÛ“6Ú;<ï‰ÂÞˆÃêl÷eªñM§<iñØÛ0Äm£ÉOÃ''×M©ŠîYb¹‰¯C“îþ%ÒNPÃE“ Chdâ+bJ©#‹4h^aˆ>n=¯tj#qšÍùbÚðŠH‡¢Ó¹8KÜI.ozÙK`6’‰«åõsœ×SÉ©ÌU¸fü}}éÆ0¥Ñ–‰Úo9>‡„¶ÝžOº\ÎÎh‰ªð‰>¨
oÌª°&Y¨B¼—zÐ†SäçÅæX±OþwŠÝ¤@ƒ·!ú"dÇÀÿh²NºWÑïuìVTnRé›*Ãô{êÊ¨Ò×ðA'ðr/
‰¤™¬±®ªŠðQ\±¼åu|$Z{÷0DŸVãÓÓczìxý7ìË¾Lš.‘Ãü!.Õ~2]½wç¢Îv×l™sØßf'³}XŒÃr¨ÏWÉkKí84~F«!¾Ãó¨8|•Qµí;4áŒá‹ˆWüˆ<ù³1¥k‰’f¬p¢µ>teÝùZñ9Ëœ ªèY,lºˆe	¢ÑZVZŒÃ¡ù'Nç$_d‡øK×ÚEñ^×ðgÑŒó[$ÙPGI é°!ú”ªø¶èçà&mè¡íGëh÷¸»=ô	EíáR’Ð¾š+´<Öjõ<z1·ËÐPWDŒôÃ@¯µ®¶Õ…g@ZUñÐ?Èn†õ7ü3¡‘vE¡¼œ?^«*êîo´sñEÏ¯sÊˆŽ‚Þ—Â×}Yø’q4¯¯'³ñrþ%Ò@Ü-¬PÃbü¿TØKõÄÃ^*ö*¿A®üDÝáŸh’@ß)’¬ ­
÷ë–I*äÈ3w.¡Y¶žôb“°^,Ê£{óÁ½˜ñ¿ß‹½ß“ôbÎšÿ°›<ÉœŒ]¤_xÑ³DY<4óaW“7ù¶ªèqf²I^cä"¼ÃÇ¬ßc)÷¶­(4›Ûò†B})™)Y {
            throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
    }
    if (options.encoding)
        this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== 'number')
        this.open();
    // dispose on finish.
    this.once('finish', function () {
        if (this.autoClose) {
            this.close();
        }
    });
}
FsWriteStream.prototype.open = function () {
    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
        if (er) {
            if (this.autoClose && this.destroy) {
                this.destroy();
            }
            this.emit('error', er);
            return;
        }
        this.fd = fd;
        this.emit('open', fd);
    }.bind(this));
};
FsWriteStream.prototype._write = function (data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))
        return this.emit('error', new Error('Invalid data'));
    if (typeof this.fd !== 'number') {
        return this.once('open', function () {
            this._write(data, encoding, cb);
        });
    }
    var self = this; // tslint:disable-line no-this-assignment
    this._vol.write(this.fd, data, 0, data.length, this.pos, function (er, bytes) {
        if (er) {
            if (self.autoClose && self.destroy) {
                self.destroy();
            }
            return cb(er);
        }
        self.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined)
        this.pos += data.length;
};
FsWriteStream.prototype._writev = function (data, cb) {
    if (typeof this.fd !== 'number') {
        return this.once('open', function () {
            this._writev(data, cb);
        });
    }
    var self = this; // tslint:disable-line no-this-assignment
    var len = data.length;
    var chunks = new Array(len);
    var size = 0;
    for (var i = 0; i < len; i++) {
        var chunk = data[i].chunk;
        chunks[i] = chunk;
        size += chunk.length;
    }
    var buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function (er, bytes) {
        if (er) {
            if (self.destroy)
                self.destroy();
            return cb(er);
        }
        self.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined)
        this.pos += size;
};
FsWriteStream.prototype.close = function (cb) {
    var _this = this;
    var _a;
    if (cb)
        this.once('close', cb);
    if (this.closed || typeof this.fd !== 'number') {
        if (typeof this.fd !== 'number') {
            this.once('open', closeOnOpen);
            return;
        }
        return process_1.default.nextTick(function () { return _this.emit('close'); });
    }
    // Since Node 18, there is only a getter for '.closed'.
    // The first branch mimics other setters from Writable.
    // See https://github.com/nodejs/node/blob/v18.0.0/lib/internal/streams/writable.js#L766
    if (typeof ((_a = this._writableState) === null || _a === void 0 ? void 0 : _a.closed) === 'boolean') {
        this._writableState.closed = true;
    }
    else {
        this.closed = true;
    }
    this._vol.close(this.fd, function (er) {
        if (er)
            _this.emit('error', er);
        else
            _this.emit('close');
    });
    this.fd = null;
};
FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
// There is no shutdown() for files.
FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
// ---------------------------------------- FSWatcher
var FSWatcher = /** @class */ (function (_super) {
    __extends(FSWatcher, _super);
    function FSWatcher(vol) {
        var _this = _super.call(this) || this;
        _this._filename = '';
        _this._filenameEncoded = '';
        // _persistent: boolean = true;
        _this._recursive = false;
        _this._encoding = encoding_1.ENCODING_UTF8;
        // inode -> removers
        _this._listenerRemovers = new Map();
        _this._onParentChild = function (link) {
            if (link.getName() === _this._getName()) {
                _this._emit('rename');
            }
        };
        _this._emit = function (type) {
            _this.emit('change', type, _this._filenameEncoded);
        };
        _this._persist = function () {
            _this._timer = setTimeout(_this._persist, 1e6);
        };
        _this._vol = vol;
        return _this;
        // TODO: Emit "error" messages when watching.
        // this._handle.onchange = function(status, eventType, filename) {
        //     if (status < 0) {
        //         self._handle.close();
        //         const error = !filename ?
        //             errnoException(status, 'Error watching file for changes:') :
        //             errnoException(status, `Error watching file ${filename} for changes:`);
        //         error.filename = filename;
        //         self.emit('error', error);
        //     } else {
        //         self.emit('change', eventType, filename);
        //     }
        // };
    }
    FSWatcher.prototype._getName = function () {
        return this._steps[this._steps.length - 1];
    };
    FSWatcher.prototype.start = function (path, persistent, recursive, encoding) {
        var _this = this;
        if (persistent === void 0) { persistent = true; }
        if (recursive === void 0) { recursive = false; }
        if (encoding === void 0) { encoding = encoding_1.ENCODING_UTF8; }
        this._filename = pathToFilename(path);
        this._steps = filenameToSteps(this._filename);
        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
        // this._persistent = persistent;
        this._recursive = recursive;
        this._encoding = encoding;
        try {
            this._link = this._vol.getLinkOrThrow(this._filename, 'FSWatcher');
        }
        catch (err) {
            var error = new Error("watch ".concat(this._filename, " ").concat(err.code));
            error.code = err.code;
            error.errno = err.code;
            throw error;
        }
        var watchLinkNodeChanged = function (link) {
            var _a;
            var filepath = link.getPath();
            var node = link.getNode();
            var onNodeChange = function () { return _this.emit('change', 'change', relative(_this._filename, filepath)); };
            node.on('change', onNodeChange);
            var removers = (_a = _this._listenerRemovers.get(node.ino)) !== null && _a !== void 0 ? _a : [];
            removers.push(function () { return node.removeListener('change', onNodeChange); });
            _this._listenerRemovers.set(node.ino, removers);
        };
        var watchLinkChildrenChanged = function (link) {
            var _a;
            var node = link.getNode();
            // when a new link added
            var onLinkChildAdd = function (l) {
                _this.emit('change', 'rename', relative(_this._filename, l.getPath()));
                setTimeout(function () {
                    // 1. watch changes of the new link-node
                    watchLinkNodeChanged(l);
                    // 2. watch changes of the new link-node's children
                    watchLinkChildrenChanged(l);
                });
            };
            // when a new link deleted
            var onLinkChildDelete = function (l) {
                // remove the listeners of the children nodes
                var removeLinkNodeListeners = function (curLink) {
                    var ino = curLink.getNode().ino;
                    var removers = _this._listenerRemovers.get(ino);
                    if (removers) {
                        removers.forEach(function (r) { return r(); });
                        _this._listenerRemovers.delete(ino);
                    }
                    Object.values(curLink.children).forEach(function (childLink) {
                        if (childLink) {
                            removeLinkNodeListeners(childLink);
                        }
                    });
                };
                removeLinkNodeListeners(l);
                _this.emit('change', 'rename', relative(_this._filename, l.getPath()));
            };
            // children nodes changed
            Object.entries(link.children).forEach(function (_a) {
                var name = _a[0], childLink = _a[1];
                if (childLink && name !== '.' && name !== '..') {
                    watchLinkNodeChanged(childLink);
                }
            });
            // link children add/remove
            link.on('child:add', onLinkChildAdd);
            link.on('child:delete', onLinkChildDelete);
            var removers = (_a = _this._listenerRemovers.get(node.ino)) !== null && _a !== void 0 ? _a : [];
            removers.push(function () {
                link.removeListener('child:add', onLinkChildAdd);
                link.removeListener('child:delete', onLinkChildDelete);
            });
            if (recursive) {
                Object.entries(link.children).forEach(function (_a) {
                    var name = _a[0], childLink = _a[1];
                    if (childLink && name !== '.' && name !== '..') {
                        watchLinkChildrenChanged(childLink);
                    }
                });
            }
        };
        watchLinkNodeChanged(this._link);
        watchLinkChildrenChanged(this._link);
        var parent = this._link.parent;
        if (parent) {
            // parent.on('child:add', this._onParentChild);
            parent.setMaxListeners(parent.getMaxListeners() + 1);
            parent.on('child:delete', this._onParentChild);
        }
        if (persistent)
            this._persist();
    };
    FSWatcher.prototype.close = function () {
        clearTimeout(this._timer);
        this._listenerRemovers.forEach(function (removers) {
            removers.forEach(function (r) { return r(); });
        });
        this._listenerRemovers.clear();
        var parent = this._link.parent;
        if (parent) {
            // parent.removeListener('child:add', this._onParentChild);
            parent.removeListener('child:delete', this._onParentChild);
        }
    };
    return FSWatcher;
}(events_1.EventEmitter));
exports.FSWatcher = FSWatcher;
