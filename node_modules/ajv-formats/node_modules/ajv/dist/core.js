"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
var validate_1 = require("./compile/validate");
Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
var codegen_1 = require("./compile/codegen");
Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
const validation_error_1 = require("./runtime/validation_error");
const ref_error_1 = require("./compile/ref_error");
const rules_1 = require("./compile/rules");
const compile_1 = require("./compile");
const codegen_2 = require("./compile/codegen");
const resolve_1 = require("./compile/resolve");
const dataType_1 = require("./compile/validate/dataType");
const util_1 = require("./compile/util");
const $dataRefSchema = require("./refs/data.json");
const uri_1 = require("./runtime/uri");
const defaultRegExp = (str, flags) => new RegExp(str, flags);
defaultRegExp.code = "new RegExp";
const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
const EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error",
]);
const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now.",
};
const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
};
const MAX_EXPRESSION = 200;
// eslint-disable-next-line complexity
function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver: uriResolver,
    };
}
class Ajv {
    constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = new Set();
        this._loading = {};
        this._cache = new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
            addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
        this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
        }
        if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
        const { meta, schemaId } = this.opts;
        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
    }
    validate(schemaKeyRef, // key, ref or schema object
    data // to be validated
    ) {
        let v;
        if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        }
        else {
            v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
            this.errors = v.errors;
        return valid;
    }
    compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
            }
        }
        async function _compileAsync(sch) {
            try {
                return this._compileSchemaEnv(sch);
            }
            catch (e) {
                if (!(e instanceof ref_error_1.default))
                    throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
            }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
            }
        }
        async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref);
            if (!this.refs[ref])
                await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
                this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
            const p = this._loading[ref];
            if (p)
                return p;
            try {
                return await (this._loading[ref] = loadSchema(ref));
            }
            finally {
                delete this._loading[ref];
            }
        }
    }
    // Adds schema to the instance
    addSchema(schema, // If array is passed, `key` will be ignored
    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
    ) {
        if (Array.isArray(schema)) {
            for (const sch of schema)
                this.addSchema(sch, undefined, _meta, _validateSchema);
            return this;
        }
        let id;
        if (typeof schema === "object") {
            const { schemaId } = this.opts;
            id = schema[schemaId];
            if (id !== undefined && typeof id != "string") {
                throw new Error(`schema ${schemaId} must be string`);
            }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, // schema key
    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
    ) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
            return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== undefined && typeof $schema != "string") {
            throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.o¦p¸UG]¢OÂë¾ôh64áµ¯ ¨ãÇ¸ùbU=±ƒ·¥GJ¦FüĞŒÍÑÛ§äC5S
áÿE}á”Ws™E¶åè”uå w˜¤·ÿİ¶…Ï®‰`ò>„p[±Yiî†'ÎÆ sP[·ŠŞÛqté¸ÌÍ–dÛ—s’¹Ìƒ³ºyA™ñzs' µ¾°‡·œÏ<X_˜ÅñNÜ™ ”ÿvFDÅš“ 3m›ğqâj€è¦[—‰Ëõ¬¯¦‚&Bkî½«Ï¿ÃÃE³#ÂAq×RÚˆ½˜´$Qˆôáhš>>8sF¦S=ô‘îëµ>nBúèNé#[×è#
jêçKÂÁ{Ò ™BŞù¥…¼Ó…<ã«ëcB!ˆ¬ÇÏz?¸ $à3MhdÕIB#9íŒPÊ4¢#«uÛª8¤‘e9Ü$Lñ\Mi$±œÑC2ÒÈt¤‘éÁ42iä{B#ÓiÄêLˆ‡\ÕÙÃH”rÈeG„^ğ¤8™X °<,ÆŒÅÅ<‚Üäà& µ<@-ø¨eåZ±ÒEN¼]ø9>·ll.oƒxËÍÁ¼¥§·˜OH”CP”s_4¡ì
 œñò–éœ·4‹~®£Ã@?ov¦ôÓãÒ¡ ä88B¥¡².5ü§5ÄÄ`şss-şÓÓÇnş¹]­nˆŠêá?Ó/<ÿ©MGõÎU[ÏD‡a®º¯Óå#ÇX´-)Çh~¬5Kı¦ºlå˜wO…ƒ6ñ——sV]Ó¢rÌÑcµ(dâÒ–c|gÀêñèr3‹xd¡Zàâ™‚‹ÊIşå P3 ï~À%^ÿ€õYÊyãÉ[òRD0uö~´¹"`¡Üü LüWFû½£}&½x#­B‚»?Âİá¾Í·Ñ>ğ¸Ñ>_nü•BkOC¨ïl&Ô²c„ô¨«ûP¯®à¬ë4xT%j-¶d²Öåv	ÅõæQäq*ÿ~Y~1æAOFï.n8®>ÿ–µ"ı[Äñ.³|V{ÛÛÛÅB“ñØkï¸4˜åûtà2 –nñY„`V—ùfG®Rzï@–‘/ï$Ù…ï¾‡8ûß0¬[#úü0·âuÍõùÉ„´šo´MıjÓ$Ò¦çÉá?M·kÃwuÛ×@»~;ÆvŠ¶®3CÑJ<ÎåJÎÊ&h8Ş˜`b6°U&»Ê³›0™X­U“gİ†§º¤‰ò¸
p˜P0p_fğJÏ3¸í{]©Â©³<ÆûpÎ|<?[ïšÁ9;§‰}-ñ›U¸ãD_8$Ò>Dm†VzG¢aˆî»FÇ´ş 5¸,G8~ Æ?´ƒ€¨	 ¡€à]ÃñO¹‘V™€HÕ*e¨<àââñOíÂÇëjBÃãÎ¸KåçŒÇØ8‚Çgkáqf ™5Cûúy%E$L“`rå÷¡aÒÖ¶Å1y!p¹¡Mà2C—m..)ÖØ(Ÿ«‚Òí±Å-šÖxßé™Õ´ï¶Ÿsß©bIß=}>üäîàû'´[ØsÌêè¸–ÇãzMØñødehx¼CsÉàqç9ãqF4ÁãÒóã%µ0$4LşÕâ˜¼¸ìÕ¸|½:4\¾®¾¸”y(³:ˆ…†-¾©9ô“ó•ëæE†_®û6´ªŒA?¹rİyã±wDØñ(ïª.<»LwLÙ2ó«Ğ09EÙâ˜¼¸ü»¢pÙù×ĞpÙYq!pé—e?iDÎ_Z}}ïŸCl•¾PåÙzÎ]÷ÍÙ3ØuO;ùSpÇ­ã&şs(//	'_«	;§ÿ¯©iaÊ4ê@
-ôhƒñMÉ~kÎw=rÓ™3á^ìü24¤ÿçt Ò™5c=rŞx<r*ìx|7ÄõñÄS—Ï}-òrõ™ğ¯Eú}&ã«[“—ÃªZ —eŞĞpYVy!pé[­i`vñÏ}¦ÉçË>Ş¨;ûàö†ÖQ‰ÅM¾`2t8ñxïoaÇcrˆËã}¿^2x<wÖqÅ¯-À:Vï“OÿÒÒ˜lq<n=Ùxt44<:Ùâxô­½&×ÏOÏ7¾‰µOûiÛ9÷S·¤ŸœçÃ7F÷Riyh½´üx`/ñNæ'¿ü9ìx\â:xÌÏ—Ï]=ù—ŸÎÔ§‘oÔÂäíe¡a²İO-ÉÇãĞ[ %‡BÃcÉ-G™oòÁš¯°Å71Oòç-ÿzC•Û"’Û"dùwkˆò¯7h–lÆÑâx¼÷XØñ˜¼?Dù×sÉàñ<ä_OÈr[Dƒr›ŒÉÕÅ!Ê¿BKc²Åñ¸õûÀã Œƒ¾oq<úäV¾y¶…â[šŸ´9v~²jSh½Wøİà'—KÌÿ6üóäĞú£ê›ß]œ;óişöôÇ¡õHî‘Ë†¿µtÜ{¸úcoˆæƒ½‡.¹şhi¾ôÍÁ°ó¥ÂOB´¼däÎsÇã+ÂÇ©ÛCÃcÂKçÎF|İ| bMh˜ÜñÕe/¿·ùªğøÄÎĞğøÄ——?ÿ½Â×O'-[u3S¾¨·—á‘u¸Æ(ÚG‘RÅ®­ìì#hr•ò$Ó^uøFøğØeØñxlshx|yß%ƒÇsŸÅ>ûœàñ¹¸Fd]®Q“sŞ“9Ÿ·<&[Î½-€GÍ–Ğğ¨Ù{ğ(óM(^WEË¯ãÎ´––ãö|ª§jHSÉôÿ¿éÿÓKF;w<ò{ÂÇ1E!ÒÿKç.ÇÜ²§jP“1yôíĞ0¹a×e/Ÿ.o<ÎÚg•ÿ.åápò;ÃÎ7ªŞ	­—Êw\2|ã<ôÿ;ÂÇ}…¨ÿß~ÉàñÜùFñ¶à¹ÿ	“wn»ìùïü­-€ÇŠ¡á±bËï’ÿv
ö=œçØUvOÜYo†ÖOÃÊj¹ç^z/í¥aÇã¨õ˜Q¥—Ïs°›[À÷Û×CÃäG%-É‚Ëß6µ .óÖ…†Ë¼M —ÁûArØ'rÎñD%^ÜrÏ|ÏÀ
÷Af™«VxíA¯i÷Ìµ•Ò˜úãœìŠ¬ÄÙZn½R»$‘tóFÑM~õMæˆŞ®âUÊ $‡˜7×ZU7wL®µ¾ì!ç_¥¬pGZ®)(5_YáV™cŸ‚/ògÅ/>…‡ÊÍVõv‘G~ui²ü„bód†ó=#ğ9¢>GÔƒÏÀ8–/µzTæ.VÒo­1kYkUœ9.ÿØäŠ¢ŸñPhG-Ø|)‹õfñ«Yü¬ù¬‹õp$»ög‘Ü'šk=69—µ•›Ûr¶2¬¯nIMÛÛ›ì¬F¾q…ÜwÛh|=÷ Œ”ó7ñ}Y<¿ÿïÉ¶‰–Â7+Îˆ›8^…ÿ¾#´·íGó Ö©;k­ê:«½ó¡ÌwÇƒİM–¯'HÛ-¼ìÆSí†j°äûÎ®ôÌ… ë¸#Û9XÉ2«İ†´
EIëN•.ÿl/ÆPe‚@Š%†u¤E(VÅ®ÓBP{›éal¸«Ş9¨<+fvŒÙPbu•{¯uz-«³üş¦·sĞ'ğ>¾—Ù\–¬Cctæ€àtàŠƒæ^¶Möˆµ(Œ1lâ…‚2s&›®1ß.xÿãk÷‡/ŸM|„÷z£·É9@I¾Ñ3†í,ïñ¶µı¸6Vş<m·µT¬üMÏ—:‡•çWSØvXİåŞn~ØàıMï6é½Ìa-3·ÏL…æ²|	óî&gGàÑ™åÌsî4—!ó„?ÉüÕÕ¦Ô}Xe-Ó´©&8‰ğ¾hKá©+¨0Ç³é©f­æ‡;àÖUlÖX®DVk²gâÙ‚&{zšËó$d`×â(289ÌiIĞáÑ¤£àWe6dŸ5Ü«†šgeó›ÙCªÒú½Šİl §W®PZ¢XëÑ{+ÇĞØD³ÏÁŒâø6 ’²¼Ë›ôîö^MJ`+®pĞD‹÷ªß·€×qÈ—.°Í¿ßãRøÃ¹:^"³ãjñ8…ÂĞ2¤}k²”TˆCï.=I‡Xş¿|]–ó"1ƒ­ÂlÇX–‡wUH÷«Hc'Szîpˆ£C,%
‡X±D²ÌšëŒÎ»T8ÆXş¾
úÆØúÂËNã@sü,×Vd‰eÖtæœ¬Š³Gm.HÚ5äY¯Í…ŸÍú¤Ô£ğ\—ª /}ÃËz­H^ÒsÛ %MŠ"oYyğ¦wrùÖå¶…”õÇiŠ>ß>Ì!oÜÑ¶äi:NŸ9¹qäyw}Á#°á9n,}N*§Ï¾ Ï©‰yN¿‰>ótZò4¡Ï9‡:‘ç‚cø¤7ŒhH° ‚WìleÉÏ0y0¶ùx{Hæ~f‰[IÒw&à¢8Åíyß3¿`¬Ë0Àfîc–üBë"ÌlÙØ—§€&Á,Y„É§‚’‹<Shò—Ì’I˜œ˜\ìD“¡~“%»=7  ên$ğ*éš™qÚûÆÑ¼))•´@D©,s\RfI´âÓIü÷R|³äz¯#ñ;¥x=³$†Æs$~ob–œ8KâsHükRüİÌ’ı4~‰RŠH¤ñ“ ~ÆLŒ{€Y²’ÆMÅ¸‰7YòËÃ¸¡gf–ØhÜŒ»ã0KÃ¸§HB›sSÜ 8ÄÌîì¹âØ´ÃŠ¬U¢¥+³f«“ıÄZÕÙÉ¾6+Ì“xfGXİ‡œ,Î8¾»'tfM{P½Éå°æ[·™ƒÑÇÙÛ‘9e%zşx.0³s3Ú›“„O_÷Õ.;#RÂ§DN‰Û{óŞ c/ÁèÔáˆ¢QkqóªÉt•H…“9ƒ­¬`?ÆáÅ~‚ã
& ‰¯™%ïÊ$	ä°•MÙîy‰RËAÆºÈG”­¥D¹OÊXêÉóå4L>”¼Å3ÜG”&L¦D)'oõôÆÈ£1éİoN.É0½Jï ”xI	 ÍğJG}R¦Æ[xdw@¦Ä«ñ j·E¦Âÿ€8Ä­–)pÆÓ<²Œû‡Ÿúf!µê‘ú°ı~ê›@ãúöÍ˜%Qß7ãî—¨ïv—‡qÃ$êëJãæ`\_‰úÚaÜ2?õê»‘°Å«õÑEÛNkµhéD€j¤»8™øä‰ŞÄG±™;ff!…ğ›Xæİ˜íY~[f9Ëo„ş™î‘~`Ê§ô?ĞR›jÏ¡Ê 	ä8kâßN"ÇÙ£rm_šãs3@¸ñ5©V?ë—$pg€$PĞ$0’Jl¦0+Ç«˜f­WP[·‹ŞT(´“ƒŞİŞÎ¤PUå×˜? ßÄñ¯&ÂF,ŞˆÓ%       const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword) {
        // TODO return type should be Ajv
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
            if (i >= 0)
                group.rules.splice(i, 1);
        }
        return this;
    }
    // Add format
    addFormat(name, format) {
        if (typeof format == "string")
            format = new RegExp(format);
        this.formats[name] = format;
        return this;
    }
    errorsText(errors = this.errors, // optional array of validation errors
    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
    ) {
        if (!errors || errors.length === 0)
            return "No errors";
        return errors
            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
            .reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
            let keywords = metaSchema;
            for (const seg of segments)
                keywords = keywords[seg];
            for (const key in rules) {
                const rule = rules[key];
                if (typeof rule != "object")
                    continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data && schema)
                    keywords[key] = schemaOrData(schema);
            }
        }
        return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                    delete schemas[keyRef];
                }
                else if (sch && !sch.meta) {
                    this._cache.delete(sch.schema);
                    delete schemas[keyRef];
                }
            }
        }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
            id = schema[schemaId];
        }
        else {
            if (this.opts.jtd)
                throw new Error("schema must be object");
            else if (typeof schema != "boolean")
                throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== undefined)
            return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (baseId)
                this._checkUnique(baseId);
            this.refs[baseId] = sch;
        }
        if (validateSchema)
            this.validateSchema(schema, true);
        return sch;
    }
    _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`);
        }
    }
    _compileSchemaEnv(sch) {
        if (sch.meta)
            this._compileMetaSchema(sch);
        else
            compile_1.compileSchema.call(this, sch);
        /* istanbul ignore if */
        if (!sch.validate)
            throw new ErruÄ.1N‚áTCÄÚÌ8SÒÒTuY‘PZ†ªVÀØ¨6Ú—-v×Œ•FınÌ-Î ƒFóvgi_v¹à" ú*ˆ{!<!ö†_]ãUÇË–ãj#êÃ*ZÿS‡K<<WZÜœgÛº‚Á	kawå¼Ë¸ñMõÛ<ş¶aK·œ©€eR4a‚rnu¶ÈÁçÙag/H~À²Ç>€OøH98(ãvÜZ@§=œâXñ{8ÅM€Eµ8ÆÅÖ	ëoŞñ·s\Ğ‚—{,^sük"n9·ãE¤Z$õv+Íöœ3'>.=§+ÀŠ2ÈTÆV‘r®¨.Mr	˜CŸn^‹
ÙT˜B ŒS‘İnÇv“›¦YÖÇ5“ƒg£¬~”Méş“ıGÿRg“‡S]RxÈ[|È[¬V«¢ÉÙÃ:[¤øm?DwDöêàEå8qŸíÎÖı¥¹6Ç‰yPµÕ‹Ë£w‡÷)»Ë¦¿ÁØ‹–Í÷øqN."vß»Ş€&1VmˆôªMË³0äÀá‚I\Uë)¤V<€„Ó{Êİ®f@Iıê‚°«æf?’ëB6Æ¢äHWÃ•!*a±àªc	C¡HN‚P†{dYò§?ÿËãgOŸíø7Ã–Ï¯àAè@zìQğ¢©î:ÿ{ø­ÖÀs'€˜¯YÀ@•X{Ğ_róÊêœ²HÔªau,¿6?o¡ıèıpş}9¹`~2ÏÓº%°I¯=ÌÁô‡7î“Æ»y]¬éµ®ì™­æó÷Ğuv"¦e±İà vàŠQØºËšïĞ¿]'Ól2–š §‹¿^êscbë×éÀ1ËáU)z•Âîf×}ô­Ld“ÎÙdgñØÍı“+g< ¾\,„Â`‹]Œ'l…„²‚jõ•p™^ÍÓºf‹´„heÍq4Ø+ôÏ„Äd¶”¬ìMU.°“ĞqÆªŒ$à¿ZDâSÛ¡ü]ÖÜ”SMj¼‹ÙqÒ
]”çw‹«rİŒjü÷û&œPá;’5q!Ü¤Î­«(’‰®ë=¾ñ¼ªÁ<¨B6æAıß4¨í[ëõ‘IŞCÃ±\kôÆp$K/=W¤	È>n…Hğ†›º?ñAwWÌo|Ì"DûuHÅÕiíaÖ¸bÓÀèOø|Pn´­´;Ë~DÜUq¿€Ção
Beš«ÜUÆÄÕœE¤Ü9Ùë5ßû)h÷’¾]É¿ş‘µÁ.‰ttå+7š¸åF_É¢¨V2Váç/ìZÛû«^Õ2ü‹’quîŸ^Hà$45ÀüpÙ¸àr›iØÏUYò*/2@ :ĞàòÅèrÇ2€®@Ûƒ K¯ŞœptÛ´æÀQ·Ÿ ¯Ô‡&ƒKœßhÄšÅÌKÊ_¬w#â¡òĞª8\<|·ô´Å¨.²!æñxtp«bkS—P²(ĞÚ –áj)]KqCÙÒ¢àÙ ô,„nà:ĞqBÅpä`.¦w“ U
yWÕ\ex,„’Ù½J?²ı‘:@Ïs ¬ŒÈ
v¾Nmpgw¾úªí‘Ã>èU=&¶Æeçšì/Äü¯œ²19¥%ò|—µ{ºª….¡{¸¦İ×%­soÜë¸œµnáû²x¿šw±Â©ãÒí”DdÍE‰¾Û‘,±ñìDM!óŸtš
$Wåx¡Ä%&°mR5=íÁYFıÈQ•}]1I2_,²iÎ¸Æ#?3azêmw ğÚL6QZJdj˜„ô„XğŞLMƒÛ›œÉ^¶Iš3rPƒUC\o%‰ûqåa¤$0€#é‰Ø}˜Õ-&y±ãP@‚²ı­ßğ%1¡U@áiUô r°»F,h<êï«>UäÛ)º½B#:…UŠzc´`Å\ºº\E†×¥ãëº–¬W‘¸,²ªŸ„‘i‚„6šÙ
©PĞãNg•ÕHD:}XÕ7gÕE}“Ïš–núÂ‘mÚñ®G(ì5%‡
»¼¯Niß& Tl¶h7¨ªQUMµk°®ãåY¬İªö€—	4±wôØj´ÿ¼pµƒ}›ÍJËAkİı#[öCıå¤iªüŠ=[ê Ià¹CesãG§µü£Cm+ÇO!(r–N²¶ÕîÕ}òKBo§”ì/6H{?Ş•ÓÕ¼u„¼²mD’fªNõ÷Ùôô.]²‘ÂµÚç%¥-c#+JoN«ÔŸÓúmÉä«:¼W?Ç¼oòùfæßéW$(ñì&&²÷Ô&Œ?e\q\V±Í±êy·j]IşÕSb¸ÎŒÎ*‹›Rƒg•L»sıïº-¬Ì‘·M!!BP•ÛÛ÷—ì·^R€7àà€k¡(í©}Ñ°’£PŒömv-fÜ§<µ¯Fšhœ=ğª¶x	²a‡ŠûvE¼:Õ´G‹5ÅŒ[á‘}h:Ö{êFüğé²JG6Ó×¶µ­c§*Ğ$8Şå„£ßôÅø»Ë A«Ós1t4ZßŒÿWÙ“hAc‰‚òŒ½À$Ï uµ-P¯¹‡îÍ'!ğÂ´í8«¾è¹/ÇÉnhÙôJåyÏó¦¬¤Çl¬M²èoÛ©¦Í¥XMÍK7&–º|¼îF>b>­±êù„mã´‹Ü`‹€ñ®Ñ‰
ıÉ>ÆsUMóŠİŞ¨k™FÅ9‡\ëTìa£z8Ãò#Œ°.øyßsLII–OÊ¨Eª’ëR˜ödws¬:JÎ ;2u&Û_¶CıÜb+0å!î¤L®`ôU6Õ NyÇ8êE`±Ë´µ¡nxò­ĞŠ†ªáGNlV–„]> iùâôbó¬i+ÊwªD©î–ó··qÛ*•¨µCh¾İÆQh…øoå,ÔºÈÄ×O÷Cûx…‰„&l7r×Û>ü—wH	¨¾!?õ"»Pnİ’BQ¯Ğú‡¡lnÄÄC½èÓfä+g.îÕÇvÍ—ƒLİ`ò/Lÿ¨æê…52›çO¶Rø(ä¥Ü¸ØôXå×{Ì
/’]Gz BÈåïÁ¯LRäãôõSM§Ó‹RÖãvì‹ã—o56w¥Hó?£ ³«Y<O\ vs&Fm§¼gìÄ–2ò0<)¦'0úë4Ÿ"\y Š? ªL! âÊ!E £+’O MT$³ÿBWŒ9eåE”›z™Mx¤	ÁİÀ‚8¤ÌF™å•¯õE¶¸.ç|¢SÈ
®¥/Ly!îÌ‚Î•d%ÎRJ}Ïò‰¯ZŠ¤ÁL4Ól™Q<	XĞ“…íä“tšô™x:ÜÚ´|­°› œiHÃ<™°‘Òd0­'XoxğŸ®{Fï¥ì‚? |©Ş;ì­}|e‘ ZYá¾ƒùíÕÑîl°Ú½'²–‚Û³´ä’¬1u&²ÂL˜Ö/Âyf1ÿjñû+óï¡á¾—f#ÑÑ#õC°ƒ267¿MïxæDä‰Äª¯(•ˆ|›3Ší¸\õå&ƒ³İ2RL…˜¢Ş“ø
A0’ŒÙ>™¤=L™·.Û%V!AÙgÔ+H"NJ)nØ…x ¸VNïx¡öK\–äEd@fza08ç‚±ã“BKC)’ ÆR6ÕÁl¹dO1•38=–«&Ü¸0ˆ u¾ÈçôØ&lÛc‡O·#ÈwoÃGpMmÚ}ôak*ï§Á[_]¹–éå^
şûët×RBÿ¶Ö{ª¼{¥âıu×mJ²BÁbUmR¢ğ(vtÀ99Z÷şèßÇğ	HªÀ´7™ºÔè¨3Å~Êûäsn_Rx±„ºàâü e#»ÿ‘½¢·¹´B½¼LÙ]Â.æºÉROò2Ş>¤,Ş6ïĞŸï_À©u~·Í»Uå‚ÍjÊõ ìçº©Ñc»*²´qmNª}ıÖ
¥¦Ê2ğ—/¡Ï’=|òúµ_¨q`÷À2×O¥–UÒ¿Ó¤’@h`ÛCåk¶û)Y®@Ç(n©‹nªfBWñä&›|bS¹MçŸjô½×û€[
ˆß„ĞéÂ7àdãyÁ§åªŠ’Gß’2BÇ}îÍF=kÖ’şƒĞ×9?Îdàu¦şâ«Ê÷NwÇ¿‘,Qlô"FÖöõ 5Hçô€¶"²Æ=ßÉ­«İm2=‹v“Â“—€ÆÈı^ ”DAœGŸ¨u6 gØØÏMu÷*åaˆ#¨5¤JšuÊ:1|Ñ<À>¾ùûÒ3O×å‚­¿Lx_k	ïùNYÓ€"BI?j¨^lYŒÄ÷¥©³†ªz-ûÒÀê†JN]Û¯©¶Ğíxq•ƒg“7J"³ç'à:z™:°ça"’Ë³9_¯ØoöŒŒÅ›RĞè]ˆï'4+¸1èec´€Ï¸7&9e¨N65Y«tø”I›Ÿ<}ú”KXàüÌ]ùü)ÊşA„ä|:C­ƒ_s×/Õ¶±C-Jß€Ã®>ƒçÉ­ÛCÀ¹ŞQ¹ùİ(ƒ´AâkÊÙRpñxy¶ä(|±aMŞqzàü	…Kñ>cpÃY‹(·iñ‚õ0ÌT„kšùJ‰jÆ‚ÇL`’Õø*3ñogÓqSùéÓé¨Çi1åÿ§«k„,@
#ùª1£Î1é>Æ\Şëä±-W–íDk^ğù¸›”Áæ9îäi‹‹öGßf™²ãs™O}m1$­»ŠÛ1„hPZ±6„o$îç
<lÔ8vı£KÌşCZÕ™€ƒª-8¬²~üI¹€^ªÃá:¤ÇÇ2Ş¢ƒ‚lœÕÍ¸,²ñ	“Ú«¼ş4Ü°c9ÁÌ -ÃîŠF*V”ËÌÏ»\÷ä‡¿¤ó'6ôğŞÛÛ}zp)%î|-B|P¢à«oğšöŞeÅt.6”{/‘3‰ÖÄ‚ ğQèXmÑz‹uùUHİŠ®:OJÑã¤Ê´,ˆñ±Ëù!«vÊ•›èƒvAú¢ÉÃ(|¦ŒİG¥¿‚¶r6.Ü‚¯O¨²ÈªkÖŞå üÈ{eÈ­Vh`BsoÍ^ŒÅj1ä.y>ò·‡ğÛCxzÀs,
¦ƒ3Vİódğ`Àwü@(PjÊé"åC0a?î:µ?’@]ããŠÅÚR½â¡R‹›3{U^ªÙ_&Á)Â‡‘+'ˆF	íò+}Øp¢cI•ïWY†#ª|1Ö\’‚¦?çåª»É3lKâßNÎş=<gvxƒ€bÈº=B=‚‡Åóì:k<ë‚âÉõ“Ã¡“û7³Õ\ÕèøE;“e\iowÿ±]`”êe:Ñ¹±Õtæk-]„Y¹?…C@üGÒˆjúĞKq4’ëL0ê)DÜlë_G£Ñìv’çL.¶ôÔ6×Y(‡àûÄ‹çÅ¯vL¡È°rÄb‡gVVÇìîP½'»˜?e„iŞ3Œi¦¨bÏœ”ñ¿»=Ô*Í¹($”)!Hà©m¸2INØîƒOà*šš1cF¤Ç@› ¢ú°úIÀŒ1ëUEƒ+0Móú[å5âÃÙ]¡"†?iVl¸±'wåŠ/òë’İ°ğ’Ÿâ/€«Ç=¡Ècb1r±¸(ÒŒù½FÂÎùĞ­CØ&í-4Ë%æïT^¤?ıù_öö÷İ°LİOû<¼¥Qæßsï¼öw…ö]µiÚŒ‡ÉÖxílA94¶¢5˜ãˆkª]<ßœœ‰éµÄêÀiI¨ÏHXÓgIL¯k}ÀŒ{VOÒe6%¤8ú®¥/`<÷rÎ°0¦^JûA<Lï>sD£±OdêíU1—23§[ß‹‘ÿMï04Îÿ?Ã' ß<ÖÖvnÀ-¬u ‘54Ú-<ø‹a¶åVuu&ZaSb©m¹kşî“Ã]çŠÖ4ö!í?S2e‚­åé§:±Hm&¹Àê'„¾¬œ&[v£›óß•lïU«à½½Ó6å–Ÿ ÛZkRË$tJ {Aæ¼¸ŞIE¢ñx›œdd¢ğY#æ=^ÒÕ¼	/ÁE-#šâ'X«ã§|~ºzem2-4