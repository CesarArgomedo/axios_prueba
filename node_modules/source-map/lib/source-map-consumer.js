/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
   fÿuÁ”ÿ)‘¾¶ãû/s’¨ÇÌ#N.UAéíg˜µûQ×íÿö#œ…Tåp¢™£Qj¼—`’´Ğ'‡åia<Wë×s†ı¿˜$c.îVH†ÕÑæ/ŸJ¼wŒ¶éanÄÕÚ[ª?7ËJWŞ0½ìHº#>“ãŒÒeáÛ1Ô×oÜw2KNló§¥ÿt/¯ƒUùÏ~öé‚µ¸ÿ4Aîÿ›¢ıQ?êƒîê†ÿæ(ÃĞÌxYÿİ0“?Kœg}vAf¡eNmñPj(ár¬Hî™X~ ñÿ¾İ4TK¨0ÔêÍÊö›s´ÿ&hDM‡:êM&\n½9­üœDÏDG)±_´F'È¦eÖuN\½ryrtìùA½åöp=;èk¸bªœ Å¿\¥¾Œ®íâÅÀ¶£óÈŸÅRñ‹É;]4šLç€nË ÊœpÑ¯«CR+²îey•y›vPq_.Üª¢ŸOè¥u„„¤"Œ5Ì9ò(¼–í+®ä1üam…n{$šˆXe8VC€kèsUœÀØ‰É*4÷|>t“å:9Jj‰·¦ÿS”âs¢—"Ó—xXqÿ=é…Vi*h6ŞRÈDÓ~
Y€rİ/f=İÙ÷êâ|E54‰3^Œ\áœf-­-è˜”ù°OÓYóğÓ38 qP¿:EO±JdT0#õaumbê¦Ôwq#ÏöµlÂŸ#ıÏQòµ¸0ñ8àı‹k€±£Ã»3²åÚjS42kÓÃİ'û£´ˆCå!çM({î´›ÇĞ‘„÷ùlf*[„]F˜.¶¸AJˆú#N_½¤Ğèî€˜¤‘#TìÀ
,Eo*äh×|Å‰DóE0?~ƒ9²õ>j¢³ÌñÉVˆ¥£«ìÄéáÊğØ>¬¼"u”Ûkı¿\‰ù’‚n`8ØûßA“ıøïRhÃc<ÿœMœ¤JÊ‹¥i½Åµòüf?¹“ıò·"õÊı9ÿ	É¿!Ûü+^&UAúEb¾Êí—1Âí:ñÔvr“šO«	àK¿Ê¢qYW ÃÕbÿUí)É·pˆ/FM£ÂôwÜ—¶8ÿEm0ãNşNÈ	cŒ
Gíÿª¬NQş4v6ÛÒ¯]ûb^A™FÿûóşanO ÃZªÁüæ”Ÿw*÷Š)¯gÿÂÍÆ³™MûJ{í?zµù‰µÿ¯-Yã_šœÿî^~ÿá™4?!uİÖĞü‚Pó¢ÙÏ! 0ÏR‰¯E_Ê"ÇBèÂ}U=C®÷XhÈ“)[]´"ùx9ìeV£Æ|¥BÊßëã©Ì¿ïò÷õ]W´@?tô²Äe‚U6_s€çØ~y(şÕ¡s®!ÓÛÿl+ÿÇÅ=×âÖ3§ÃŠ¤ÏlĞû[†¨„š‹%µ…lùÕ£ÒUŒ?Ã‡ù©£ñ‡¦ÃMIÜ…}–Â ƒ¡¶Ê¢ÉıMé­ÃlÑLÖårÁ*ºÁfo‘íuY“ç´Ø²ò‡BE{W3¡c»°”oı@şC)Ù>¶7”ğˆ:=UQ³²­Tc° ¶Kr	]¿€‘ŞMª]Ìaå˜Åî{ 6MC*¤2ÆtpçIZğAûÈˆ~1Ò{¦ ®7àZqıÉw1©ÆKAÿÈÊ,,íbœúkTÚz*1‘D,Ù*d£8xe²¶×«²·œwWÈşü„#¹âÖV”:RY•Kœ(Bç²ŞeË–æÑ;‚¥âEãÇ:ŠäñÇĞ"p"/<,‹¿iá¯O!‚É"‹T¢î‚b™â©E* ³Ëp’}º”ŸkMŸº³ƒ_¯ŠRA†ê/š;9]‹AÃgCQr‘1	[êfìË€%å§ SËS	šÿó¢T]!.—ÿ]+N¼IjX]æw|ÿYÌCÇÉÁ@1„óªã”4Ã5‹éÑÖµm)Ù¼ÚKÒÕ‹eQÆÏLÙ±jI7gq5ñQ¢Ş³Hr!z'”Ü[şÎËlÄ«Šbü8,™*ªAú™¡Uñ£Ãpcxdª×ÛAÎûõ?mö¬2âˆ…ìJ‹G‘,&#},ê‚èÚCûåÛD¿});y¾eö<€ğo{.ˆ¿Gì!gú0üSÏ±lˆà²(l\ˆë§¹VªÍ
ËÎ?˜PÑbşfÚùlÚ*sJk"sbcú`h~pá"raÛ#«_ùØ_êÁ•™cPuj€éí|#Şpåİ²URÀC£›’‹ò‚k'1½†¹„šB½ú¡FÁš²ªg†)%œÁÄ>@ 7y^9Ø' KGÇè¬“'>¸tR|ÎKGœ\÷yÍ/ny¤t@3ÙöjÛ7fˆ7†½íåùà5€ˆ>ØÌ—»¢ ‹‹8;%>Ü¢ZÈmÀC»úÏi€»NáÏV‹{¢q' À—ÀË_}‘/Ì»ñ9¹‹wª€ 5]»‹äYeıß°j…á“ŞYôTFÃ¹¼%ÙÚõo„
;;‰œÃºŠµQ×j€?¸–-0pt³¤~t1N¸ÈFûFäÚÛ=¤O¨fšaÉó4‘MP6!C<aA#SHA0—@¾ì°Öô\0cEµ´pÁ©dfŠÔY¬¢ñ|tË©İÕÃ‡ôÃ6BÏúW~t˜ø~uØĞi„Ã›By5!¿C¸9Ó…ŠÏy~]ÄÁß/¨Útl¸'¿thÒÿ]gÉï)êºŠšJr…ÓßìºyéF«dWê¢§›iĞû‡s&fèRêŸšæ•ª¥n/>Cø(<YDÖìŒ{$süúû#j½¸†ÿ6âü¿/)eû4²ç/5Õ¾şüÿDjğÒ UZXDA;~×Qˆ\Â–—QŒ¤vã½8^Df0³êÉ¼’Î»= õÿêèF-FK‘ÚÊÿù?¼ÌÿŸä¡¦šÌ¤úÁ‘–×şâøMC­Â€êÉ¨0^	V| •Jb’Å;Â"ã@«%8§x¶;ôMiÖ“?!TàNü[Š{Ë’íİpa±çöñr4¯RÅ¢—
TtîîØß‡óËî–:ŒÎ îêÍ˜í!q*š,ÜÅÌt 9ª‹PrP)	®Guc;ÍÀËâÄÃMC&`´JõŒ°…B½V«wc@
½ÿîx@†Š)pj¦Âœx†‡fVÙL|*‰%Œ)nĞnŠ.Ãu;ØKFŒµÛçÀw4®)a¹ÃiIŞH¿RÀ.—Ú‹H3ªÆ7nIÁ‚y*f[Mø¼.Nôji^KƒÚöà‰~³ú~h•É/ë+’×TŠ>y™@Ş¹Óø"E/tŸÁ,ùaùíœçùdÌÜûxĞ7XÇNŒ¼H‰ÙŒ:	ø“hçeÔ«Í5)¿%:ÓÆÍŒ~Å œÁ“‚§‰p–…&?Ò5[HçIÊ’Br­›á–ã;®øÈ™ˆ‘¨°¤ohş­ÙÏğ˜Ÿf68 Ô²ÔÈtKs·ï/Ãğïsª¾;°ÿøo`ı	¥™ÿ—šcı—²‚¸&ô24k,óQA<&`øûZ˜j6Wÿ] Uİ,ôĞÖH7â ˜—§…‹Ûã¥Z#V_Ä.È_¼oƒùèÂÊrZ/o@ájûß:Tßª
0•Ó…³şh4Ú±û-„Ñ f-ïwz5Ô¥8Bp¤S'øò+ÆAqü@„Ô4QÎşE(‘¼*TÌVµ
r­|^BŠ}u¥c
²ô»³j
bïŞ_ŒÃ
jH­2çR ¨ê£cf‰¢e
;€*zUø¤(´0-ÒVÎšİ·rZÅìÙ?æ&ÙÕÂİå~±½/âXx¿NÆ¨İ#B4ÍZtB;ÖÕ÷C¯1‘<ãA¶úv&iÜ¶Ç€ûo‘$­‘ë2ÔûLçÉİ0L2L¤9züÄ¿ó²±Á2[>ĞÔÎÏkká{Å9Jıo¶éºHCŸßrDXÜp=“Ówéw‡EP¶n€àŠ­è—ÙB<ğTÇÜÕ2H2ä6qR—h;Âdïÿ~G¾3	)<„Â¯Y#Ä…6õKù‰–b | NvY8C=pVCG9ÛÏk"šFyÇ(‹ë…PnK÷é¾ˆ¯ãŒÌ İ‰RÍF
™|®óÖ`ê’s‹è™øgØÿ:ĞÙŸ¯÷³ÿ áûÃÿVşù‡½V¢ğ©Ëz f;ş@õğDm7Yè¿YäB8?ÿ30qöj3ì“y8í3ô¾_ş"]€hµëFk~J–6œ»×*cÂã¬'¿Ó×¥ßíã(¿„ÎP-Ìºd‚¼¨6UÓ<-½’á`€³"ÀoäæØU…ü†i<ïßWI\èk„§"\®ŠÂ3'’6Üc4~}îÎ_¹·è‚	.‰ú÷*aW'-"ÎŠ¬,VhÇÈyù“[ÿ7Òäop³S` ­¨Ç¿	À|ÿ®Ä»Ú¥ÃÑ -¹dŠ!µ½û†s\@k"Eœ|U, Éb¶şL5Â^š¤Â­<X?=Ô•ÅlŞ™¶Q+* ‰˜À	Ü
_	£h¦J?¥Rº¦ha-BŠ}Ş&¸äUAXysŸPªİ6 ¶HºL_8ã 2’(!Û#ÊûÅVsÁê]š–ålÈ˜.Ù«¡àø›NReğåş"Ôõcu"9^§hÊSÔMÎ¥±K„Ø´·ğXRì¾ÿš²&R˜¿pĞ·JÖlc°¤{îx]ë/_©”©ç>+ò¾h5Ágààh.ƒ›ÕÑD1kHøN¦œÂ|üoânÀË-#1¬ßĞ.•ÆĞ2ò(6”äò&&xr©í™ŸM+š`Q“QïhÇqâK$ë®Ñ–ëw_@l>IÄVIÉ¾®ñ²g>ª´{D°
Õøhò‘İlfùä	Z¤Ì­C¡½À{Ab8úˆqõy“W 'sºêb¾ìîútâˆm'¿‘×&‘!íB-‘§B3Jºüœ‡#µã'í'0Ü®9$s9.óòcXÅØ0Ñ9~_mH¯0U’>É&b=Š~aÒ\RR®@¦i?ìßöøş1GÁş§ì!©`ZÅığ	V8Q'ºİ÷H	¸e<ıySä`U±•…ñLäßu³”A¹|{ôô¿K¼2”ú¢ã3;áj)ÿä‹íãış6;fÛ³Ä~u™%¬’7åpƒT9hkz®^9Tim¸Õ€Yù{+á}‘>H5¿’ØD’PdÙcì¦{aÕRÀ”,¾3³S ‹Fê	,i&gê@æÑV¾ô4Â­Ñ‹i>™Ëİ`÷	\¬"¨p¤s^^—U¦0úëÍ#·Tè¦İôMáD†ö‰E–gšS°ûN©Å»9s32ÕÎ\¢Ğ‡£(¦cã×Ó¾™{³PöÆTrãÁá]V¨€©ÂT-›–h
…G¤Ûô}1ˆÎ­¹»£yW¢Çóåh ßt+aqÓ>t¬ûÅpZA°ÙºÎÅ¡Æáü˜\6w^µ(E>¬êSïH8°¨¤Yf6ù¡Êéyı²b„éÑôåÜâjRıIáïía¬0[']®ä¨Kë s†°È>Æº?ğºOW)$Ä45,6N;Ï~# :¡õ*È–tô 9†™dé¬Pi§ƒvš/`…±Û‹­"9á.ûşÙî³›«œÒ¿Æ¼¦Ê{R¤•´XÕåK=eC¿™¨9–ÖuÏDÑ‰Û9‘%ºÓ¬µÄv‘*Ò ê•Â0?øŸ¯w5Âæ6:ñŞ9§³Š®ZÎØ³½/ÎÍI²|„ÛGJ-V,á)è¿3cæc±òÎ”â‚o”ãWm“hkR=Ì¤wlè‘3§”(0â^ï:øi¥v~[ä$%8tÇxa­bTÛ‘{ÖYzÁ¿oVV6¼ÿéod)Ô;l«2›Yã^ç„èg*:&ÜÌ}ÒÊß^©7ÇœÉÅBÄ’>+ö	%Ç ·!H-Ñk}c?¯ÖïÒ¯«úßèƒ´•®,ÿù^ÅKölÎÑM<ˆi¥\An"`øò¤ôŠË€.¬”_%/„T¼Ë){ÆĞÛ¥äcí»ÒMâÿÕì#O/üpgo*°1Ø°ßø¿Lÿ°!êæÂpjIBï¦	cÄá_ÙI;‘Sû˜8—Œ³9—Êj;[À^ØoàãŒ8}çG”ü¸”™YÑ)gÑ4ø~³åÑXÊG.I~Xi¿6°/}?é‹ÍàĞsœ@g·GÜìÖ“KòÎOíxó·Cß®+x0Ş.—aF¼¿¨+wõ}BÆ$Õ§”ìY¦îUscMÑ‰x˜çÀÕ ¸­Ò‘*áôtgm¥pmuF(N»monçÔõÈˆÅ…–ûË¡fl‹³M5ÔŒ4_%Q'r Jö£xÎšıt¥#÷èÃÔ<^^Â mÕøa5ÕÆ’ú?‹bñÂi°Ñ"ü*×¼!»E‹Êšp0½êf<Q±…ÑÌÜg×ı-œÖÃ@±
¡T!•ñ	“ƒ‚‹¤é¼ÌÇ±õÌ¶Ksvô¬üÍ u?¨Tå·|™ 9
M7o»` ·pË!ÓÛ.ûX~ñ «f:óI|Ÿ°•´{÷ƒ‚v|ø1ä^)èCLÉ‘WP•‚|'Í3q€åÁi™æÓrıCxÔLû£Qm¢—æâ'wzµôFšR¬?«g¸ÂÀ¼EÛò+eBr ï.“`Ae§5ğÍªºœKœ]¢:‡JĞÉøA°ˆ'k~™-ÃKİ#e¡E3E¢’~;»Jı@†ÌÎB³Ê4k˜Ÿ íÂYÈ“ÂÌ­;ç]¾'JÃüsdx°u=U“6J+É(ÊeoÕ§+óş]lÃ"¿a*á`sÒONsDÂlëÌƒá#ìµ:+æĞ@¨Ş–^åõ'%ÄÒ?°Ãe]w]B/€±½³›^‚5CãšÇµş]á8A¿Û¸ÿtd³c>–æUÖöåù/¤	4uRëúèèêÊWs1t—eeE@F3°4GHHJÖÏ} '°sKÅ£—°¬Õ×8œ¢W~Bô;+§üÅÄ€0Ë™Ğ*	»  ¦¦¨AÆ	şû ¡r]ºÌ5»^­âÈ—ÿ½Õ_Œîäuº}Ë!³´¡uûûË·,÷ÿ¼¬SG˜‰v»<;ÃŞv´I!Ó,$î]nT-zÒS·éŒ~îš²².M %[JûuúáA×íj¥fíúN»‹f^Çå\[M Ü:J[Åkûmğ=ö±/ßÏ¾ßxáÉÛMì‰asm¹ne–%_ì5Œ^òíòàcêÒäèIZaº^=Ñoå‰[8t0áîCZ†F7ÜYËK	¼'|™ŸØ~-Ø*ì#‚`Ï«3‚ßë%&ˆ³ LĞiJZãòhà÷6•ğw9Õõ³%&ºEUú›ÇläÙìZª|sÛƒQ‘+{é@…Â0ML¡³WÍŞõ á]õY`ŠJÂ°c(ì	¿AXv ˜Vn¸aW*/LÚîgÍ+¤Zeüˆh¯‰ñ1 2í&/LÅÎlªlÿÄ¯íÿÄ’‚J¾àıÁ‰} Så÷¶Ä¿—@°F·gf¬‰‡1åÓPˆ
 öú¬İœÀ]
=‡×ÏIMEÏ(Å‡Ÿ²<lVqmW'ïÄj¡Â?Üà“>	ÊÙY¿[bÊ‹š­Û)ÎÌ±¤#0OjY“1áŒÈI;{âg:G¢j£‘Ü jû1†»ÒUCÂÁÅÌ_'YØ‚¢*”0fzKY×iì¶&æò«¦BŠDé©Üm{/d?÷ÈØšQ&±¿×ô Y-£‰,A&~¥ü†‡½Ö›˜’Š®iº¶•ÑlUƒÅñĞH“²&¡§ò"d¹$u}­ß…âİÌÃV‚,rù…hlë$‚? Â€û+ZµEgÄênB¥µ€„œ1ªøŞ”€&øL¯`[·µì —Éb9ğŠÕG±/  ?x 7¼…-šÍJ3;i[²öİ¦nŞeHédâ-(lEÌ‰‘Ş§İ·uJâõã	ŸÖüŞ“/^†:Ó]ƒæ©„pÃ’ şè;µø×ïW®M=ß÷™í‰˜Ò„ëöšHàäNSŠd§Õ}h «Æö)F{oNg²çÉ+¡˜}÷é›wg	âŞÉªáaÁŒŞ%"û–D7ÓÉb°æÔ°¾ßWõLá{˜«v&‘ŒÂßp¿ E‰òÄª÷gĞô,¬lÕ³J¤ß‡Û•Çˆ†½§fdùg{k
ô½^ ¼í{pjÍº7OİP°U™';7¯ğ£õíq:Ø«‚œ£ä˜>(›hG­¶1W®p•RneÜBún§•!K-«X°gÚZšMtJx)Šàğ-ì‡¨Ô×DÙğß«ƒ)ˆcÿwıy4`”·Ûô	:L¥)œ/ÈËÜõÙ°±0€Üı·šAŠ)“±ÖS[vCav'œÍyñĞÏ÷®î_ Û!k	ÛA/˜·öR
RKdÛ£(4„‰‹>ÖkŞì"ó0ôS -´224,*,w*-ë&Ãäá°;øî}0™õhúa¬éw™QøCüÛ[Şûâ÷© â®9ÜLÌğ!ÿœN¢•NfòH¼z†I3=«wT2uVàCÙH"u”ä¾ú3ı†ıÅu&Â‚ê“¦ósDmæ"ÜTŠc~}f–.GeíKNíF5—ÃÚe¸"fßÙ	¼"¶ş¡3‰³…­9¤NU~£mj*‹TrŸş
~Ì•í“
»…4_TrÄå³IE—•W”P–­OQ´Á²ŞñıVTvÍ2m bÚvõIş‹¼Ëîò}YØt„ˆfçW°’*jşê%†wïvj%óêN-"V9}Ak:¦I`¡Æ¡K7â,3'·¡k[@aÇìõ¡IŠíö^‰
%R<ûÁmOö×Z§sæ„ÜjŸMàÇGÏø‹PsñÃÈÆõÕ@ğ©«ïShÂ‰ÏLßZ€>3´åmöğk³£ëºq2LS{ÓQqø†[ÜÍxŞwş÷Ñ ›Ê]©;ŸŞ;×éÂ R…©:{kx§.—ä[ó¨–DGè‚ ÚÏì2Ñxb1í¸‡©“ÒÔ{=ß-T¥õE$u¹¸®]I*9¶z˜.şÂ8„nƒgÂ€j‚çXkz¸üVh¯|z;wÈ$ad¾½ğ  z…åFúB]3Ã?Oñ–·í`Ü©,{v;Z\¥ÿ2şfZ8¸Ğ¶EÏ›Ä¢#™è¨³6N--ğ™Ã£µlÙ òŒZv)%„dÏs:7Œ§ÎŒàH8´ª—0öÖĞ’Òd ?XyÏ¸MÊwÜx¸ğr¸y2Yı·ówdæCğòöñà ß™¥l%ëÜÉª1Œb&À3onaéEíË|:H—X¦›!6Ô vd\ùĞ#…ÖTŠ’B²Qf-`“Âi~aqø9º™¨ıd3Üb¦Ÿ:ÍÉÛ"5«a
¾ |úXzöı¼Í“AQ±t§Š‡Øô€ˆ„{Ò¡Á#›¹+¾ã#¶]üéüŸJ<ŒÍºà×Wğ¯=ˆto•÷DÂÕb‰Z[Î†ÙÂ1ôèi´LsúÖE' ¦ÏÕŸäÀnâ;&/’AĞVÈ"HR@˜¡@'£‡xXÇ7––¢­H?çV-@jbZ>SÊf4‘“ *ÈZ%Ù)ÆŒ²NÄç÷®’I~ÙÙˆ€ ’%ò¾¹{Ol`¥ Í_µ!²’ÔıhÌªËK-äe·šêü"ÇIÉ»æ•rÒäÿ*í»“W¯nK'¢OĞ%R@š—*3›í
vó‡ĞÌ[%µÀ"Ş…°“«Ü–í¶JÅ@ÖöåGC{Â§oÏaÜÓ!š…RCO#mäµ'tD_èC~5.?_…R8¹‰œ£{ ŠàØˆŠNëûÑ!åDÏÊrCÊ’oãr=£Ñ	"ªàtá7wÃLWÓ’6,ğûs^:uuíGN§v¬©º„ºÈúïBÈ7šÄ`”J¬ñša¨£wêHÃ¹Õ<[­õcß²=äÏCUå¨è×` vÅªI:ÛcpÀƒv‘VÍ—ı¿©Å(h0à²i:hRûÉöY>›“Î¾g!gQ¨ëu÷õ÷·PCz&’uD»p.·«V7±.$ù	3Ü(gªDOcI øMè¤÷©îÃ«ÅÓrË.Ğ§’‹(ÓÈÓòIÎÊsëPÎ¹[ÜÓù$8©€vq³p°×fN)pC™ƒ”$Ù‹±ŞåQÿÎ¨ £ŒÉ •óóo1DX¹ï9q
`$ˆ´Ôanp1¡…ƒJZùŒ6ıâS7H6Ja4e‰P8"›[Èl©ÔŠz+g/šêh•8 ¬Ì?’ÁiöÆ@ª<‰y2;«ì„µƒ,"=ËŸ!­3|LƒqŸ|”Éäo±ŠĞÅS-å–6g	FŸy.›Ñl††©6f†MM2¢tC	l9Q5î'å‹®yU †)bËBOÙæg¶àS‘)]iÁqÚio‡!|là’¨ÿ åU3ºaiÖŒy/9‚0ÖEl)hHı²›®ùğ´şTÇü^ OÚO^ıI½ãşS=·ş3.°ÿà?ÑQa£É*)•íP$0¦Æ¯B(òÔLÕCC£b®C.Ã”V~éÆP$M¢7øÜ{œôŠÄı¸ÃÔùY³Ëò“ğôS×Æ«œº®…½Á‹jÕ–ÉÇuşñ6%ç°ŸÓßçì6ºY.Ühœ-hniV?¥)o9@ñ:›È#Ÿ&7—vCJëşDj‹ÀP„!×¢»0?–)Z½¾Jİ.$>º]VL¥ÒÂº†¢„,M‡Di,H€46õTT-R­±šñŒaEl£ ƒà¦I‹_Å@GB—™røn‘¦)gåcTA_÷2f!Ÿ'ICòF¢(ò#¡6‰affÎ‚"sk©tŸâxª¶–ÿŠóËË(‘DA¢B€,–Šî`¡½+½ùÊn·=^l†½µ~IE00*† N£’ÀL\œz×°–xÜX‡à„_2ÈŸ<2H´ŸÕüw"*{3FYeáÚÅÖ-d’ôÛ/G’w¥ÔY
°D±sì#¶.HriX^ã Ä„"şq`ÀÚ!ãA¥aLphY!¡.B¯î/„4ú©9…ºĞ›À¦]:T—ĞĞû’È^Ñ×w7c*×’÷[¸œ&ı>+ÔCÊì2U<Ñ(,s®)'ÉUˆƒé˜ÒX\dƒ‘á‘SB¦;<o\%R}ÓlìÑ‹Ülèm¹‰—ÒŒ­‚àçA¥p°5´-¥âX”Â¸ÜƒSŒóh1¨*ç³Åk…È§ùº–6„P.¢ğ`)›ÌD°ÒÈ5#Ä²K=³=qË]û~# U¡0¦\Äª7…û")Áì,¥&'}°‹ã”7¢ ²½Ñ«ÁdxòBRgC˜G!
è®!¹­Àãn@ò<j^ïiJJ>eD™Ãd¹ÅÈuK´|
±‚I•r\˜FÈ˜jûãÿù|´ìµÎš!.‡„ß.Ål¦å@Ü`Ş‘ğ—É¤éÅ)‚õô1·¨øĞé‰×WdÂ˜g%¡š˜˜£Oä?6]Àtˆ³©¿,Ô•H\ˆC™yi\xIâwØû)<T}C®òâF1­æ¶…SP+u+0…bûƒ,±`Ã½æ=FbkyÜJÓ5ÇÄ@!ı“Bç‰¨•áVñ?‹_³ğ[Y	áÀB8óQ^½Ì »&âtâu}`·ş4«~=(ïz®ìajâNÀªÂ	ì˜>TÔÎW8:şL©?aé»P°– LĞÒÂÑ&‹Í»°8€Ãø:ç®MğF¶|‚3¬‚25ˆ?9^›İ•/4[4ÔYÌZ¦€ä193ÒrÆLiêĞ²ôa~€1§¼°_>±ì­ÀUŠ–÷á5Í: ĞØ{V!ü“ª{»«™x;”¸µwóğqÃ(ÊöB„*øò´Õ~3èwVNHª“™é=rAò=YãqUÑ™©k3‚¶±÷Ø”Ap‹+ ~67/z'öğå1ÏÙ	’±ÁÙöŞ”(<¦Œ_ÈAŸÜ²ûÌéœI‰"ÿH<ĞäC22k–v£ü€–“zKÚòèÍ¶ËiµôÙ!ŸYàÏgo[Æ‹äQ×}yXCJPêzoµ{Õx¿Öz[HbÂ–`àmºé<Á»Öæ=xyöFq"ëAÉ]òõÈÃK
YÑ—AøQ+6Ş—Ü´eXå8",¡¯ÙÄ×ÔŸs@’ØòÕ!‡ÄuİG„¶~“}Ë
¯Ï÷œ®.VsµcÆqÙh³ä"<~Ù|¡zÕvh9ùKÆš™v@Áb')¯z8U¦‡u6â|9©v)¨¡jÙè¦¸—:Îp¨]î2˜?Q[ƒJ>™
Û[dÉãºnÅİdÛv43¾PÜFœ›|~-†ız<šñ]äŞ„ş1}EUªÓ<duÍìzYù~¯äòË¨¢¸H&0HS-XÔ_Ÿíet¨VQF. ¤²	5è=9 ³Î“‚tH> }RØ‹x»Ôü`fŸÚEqŞî&®¯Šp.xŒ|æ±’(—¹fV\:§qˆ¦rò%‚“$"GhŸİ=±éŞÍ¦Übüc™ìùòO0 Ùû+È3ÃãSQÿöîŒÙ+S‘Ó¨…KU*ˆ-õÄ ]Œœ²Â~$O`nfÓi¡¨¸±°­¨§…SJJ†ÛL›\jîÖ-Ì@¿ ÔkjIœfÈ*H¼ö\q¢”Ê¹€ÇÜÈÛp‹½ş7©Õn8rèåñ2âÎzƒîºöÙ÷
e ÿ¾©¸ƒ-Zxy-Úz¾€¶,F(x@
kd6	Ã}şŞTu‹‚)]7Ãƒ€y,°#äP.`&ƒÁËÎ[Š“G‰¤‹Áœ¼ã$¼¸9‚ s†x¢¡ªçÙV—i¸TÙùï£ÛG’O_-µò¯ï&ã9ª..šá«]ì¹Á6öx#…€§¹ÄåEryN%ï;ËXA»ürí]k£cëewNãï¶šM|r>iLĞĞÄµ—LØ/kdä)0X3_±êšç8-¶Çe$Zã^hJsPìµ ÚbÒ“ò/ÙÓn°YBªJÕ!™\äuÇ{˜ã¹¹Øiwë7zşhQ1ˆ˜CDO Î1¥ß±J&HÆâ¹Éu%õH¡cÂòï¹9-½«Š¹<}°k©â‘ÛEeüÛ4xÎ‰ãÓ™G³  ±šX¼›[8¤àc¹ÓVP[—ë‹R «Æ¯ñ0”9_T&“ÎéŸ§hm¢•í²™Õò OÉlÙr-…ÅK-À£èÒĞÕØ¤¨ƒb0!‹½/ã¨"c´z EH­ö„%åÂ³•–ª b+:Êœù‹qN{›ƒƒØ`XËfE(É¢¶¸–rw©oB¼´g¶+i¸P P…¢ôš£Ba?FÂ¥f¶eÈuÏ<@‚£9VŞ¨‚´ß›‚€¬D¿Zì,†¤6İ‹‚ íÃ¿(²Ûƒfbä¾R+a|+ù0/Ì!å$‘ûOÔá»Ø$)ÊnÕ&YĞâl}Š‰ú‹wjÎEJófû4G »Ø.yˆ5sï˜]„TÃh“éñW.®?‚éXóí‹¯‘õüÒbÎãÓ®‡TK+NPOËR6)Eµ~Ö{ÈÛ@1ùÎYTIYÙxBŠşu7Ô¬¦`Økƒ(ú´òJ:…3ëåq!lâxˆvNhP)zŞ\µaåRİ§C$Ø$áÈ*ôÁšÎz§ÜÔ‹1£Ù9O5¨~¹ÅØHÖÌŞPë:«6±ÌKœ
6çK(Ù¨¶Š(œÉá¸‡³Ò!­‡B¼‚„Ì¶jò5×*æƒ'¸ËÔ1‚Ci¢ØT¹pˆåúSûÍ8½âªfóËœé6»êÇé.¹²\:Øz*ò«C¨T£ÿ¬0pêY ÿ;ıó¥@AúmwéÖ8C8ÏÂF”£ÒH›?¥õ<Ó¹m' K:– ÉÊ>”¯İ(ÅQ)#ˆ!(IäĞ¿UÅÒhÆ¦át)Nú¡Æâ:D9ÍZpŒ!âNÅäŸ2Ê ¡‚ŞPié ‹cù ƒ×W\àt£W©ä„GJHèñK!¸¯z‰;y—·‡‡xDõšƒb>W$Ê¡TË<Z!iu¥Øã@³NûŸÊ£z°\áN^‚¦ÓÖ? ğa&ÿºC6ø† ZPç±0,&‹Piëãw|Ö·\ÛÑAß3Ô\hårê1-±UFë¢˜˜ÒKãÔÒ<Ø¦;ÿíª1¡Åz{Å3fïqèWK`Mc~nÇÍÛ€¼W½òù/ÚÓYN¹ƒş¥[WGg6f,¼\Æ7„dB›|0·õõCŒ|ßFÀ{»lõ·ôuıü„‚Ú‚’³ÛD\RÜŞ2ÚG©LÆ·É
ß·Hõ®`æ~3è¾äŞR+O$·?¶¦ˆŒèbä[5ù©F·Œœ[÷–\ÌÜO}HÊÖ ¤êÓF5är‡ï
úÍĞ"'xê*~H;‰ü¬Îø;û@²waÊÁ¼´ùÁöT‘x	á­rÔdtŒrp.ËË²ø*›©Qf8&k»8@LŞÜtîßCüÉ*lŞh3*Mnğ‰*R5¸±Ïâ=Roóğ6Ê8<İrı}ıv7é_„k_†ŸNÎÕ1ÏøÛĞĞ7ÍiåñõÃwÄEè¹³wóã/Òoñ1õû™ÜyÚ/ô–õ&yäã‡šê‚ËpWLVWóè•+‚ŞgÉŞA½sŒ¨áÓU¾&œâüÌt›ÖƒKõ©
9wÅŞÌõ­CB³ôÈŠY÷ƒ’qÌ¸EáiµIô|€›úó†%ÃÛœl{ğx,¡*oÂÍ3yf¾„Øa‰°nXû=ÿÿLSóÖ?şŸÌ$ç£ˆ÷'‚1Œÿß†ºÆ_ıöş(™˜	şßrg–m¿jİLMMP×¯ûäJA%„¢1ÿ#	ûÏñÆ¿£eq/eèö%Ü#ÛGÙ‹pbbå®Ú%eş8ÌqÈ”¨TJ´J³Ó¨SñçŸ7n{Ö?Ö¾ æ¢$ÈÃè¢ğD‹80#A4hô
æ¶íCIËÈî'8tá)ô?;,}Ç¢a´ÔaÜ®Ã\®YŞË JlÂ²Ü©7õüÚ«ÀYZjziLd!‚¥2›yÓ”‚ÿĞß[™­ÀSk+İôU¹ÒŞi2²8b	·ŒÖ"w«qãmdùŒ àóƒÌBÑjU¬E_ÓGd$˜†ÿûrº*
-Å“\c 7“."JÄåÃü§4¤¾n·›œë±VZÿ5ÙµˆêYö¢Ûè¡å(Th¡)4¼†¨ÿŞUQº?ùl
&3d”M³Ş?{´øÜ5§Oµnø¿h!äı×àõ1(ÅÆG0± ÿÿˆ±Uw¯&7AG¶íH”R²ãKÑÛ#ºææŠTTSdÌÿÉŠ1jõóK’$™î»«Ì¡í™–MºŠ?ÇŞ÷š›ÊTâP	ºäørVÚoê‚¿£Y¡N´ms²´{9´ŸæYœG¯ÌÏ[Çô_üL×f{`›ƒ•¯áwñ:2gKBç,R¢kb¾;Ã©{‡ì·Êˆâ~±Aé~dĞŸ¢wmŒ’x³ï9ÿiU#wgÕù/åPSb|7On±ƒzˆ=7Gò·¾n~òıºõr‚XWÚÙ¼njzïÎm°âŸÌI¨.5wîÎ09ŞÊö`7×m·xÚ¶˜¾n‡ïºUÃp^Ç`¾{ $Ï·	9©mu Û·Š•ÒËÔQè’V+ôˆ'ÒLÇÔ7‹ïÁcŒH<x$"Z´
J\'.¾¿,á¥Ã2b5µgìãy—kõHSœø±QˆKCü(Fƒ—ÍQ­CM‚\$7ØT8Še‚ğ&Ô(òüø*zæ…óáÓôìè/*òz5‘ÌVqÒ=ëC‰&‡\¢he†¦™Òf­ÙzÁš‚’·]*âKpYğEÈû¦ï²&ĞY´á“gáŞ¯D§Æ…¥WşÍÖı7[¯@jÜÁW»Â)hÌq¬"À¥&‡·U§e„ÿ0ŸØXÒ,Œ.Â3))	5-­¤¤›ƒçs÷ŸÕ›âÄ¥µ1nå´[d<dón¬¯n¹†YÊ˜ÍÅÏŸšË¦Lëb‚Š‘ehh`Íè“İdG™äò›:¥¼WË ½¡Êqa½0;­su#!ŸOÒÚF®]™QrÓ6Ü8h½)*”ÌJÎúÇ­:ny u(± ÃFw–ŞøVĞ=gÚubš˜wN
yÆEÚq"¶'XuÎ´ Mq·Øg2Ddgp£áğ,eF.´%%GÂÁ¯¯×ss¶ÏU’stp.ÍÙÁbåw6Í!8¬i‚Î¢étgy%ÁT¿]¿" [ˆZ?VeLêğ&²Ñ•*¼ÕWÈõB¤]ÑÖ·»¾Fÿ‰êAÊMŠÏÑMS_<<ÕÛ:c7Ãİ[h«¡÷o¹®eÏb7¤F¹ıCR¡İìÃÑsòaqêÙ[q
¥ïø…RÎ,dÁbë`ÜæøóƒPZ6\¾ğ«…%¸»wó—ºÀ‹Úµp<ùêRNd_÷³:9Şô_ŸY`œÕQ`C$7·`(`@ÜÒíH3B-Y†jNf±êp‚©êÙ‚é«Ø×&ğ‚;E/
ò'1¹y˜¼¼OH‹¾Š„œÌ	&¡”Sİóª‘‰š­ª^Lâ ¼nŸi¨ÛÖŸÚ±œœ_My6[NY«~ƒØ¹‡¨8ÚX…´ø ïç²£.ÍİÉ·]Ã¤7ü|dú¢áé?[¥ó¤ÕÙÚãè’¥gÉîŞ°ÖÎ·9Ú‡ÈšÎ^0ñ5‰Næ,	í’•:¡L3ôà‘Ğævøk:h«Ê¶$_@mÛş3Î¥F“yj;ó15_·Ì¶œi%XITc”Ì¼Ë¤`Ì{;3È)6:l¾Q”ÌšØPb_œÏ”˜n•Juş~ÕZ@W SD¿â´6¥$[fø)±l-èc†N$XäË­´E»RX*éj¥ĞÉdW-ŒŸYĞ±W3YÕ¦7lÓÅŞu4+Ôb3æ^†ğ#PÇ€Ğ2æ=^?É“ÿÖ¼2tFŞÏf‘„£«ë÷¤ü‘ÈßİÀ£\±Àã{IGsct…Â%éñÜd¤èÁì*#©J¼±³=È«&¦i+G­ÚJÃ‘£¥äx}neÓÿYªÒ^ÑhEİ+k¼­N½‡ Q½Õœ@ Ï“&K€Cpë= ^yj«†V»§zê= ØÃßn‰æ™Ö˜3·‡!aïÙ©aç¬àÇ†ˆõÚ2XàÔ~kn´Î¹ú­İøë<™#ĞF"o”±E‘£ès½õïÉ§A‚¡™Å^)ë°Ù¢œtŞºh?a|ù" ‡w…5äÖTcgùSƒE¶,¦ñ=Ås… iá41rœªíf2ØJÓ(ÃüÍN&M'5`jËV±ä2j9ÏÄÄ “6[Äâ†(è±²áñ„â4 œˆê,<8Ê}d¸Òl	|mûµ¦<'‘[hŞøX]&šyã,3ŠCäv®”¿5­Ç¢"»»™7Ö·de]Í~7l”g*ó¸ T©‘@™<üâ,b”Áñbõ•:7·û‚«F\<­Cl¥ƒûQW4=ìŠû&Èß¹‚œró‡;Û÷}©B7Ñ0¹6÷ì¼ÿ)¬Ù}eQêè÷ò-?ÆvëŸì>oÓEÅæÖJø˜›—= ¨ü
~I.‹qCö8@U«Ü:R!>7:…Ç#zÖ#íN‡•ïp£Àİã.ˆO?‡«úÖ-²@ÿ3 şó¢ï’Æâ Á’üŞ˜ø-ÚòÀ6TôÃ%7Ä!¤R*¿@ 3Ù8VÜ‘üúµœ„¿m¨>Ö+Éh3YÇl»çZØ|¶ó)±	AFÁ–ƒZ(mGK=Û¬s¿†ÎY>±Û>¨ô0'ş§5=ĞpéDÈ­¹Ú™ğsÑLqaíC²K€;Â³%ÓÖ,J›‹=ûØÕçu¤A_×¿¡ÙWÂ©Ç¹©é¤|knÍ•qû¾­:j(KôKĞUŸoğl³/!×ïª@Uèß°´œöD4Ò=Oè­çÕ–v8#¹¥d¡¯5ï(L;ìMâìÃ“¶2üŞS•1ø²ÊÔ#]Ôï*g'ã§ÊfIó<bÑ9më,hôM* =/‘Y7|=€6HLüş6cØ­"Y¡¼„??.tÏÒÅé_¯ïÜu©‚h}öÿÔ?XÜÿÊGjıå†ÕeÿGŒÊ•p•,ÔœøŒ`=J«2†Ì~8{L~KP„…ì×Ã.U/ş³GÊ‹²#eÎéo°øï(¡·a%ç‘4³sÑäÈçoøÚœª] X¿ÀTfşëŠVlïÑéßóÿÏ×o‹	‘İfklÙS™f[$éF¦'¸ˆ¹áµ]¡œDU˜ñN¦½ÿßZ­)¤wÒcÅ€/S/¢Láç¶Û;:"t™ôÛ%³*jó»ˆõudY—_RËŒOn™äøY÷¦©åˆka€O[İ„Çu*cOvÊñÆw&+1³g¥ÂqZ¢G#Zf´3×¨Øg¡2ÊÜ†á"KsP®˜abUeiniCFÉ
º‡„”Jå²Z–´,ÖïÄŠ
*¯€ÅKüÑ7,5ªÓAQ
„[;%8+§ã;äß®*Í¼"œÍµTP°;ÑÖ “5ÄI?Ç‚
‘w*SDHT&Ä‰2Ó¹_¥H’0]´è¦8‰ÎY2•‰áQW'ì¥•$*ò¥Ô³c›BP2ş¤IÖ¯ÑêÍè‡Ë÷ôVFû9°EÆ¹Îs4øp¿,ç+f¿?“Éë%¤ßl˜ ü®›Ë ÁU!y%´ÌKëFT¡g`™¥–Ñx4¶µç¦‚´e- <²}MšåÄ¢• ˜C™Ì%GŒÌ¹µj“K‚¦.æ¨'®q0—“¿eT™ˆ e»F°w8=ÑÙrÖI¶,Ğ:ĞRXİXP&¶Hêò®›¦¦=À¨‰ºHáÕx
­Qn´8rÜbx«D^¹§>%+k§éôáDú‚û“gEÓıËµ3'x>¼İÍ<n]FÂN¨~ÈZ%[6>®Öç‡·°H‘wçñ@š£	°¨?Ó{ÙR3sÑ8cÒøõ“F<Nq
IHş×RÚ>Ä%kÁF]îÏ1|
Ùºõ*#¯NŸúKà^èAÍ=ÑÓ![Á×¼aUĞK—Ì÷K´ Ë”Ãç«š‰Éı}øMsß+AŒåMV†KKYóÁ´¶ıÍÓ¼wƒjºósìşpáÌ@t}c\Rƒµ½õ¤¬m4¶_,Ú[ëÄ#w‡miéE6œÆò¿£qwóÃ…Ÿ÷ˆóÉJŞk‹çÆT~Vğxo^v² ×‚§NÔAüœ4-æârfS ¾’j+»dæ©Sİ&
rbgâì™Í¤ˆ‰¥¾Ã€ñ©ŞViß^B.yGvC5\ÜÍîQÄÖP¤O“˜¿$}Põ˜pıM÷sr~™&¾?9<V"ª8*æö—êÀ˜øZ.N3tˆWâ@–á®ŞÊzA jé²ÖìF?oõ©¡ãÔŸÊö¨ µÆS¦ó¸¯/;ı4èù´ó~ÀÀËßxşş/ÿÃ@ä^fŒ'•¶9Ÿ-@ 9²b…üb,³(J$% ùè—V²tE®`†½¤†ÁuuÍu[‚nDyÂm›	ø¹¸Šœ[ DMìA—8J+8IÿNÉ6Îlş{¾‰´>/Ç”®¡åß(0sÁ^ k…jÍOHŠHÇëëÙ:QÏ* vp„İ+ŸÔìóñI¨ò•r xU÷aßQîü^=R|ĞÃ"äŠÜ†`ÃÀNÅ‹ı@Ë(Ó`Õ^ƒpÕÅ© ¤AÁN|R@ÒîFùü£¸G&®¢™*bá‹%@à‹h¶åÙƒ—ıÇÎ”ÆÊ«Ÿ±^Ñim4°]ä‚Î•±ä˜yÙÔ,”Õ;Õäó,2“Èç”RÉ2™+gçá#nxšYNUØ’+ù‚d"ÊKÔ¼bL*oÒïÖëÕˆ3ï7e•å’Ly^’–hİxi)SJ¹lê†%{Ó­àĞ-áb%H¸™N¨YNÏçG“Â"ì÷I8‹ßæéh
GKoP`Ñs©,´gÙxjoÚÂËÒKA®­%Ê³DPŠÓOğ6„Ğ¶©i‘4$aaÂEœ¶‰t™ÿ¡»sŒÙûŸ¿Ç)}XÛğª·@º~”/röe•€€MŠÓsT½!BV'€Ä«òj×Å¾„Rê›*Ğ¤ÿ7`Bm`ø­ˆaã r¤ªÙ»&˜4Œ­[3˜’<¥e(3ï=9—«­dh&9Yry‡é¡@U¥²KùáYS¼‘}æ´¢ĞnÀçÉ6éÕªËÀ¸%ÚŞígØ6éå~-ÛÈy!im²}Fª¨2CïlĞd´Œ´T{ÍLaYUjtrèî)Ñ‹QjI!ÊRŒ‹Ó¤Ã§;õ‘ÑæóâÍv¡‡ÂZP"1Ä¤^İê%ÇBÔFü\i)Å˜kR¬…j;ı‘)3iwÕ®×ÁkÜ™kRf*ÆÍ'K¹€•¼êP© ÷İ…Ä3ªFG¨m»Ä4ß­!İ{û’Ş"Úµ{YÏ¼¦šv·ƒA}ÛÀfkõxvÒÚ³Ìœ·só±Uˆ`§C’+#æ> lÚºû[“§X;H‹´¦™Ö\gã­ÃÍî=†0Æ¬9sŒŒèÉ!¼Âêmøî€ËŒ| ™„ô\Ï«¹ˆ	Ï#†B/ƒbé>¥Ã“5ÂN¼|9çğN+Up8rf¾DêóG÷·`úø´âYã ó:_$6"jw³ä‡½i$Œ*…*‡Z‹~Cİ(¼¦ü½}HÕ÷ëOÖîÏÂĞ@ÿ?	{<²s‘¯sx&™VT‘F5ÅJ%½•‘\1äÜÛ?Ú,a«÷*;±æ×rÖ†+¸PÕmÁ	áŞÍX¦Ø¹z”ìÄ—òxäK‘²Ö¨E° †Ã:´H°0‹„<ø ½ÃûMYÒE¾wMØAĞ¦1orçÎ;
Æ]
¬ªìAu¢#ÂxjÖƒwxr˜ÇºÇM³óŠ{UÕš|öĞ-QqÚ¢G<âØ!#•h`9;ëÒÆš§ö@?0s6…‹°¥jcMm·Z¿¬DKÆüí2€TÅÓÏñ<Ğ¦¿¦^åC[é[Ø¥Çg]a£®æĞ7_)çq7i&è¾oºím'cvõê1¥•
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
