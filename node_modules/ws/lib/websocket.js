/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Readable$" }] */

'use strict';

const EventEmitter = require('events');
const https = require('https');
const http = require('http');
const net = require('net');
const tls = require('tls');
const { randomBytes, createHash } = require('crypto');
const { Readable } = require('stream');
const { URL } = require('url');

const PerMessageDeflate = require('./permessage-deflate');
const Receiver = require('./receiver');
const Sender = require('./sender');
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = require('./constants');
const {
  EventTarget: { addEventListener, removeEventListener }
} = require('./event-target');
const { format, parse } = require('./extension');
const { toBuffer } = require('./buffer-util');

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    this._sender = new Sender(socket, this._extensions, options.generateMask);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }

    websocket._url = address;
  }

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._ori665DB591F3BA1ED01C882376699A3B2cmpB79FD0F5C5C0B1480768EF34D659B1FD{C9220201-5D68-5BF0-BEA8-A40143DBC184}fil8EF0A4D71601988CD30DE054257E0F4Bcmp1752BE65A75FD3DD6A76645B3A1E0A40{202E2033-BEC5-5B1E-B7C7-BDBCDA3819D9}fil41DD292914224B29F4B071CD1F1EC255cmp5610C5B3573447B693B8678FBFA34018{0699E30A-7F58-56C3-B77E-6378978B613E}filA1FFE1261D61640128D8E9792026459Bcmp9AEB5ACFA8C620CA1E212EB4D3ADE40B{E8346C0D-7C58-5B2E-AEAB-167DEE288332}fil7E65D1A4086A9000E59D84E1218D2B48cmp6FA298F8E696BC8BF2C3C449BB81B549{9B205897-090C-5784-A9F4-80F13597537B}filB16F14D8AEAB2D6777E0E6838984C179cmpA50C1FE522445EC721CAB04132E6EFD7{2F1C66E1-0827-5DDB-AE42-91A690C713E1}filF83755CE1439A995D339DAA0DE61618Dcmp26691A85F5BFBFFC443B71F6AA69020B{1091CB73-D8B5-5CF1-B388-B60502DD9201}fil82E80E40AD3DA7C1C6167F98E89410B5cmpCE8BA023B7D696648D34C940706F0F92{7B09766F-B3EF-55D7-B9E8-3FD8FFA14AA2}fil889E38076B8DC956C8150B541ECF902Fcmp69E0DADC638BC5977381A3A75BAC43B0{FA593CB2-C8EA-51C5-B4F3-C43B4FA66567}fil362F18AD29DF420E30D78167FE6ADBD7cmp1D7E99456F830532AD8477EE996C135E{1BC57D32-473D-5ABD-89A5-C15CB3BC4DE5}fil4C3E80B6EC7168F421EC9B4EC8D340D1cmp6538C4070299BEB822C9CB8E9AA7F562{767FEEAA-F7F9-522E-A43D-B6EF33EA3CC3}fil4D3427013375BDBAF24CEDCE6439C492cmpB37F8CDBEBFC6B3C73BDC87957E08AC7{7D023FF9-D255-58FB-A7CA-25F1E9C6B745}filD82F3470831791E7227E191A461B4F65cmpE3D69F22E5D553496D82BFEF790EDD37{CBBC2277-D085-5BC3-8EC7-ACB270859655}fil0F7ADD0CCA3D095BA4F85B1E25A38008cmp05A336D05D8066C449305013CFDCB2D8{2680331D-BC6A-586A-A936-AEA2E23F601F}fil2E9800C088C67028D8449BC75621A768cmp0AF5F344E4822D7D8B86933586B641DC{72DEF098-527E-58C7-ADC1-2E380FCE89BD}filA847CBA3DD142254780B4F125F84B7D4cmp8DE5B7A359913C59F2AEB846603E21ED{501CED20-436A-569D-BA01-CE5D9047EFD9}filDFCB002674ED320E93E487864E09D5F9cmp29029A313B8745323EB7008BEC73A2C4{450974EF-F6E7-51DE-B59B-C0234BA7E06D}filACB49B3868A7F9F7A69528B535CDD277cmp0FA9E9C8E34B647A87E7FEA5B80C2673{D88DEDD7-78C8-56D5-972E-59883781F062}filD44B84FE614DAD221ACD49F9E54E21A6cmp5F8497740AC973F407E2CBEE6E4976AA{29D060A2-4EAF-5A26-9C9D-09629FF160A7}fil143EE4C488E129A5AA331F0A4D7A771Acmp629DE68B9B9C10429DEFDD5EC3AA6650{83E01DDA-9262-5B3A-8D06-3BC5E78084BD}fil0652048C9241BE78CB70E79080EF9BDCcmp658E51A01AE4E3A8C69022C0D2871EEF{7009A87E-BF32-57D9-8BAC-5AA8EEAAB9EB}filF673513BF4EDB8747B296BF8F9AA34E4cmp92912157F2DC9BE4867A6458ADB0CFAC{C644A13B-67A5-5377-B496-2B10D8C9468F}fil4A36108EBD6A7E7947EBA6B4B1D6BD0DcmpFE140E2A634B1DA00EE5F3932529573F{C462ED47-B7C5-5E8D-ACCF-B88CA3C3C1CE}fil3132202E324CBEC66A4C1BE5859FCB9Ccmp8866FEE17AD8746634ADD23C705837E9{02E1EA16-A174-5F5E-BB4F-A6A28518997C}fil83C44E6D0470A49C368C6DE5101CF8F3cmpF76E987985D3EAF607C484D6E5A732F3{CFA8DFBA-47ED-5D16-AEFD-A8C7D0AA77E8}fil260949A36E873C6981D913AC1346BF29cmp4B9BD6C69C0C8927CA1BC424E2665A45{B3C58FA5-F04B-561B-9C3C-1BB6E654D0F6}filB2A7F068D94CB813350379D0A6FEFCB5cmpBC3613A9A2689ACEF1F402E4F492A346{9F9EA3D4-ED86-57C7-888F-75FB1FEE431C}filE9519020C7580D0EFB099C2154BAE9AEcmp2C3CFEB66A9BD29FD527E73FCA35A922{811A9288-BA04-5CD6-85F2-E81536F54609}filA0A9DFA39CB32E2B82C70FC50F67638Ecmp89DA50A58B8DE1FA898109FB1ABCBEAD{C6259771-C8D3-58EC-BE83-CAAD74A5DCA0}fil9974B19B76E9DB7854D7E92DBCF49B9Acmp41C8D7C020D78E0C3C19965215BC1DDF{736BE987-BCCC-599E-891F-91EA970CE0A7}fil2DE6ECBACDBBE236924341B72E6854EBcmp92327518B2942785C903C8F10AEC959E{53C74FDC-C91B-5938-83EB-623A85FC97C8}filA91DCD46C2CE428B7E0184B1916C44A2cmp330ADFDAE376FF116CDC0A3B563142FC{2FDBE8FC-9139-5238-83F1-765D9C3ADD43}fil952554E559A3D37CF1CBC89F1B99034EcmpA1997DCCED6AE02393FFE33D5BD2A974{95F2F6D2-42CD-52D1-868C-49622DA697ED}fil1AAAC74293131B36766F74E2537717ECcmpFE87C0E1710EBE75B1AE1AAD603B5ED6{C72AB904-0601-5610-918A-1C5C4CE2DC54}filDE7695706944047518323A25BDC8EF8Ccmp3A368C98224C026CCA1D01FF5C9D9416{8BC3E2B0-4896-534F-BFA4-0FF3339FC6C5}fil635D6F621FFD98DAE6821A70BA988F98cmp63110F8391037CFC6F71A1140E01315D{49FB03D4-4678-5FE1-AF07-9D716A5831AB}filF1D8DC725CF76302E49B130FEA12DC77cmp66459010579BF2ED6B70EBBD4C4BC9A3{3EBBE2A0-3D85-532B-AFDF-F7E5749667F5}fil1F176812F5B47C592F7EEE440567B137cmp36D3D7BCFD59DCB3269E34458F4AE3B3{F422D21D-B38D-5CF8-94B6-6D5680BFBA77}filCBDDD0FAA9E9F2368AAD61E12EC82749cmpAD9B709E410809706A644A1674CCC542{1DB132CB-F3CD-58E5-82F1-07182703E88A}filDD70454B64400EF3CFFDD3F0D8374886cmpDF06599551EA24F9F43C83BE65133557{F2D0A46B-E0D7-53D5-90C6-059B50058B1A}filE0691AE4B5B992F61DEE62AEBABC9567cmpE80F1489E11D140A675F941AACF424C4{FB4C0A6A-242B-5ACE-877E-25DDB95E9A03}fil4095EE631852D1BBF55120A0BD4FAB39cmp6A8449E158DBA95C12E7DC5140720D3C{C6394ECE-24A6-54DA-8177-95B4C165D747}fil58DE54979F11E85FEBABA83E7535FE17cmp66CFD4CC9DAA0D2A7BF86E20D83AF818{5C38A86C-54E2-5363-975C-83B3765698AC}fil001A96FB38F2BE0CF7A7368658F522E2cmp9D7809C6111CA95CDFEE9CA05A66B936{1ED752D7-50D2-5416-9054-EB2FB60991AE}fil64558C9BFD99C09E199542920C216948cmpF4687DCD252EDE0CFBBF5AAE13551F47{ED9D1093-150F-5B87-AB59-9C9B1E73E403}fil1994397819B8CA3082CCAEB53B3CCCC9cmp5743E08A9538F41724B0E00331DCE3AB{4A099810-C640-564A-902B-E5287640216F}fil4A0D98EAA339143DD3F65F1A07DE68EBcmpBF22C9E0689096EE725E847F88E7D0E3{31DD4B62-9145-54D0-8081-393F43CA9868}filCAAE7B2443205C1536504A1CA5A1C4C4cmpA819B712460BE65C161139EA8160AEEC{2540563F-9122-5817-95B7-C3C6285FA56B}dirBB3E837CB466D803BFF7E311956CF572filB00A05C2B96811F3566C36B8D1AFFD24cmp9C50CB9C59BD483B0B3E53F24BFAAD31{485740F2-F498-555C-BA9E-6A4318913583}fil63989A9BD1C56952C63C5CEE34DDF8A0cmp0776948C17906860F5A19BEAEA5438BD{8DCB03DA-0C50-55E6-8460-9189F953942D}filC8DB5034E2962C28E71824E688394558cmp56FEC307048B78ECE004F50FA837B31D{B4D02899-53DA-50D9-894C-9C86CC23A6F0}fil0C942FAC70EC31C8030320EC75C6EAF4cmp10D2645ADFEC4B7C8132B7E1C346775A{D7CC2319-4D43-5DBE-AD0D-8D59E3487801}filC6CB9D6FCA5270F8AB73643E0222C726cmpA536C8CC973BF5BF04714E18DA72963D{8A1CF386-4BC9-5386-84ED-AA3B63820CF8}fil697C58C328EB157F2DE8449BF5D06414cmp47ADE80C6406112BB1F66B4E82BD594A{39BC99C1-B74E-5669-A303-71CC9A7CF961}fil9E43B359A8519DDDD139E8397B7FB7E4cmp27FF246F43FB8909F7535478E94D4E57{4D850110-1C6B-5CC7-827E-1BD02F166909}fil85B44764AA1E4445F8E382CD3CDC6FC2cmpC820966AAEC79FC14ACFB586439A024D{5FB6A70E-B901-58EE-AB9C-B80E634C947E}fil23A9A79CABA36B1FDE49B0B5F4ACFBFCcmp424BDFCD0E0299A73DA07009E0DF22B8{1E9AB9B9-421D-5E04-9C9D-A5D0694979BD}filB5E0F5E47F33364FB0013A3FC9656A92cmp558EEE956065DE7382CBDCD215389912{D1BD8A14-D5B4-50AA-80AB-BBB3D6821F39}fil37AC01D3445606DE05A10A7051D01E3Fcmp75DD93043832955B50095140C1CCB0CB{39636CC5-A777-5CE0-9916-9D9C8FF4A31A}fil37EA39C56D72D9B935BD8A33BE00BC58cmp18111C573673D014F3DBE60E9A3477E5{DCFB6D7A-FC87-584D-99C2-7D7EC95A61C6}fil103E7256E980F9B9628D0CF1E33FB18Ccmp215B75627CE19CABBB7204B2885E8CE8{E3F8668E-FA8B-5075-B820-233EFFC11262}fil0FAF853CB8CDFC6CC8E069B639AFAAFBcmpE9E5F84F9B8E99089D91E29BC86A4E11{FE9D5ED1-0E25-5FCE-932F-49F2F0C053F6}fil5BF1DC0F506654E0344CBA8A2DC49688cmpB3E1D72C1927E0150A99558D1C278B51{51BC1D72-0387-569B-90F6-0E533160CB54}filA7C96EC107E2D40A199E44470E0258A9cmp573FDEC99A042CAF7DCB3BED39400C79{9E5AF439-6E89-595A-92D7-AE6418F041EF}fil7C77AE959C5C81597BE85BD48A6E8210cmp7CAD744155BB2CA595BD6C112F0F3241{F6E92DE5-4684-524D-B844-4DB9BFDBE128}filB1B55F6FFBBC4051128C89AE7F2E2756cmp1B9E607A277E302CC37B1D48880C974F{43B933EA-E2FB-5438-ADF7-B2D551044438}fil2C02AD2965AA424D3DD379513284BB05cmp288D84C8FA2D2918B4ECAE37FD2CDFA1{37AB4BC7-5C35-5740-AB54-708AF7257F54}filEA01D3F49DEC6D0C46C0BE46778899FAcmpCB1C2E578BCC929E2B40E0FE970A652B{485BAE9D-86EA-54A0-93C1-8AF5CDA5C001}fil31948DBDA39B9A143BC394DEF129214Fcmp78EECD4F53666A11EB9D7618A5181391{1CDCAF7E-77FB-5C80-9357-B1B4AAB949A3}fil66D37A86F199724A43544E614E806F7BcmpBE234535C75A796AFD3F10E5173C907C{59604BDC-F0AE-54F9-A41A-CF63B2013757}fil1FCFABC96461F6CD7CB6C2098258B7CDcmp96CD0F55D572795CF116119EA1B24C78{4D43A7FC-E821-5AD0-8A8A-2F9EA179BDD1}fil8141A45CF4CC276D30354C0982235025cmpD44E321C8E6EC75EBB573D964B1242EE{DD7FF2F2-9243-5403-B4F2-34C4F3E6FA5A}filE71AA623B10B6A42D414CFD340F5A9A5cmpA8B782D7BE028435A6FCB34AE6768785{E1E06E23-0FB8-5819-A998-BC0AC31D64D6}fil7F53B40CB2FD5E0F9FCCDCCA9B95DAFAcmp65053297E1E7604552D3B3CACEEE6398{633BBC96-FAE0-5C1B-9994-1BB12B56F985}fil34E5A669795EFD25C884FCE2C8C604D2cmp152C487D22937263DBD27F0F7B157A1B{451F440D-DE1F-557B-A12A-E7EFEA2AD476}dir5EE9FA47B574AE67BFFC6B51AC202C9Efil46B89C55D688166814B9DA213AB38C4BcmpBAA0EACC8E6AAE654234C4BF8A436BA6{C76A114D-0A5B-5904-ADDD-8B254669EB3C}fil4872EDE74F257D68ADB2E2CAD8963D2Acmp1E977A6FB6365EE7ABE8EE33F7DF748F{9E3CE04F-7B91-52C3-BEA0-6F657FCDD809}dir7CA96056D90D425BEE3F3CC319987E36filB2A42AD0A085E1963ACAD4EC9E9F2230cmpC03BD99924A78353CB62883A72ECB2CA{8D201ADB-07C2-56DD-9500-6CCB53C0BF2E}filCD7AB8DBF044B608CD002CD601A67ECBcmp2C31444A150DE3394B7943E86C7767A9{34D2C6E5-49E3-589D-8F76-B6DB8080BF1A}fil823F16E2285CB5E8F50C1A43D393FABBcmp67F43A5D78F0FBB9D68010BCF904005F{FF196105-FA4B-5557-904A-E5195B3C429A}fil7EACA370E6E62855F5A5673043C286E2cmp19A1BB406E6BD1AE1EADDDDD99BD1ECD{868688A6-6FC8-58A9-B2B2-889294F3E054}filA892DB714A159B02F6A6B4462DC9AF1AcmpA0ACE90047346E90AEF13B2CEF73F137{4973005B-F0AA-5390-BFFD-95555D627D1C}fil7B7C1CDE156FCF730F3EA7F669C87A59cmp8932392CABB27779B69CDA24515CB6EB{E18E8996-669A-5993-96D9-B455392E18DE}fil831CC977C4A66F1E9CD683190FEF2F15cmpDCEFF0CDE2A9897896A61C5BC3C32DE7{705D401D-770C-5C1F-B1DB-1E7730CD25CC}fil0A11CF7099846D3A305B2CC440EEAA98cmp6D44C91C0E936234C9E59296438B5F40{EFF75F64-F4DA-5AEA-A3BD-7FE877CD7C51}filEA21A358AC2039D4CF330E49B8A6C296cmpF386EC5334FC4D5629D564A1B4522FF7{F84E2DC7-C5BF-5289-BAD2-E32B6CAA7FD3}fil59087E7364F04851FA561E5DBF995D5Fcmp41E47512E11921092D74D9006311DED9{47AF650D-0DE0-53E1-ADD1-E38F18ADD478}filBC1A67D75D42A9B7F71117DB0FD7B54Ecmp920C2048229D8E8D299AAF712252C928{3203B0DB-E205-5968-AE9F-DC99246A25A1}filA746C1CF3885054DB9289A29A5851B1DcmpFB4CC2D79CD935F7F72B022098FEE39A{0D7C92D0-96A4-51B1-93D3-22CEEEF8E9E7}fil09829109C37858B274D1060AA34B73E6cmpEAE32EFB1111A21EA371D36B3634605B{BEE022D9-6754-563C-A763-765407D382A8}fil53FD8E87A7AF2B5D9BA1BC342C537B8Bcmp0DD55DE15E23E88E6094E8A0ED373E81{806CADAF-44E5-5ACE-A74E-E33F93F4328C}fil1D746240AC6B85C31F89CAB5617AE374cmp0FFAD70EC28133CE8BF3EF07F27421AA{CB7BA3F8-656E-5218-84D4-F67BFFD11EC6}filC3621AAFDD0737459AE91FB929B57622cmpA056D728C59B2AD568CAEDD72C1FB7EA{98E1701E-C425-5070-8F97-CDD332DC1FE4}filBF5DBE2740F73661F47F2C309EC32EF5cmp3806AE204785FBF6A59E590D4AB5DA20{7F3DE880-F415-53DC-904C-AF9AC787B8B9}filC444FF4A2284AEF30908F9E989EC55C9cmp0404E8CC61F13FC045BE25B3308A6733{C7627545-3BFD-5BC6-907A-FD7948923B52}filE4513384D2E69F037A490149B9B7A864cmp308A7A5613CE5C2F77DEF1FF58B985AF{4B237338-1CE2-5C17-AAAC-7209270B5A14}fil57AF30B01E9B60B4589C6FF3D50B4C5Bcmp3728E510ADB62BFEEC1338E5FEBC0F02{729D4581-BFCD-52D7-BAD6-5489CB965F76}fil79EEB067E72B6E02C74FB277E138F32Dcmp156298C3444420DB4B4E75D197787F47{7DDCB2B5-1B2D-53B3-BAAF-CEEF82B65693}fil4DEB946B447964A808465BCBFA3CE617cmp706CEC9CEDDD3554CA2BC6C67BD03A89{8725D22A-9AE8-593E-92D7-27B2100F1472}filE574C5DC1E403B73166C1C90C4350FBBcmpC682DC1262E6B1E2D37DE4874A775D6B{26F39ECC-5778-57BD-B0DD-671BF35A7457}filA49AFFD3C5D335C5D7D42CC7149FC44AcmpFE7376D525765CE66EFE54A6FB5721BF{0C286F5E-8B93-57EA-B5C2-F143432B0A18}fil938595A681EBEF8A3C45A7D8114F3880cmpF79120EC3265671DB7B61914A5B8DBB8{5BBB05CB-7F32-55A0-9983-443CA9CF5E08}filBE792C27B35EF245EDF283C2C100D282cmp6B41AA920C35F4CC3B335516E23032EE{DC77E0B2-638E-5CAD-A7CD-35250F5D7301}filE328D9A6EC512CB71EBB980A52AB6078cmp5C29EC72311E9F4FBF0EB77E9DA4757F{3F647F17-8120-5635-B7DC-4644C208FE52}dir9C101BB2FC89E6F3CFC17C4A922477C5fil4E1789FFC38773659E868B5AA70339EFcmp406E01D2CE850D1A72C69D915830BF5F{1C5D5582-16FE-5CB3-87DA-9939A79B7D7B}fil6B7AE4AC44B6E9B87F3FAF23CC27944CcmpACCD94EB0650B09450F39C47AD51C0AB{391D293F-D76C-5224-87C8-C6D595240CD2}filD6FA2AF37A8DD6315F2781CB63CDE3DBcmp2F71EA2BD33CD435A60C981C1C99DEFE{4CB80481-C3AA-5370-B6C3-2DE7B3E27623}fil3935CB993C3D118E2904F94D9E3C32DFcmpD78656FE3EBA58AF9C6BEE6FC40EB5E8{DA370C1A-C089-5069-9660-DF75DC0C244B}fil91276D084590C004A1BAAAFB436C7AF6cmpE8881D5661A636FD6C8D5FAA44E08485{D5762FC6-69CD-551E-8F5A-DB7CCD6D261A}filE66FE77F4DC8D8202D295C7D2CE6D780cmpF801828C013824AE6A771AC0B9EC6CF2{3AA602B7-7E0D-5498-BED5-E9F4793B558A}fil99EB6A2322BEAB0D1FDB08125FD1E8BBcmp3F8C05F3B4743015C6971D3C089AC46B{F31C8920-EEAF-5348-8BFF-91C189DC4B18}filF78F0E125C601DCE913B1F40DA077A0AC_DependencyProvider{28A46D16-5B02-52F9-ADC3-2180144387CC}TARGETDIRregB7E27B9F6AB4E9E8AF5A6F7A566848BCC_InstalledPack{531E7F0C-14ocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}
