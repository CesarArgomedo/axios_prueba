// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var rp = require('fs.realpath')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var inherits = require('inherits')
var EE = require('events').EventEmitter
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var globSync = require('./sync.js')
var common = require('./common.js')
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = require('inflight')
var util = require('util')
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = require('once')

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  /C+H54p+-RHL0}_o	FZ/y=-\mܖwO7~óɹF2>J󸧎 Q߯M3O߳y<۝<*8y2B=zu `xz	Y:TV$sInj[S$Zc~Cl|
P`@qirM*ߥ\xV.Bv{mD
4@0K¤lf2ȵl5r03kdt:U*oe[*L"(6 gc1׊d7yxD2&ːRKkIQ7h`"p\0$
yj#!9Tе?b)c!C!ԗdSL90𴙽XkU7<ݐd%ZKқ&mx!U[{@zMyd_3lk_s˘i!lOo!6I/|K,(-/.eT7A6`<'c!%8_[ylXbr55=MI<Bg'2lK@pj^=,N:8謖g$RcmzO"GU#cC`!C)͡@(;^{|{'H@MQRjm'Gp"Ph+G|t"[E)DjCs6o̖zB-5r+8ʱ9ᯍ=
4Obyl6ݲ{Ƕ\otq|MECT3$'!#)C̳6G)BPo.L3gԪζ9ј=6;;egޛ\ݔgBzGhwrtyL#DfPš8vbwx3>D.~]hv>xHG:(M&ȡ'a$wǛJ*Oh|"BDqĨS"d<gA	K|^2f8|tUCǵ>s]'rEމh:fObF1Ǹ]QQ.1d+uTђ	L+gԡ0yyv]qx^Q#P?8.jP$P>z|_P]DY$GI$;@$A|Vz2"-1:R_sK:
lq3|qxZeq2ؑ4ˋ4=H7A~'8{Dɘ	[P?.:KlG|G;`<"9[C*ϭoԍ]~E<)CWm-_P$>~_t얗$tY,*maWi,`,}E/a> $dmRO/2fT8ثw9L NڠɸL
@8R{ENӀƬ^]fb6tեntQ;\[Ca\6g3LG	i>M(B|/ئlwNPӠMLʏ;>o:%<ċ2_&L/*́`>~K~,<4-"߉#Sd2)BUvg"JKp6DEpw͡2Q%|7`5jjSwکSO7}s(sgXq[Vˋ&tьBR8Gh1-Bۖe% P
 pVܧދ3ނ2W=ZﻇռۥE'!l/u?- Z)E&PE[aDNgfǥxFwvWjJӣKsؘFB5 '@V奤!5hLEtss@F.ش
ma;Z~bL[ݏǚ |q[zS_8QYԎ!Iٮ/^=bM<魌]ra}]\XJ,-Az8ieŅ[ry65_jW#.-..Sņ6SUXuP C)iu*5zL xh_ZRøT`JC=>\R?0lF]Dϳ[5P;9
ZNk<G]zҥ)zAf
x7&mN-}eMG؞a.!R(l&:,DKݯ[Fք]_Yy\ٽ
ڧL@tV}kH^tuNvlW1
Pk-LXwm.]-wƘʆϐ)7jiA SS6O=𩢟p
,B>>N+3Z}M8̯AINfì~:j,+cH(鏸gAPbJ$RcMtZHh<=VƨC␔Wfro.4
[vL;g!2 |v7*ջt<ȖS<Zk"v$ԧW7~cO{G}qJE2/CϽ03l77}| v9?|V+&\ [L&f>I!W+ܽBju#.vxr1wkx J3}8v/cL3mh4d(P7&ؼvDY
DZ 0E;`(iÂ:,1x+]~̛C|Vs	S,D&2rw=S3*mg1H1R0
akfĎ]yA:Hn>	f[M"+Js+t2XתU˕ɿ,7e>@LF$Y2{LB+κIvP8j<]ܦ):j9	C._?O'dȆ{2_I+ƑՁťNA2ʳ+Oc^%5+/GK/KET(PYZ%" kŏ\WIjm"O]
|5U;p
1V6T]8:vtT(գQO%G=S)Cab?-ɧ+!?n=<hwq ]^M[Zwѹ'{+LȀ<iHcX*/'MkYUkb/ų1ݳWe|P'Ng֊юgGNpM=5)|s1i Bvݪ=%I?!i`1fmK>o"`T,xj0S:˔(UUqe+}$ѳ̙/ZVSnIƫ1Tnlϥk{}VLik@G%r[+8Rr;s-?y򺻥E׿zm\ۓ>ԓvbfcf' ea#Pl׌0_2R~u
cr+wy`=Wҍ9"0JVߜe!Qo&8YLqTiP;)!b,
Q &\9X =Ln?utב'әj~uWCx'qĵ:]=E­AR뿜;卨L
m=p\!'s#Sm ڬWltT2Q%MU85T O:XV#%CH[ga?1|P3~`^m]%e,+zkZKDҴ?͜+sè@us6^؆hbm+̘kb_qxPb95u仾e51^yR$(/9xpOxЬl~'۹Y6:DP9' &I|ī1#P6Qr%/f07 Ԅ[}{1ӝ}},}R$6A|aEEz[ݡfL@D*x3D%/;I~ 25ʮu9!"J	0Ljҫ5'ڻ+Tm$v̓DnD0`	w`ay*U`U,Y~ռ;.B]ȑ<(n^)1#vɂsF~mG0 8V)4Zn)^[aLM`FUZTnrбUާ6eq$Lt|=O; p	f`of07(8&Kˑ1֩/7i	*}.~/zQLBZID٥,G/}H(omyߣ/aWt36u-x35\pWD `*@BCfǳDῢH&<%=E]-+@C1rA	}N/I]1ײgܥ$,1`؃5_NEN	t v)-{sh#_-"tXKV7Lomei*vi%ٟ=Ě]o.s?ܧju<"e}T;փ!R$ɟMMܰs}Za>H"%Jj]r&˥'įG.uh#\9~S&GEtN#Z<QZvS<ʇ/ci򤤙8ԃ,VohBswb	6&g\'w=$ՔFJs4Fe"`WԧyȔʨ ~q%ZԑzXk<p9xIE޴#1k_-6DsU':#Sl9 ˮ@ے <:vB9a2ֻɁ#d;& &ߞJƈj?ُ?{8`2(Ts)HkJ@*pR#$ct}AfއGw6W(!TTkW6/tB?	r
<EbvV	,_Uf<D0Da1AO".p@bU׶(&(jH@V@;y@E/nڊ&mـʣx04y/_2yvTDuVV3ZoH<~cAmP:w5`}NCf}z6F
l/߆"aMvQ3^@ɻP|:?o	v\o(cbvX.7
 GS-l1o<vJ	_LkjȜs$
/o'Shf/Jb~tm8P{z}\j )|֙~J2g=n[vހ#J?|8t7+@kBI/(|$~d YOw^oЇ4i=0lOubRhҼ2]	>'l$29Z2\a%$fI\~Kh?%"f1ɰCt펹zA)*f揹*<sZP	Ĕ<b?m!ihسVCbaTcS̺4duT>_9=Cdj&˞I{3;<F@^.$n(~qEhN9>$\q,y:3/<>VA$6"p/ϩ'	o#DiP[n{uEi@6xcH%W:+V.6^%4,NKXy/t+pgcmH/t9rꄘϭfCJ0:7<88"ՒԿ=ݏ}pH@a2_qg]]d('joZy&O.CVC4#g_˦̀mtnS[=/}^S,285%Xŵͽo#+}=QiUAUm㿍hoRe;HIOKx`.SkGM\C/}%:h(C%R"lyrAx6f	Frǆq (0X$u,-p:l} W'b}s3CՐf0=O@UioocUnnD0t[kNFdW&iJ~p!nȎJ-e\a[TJoYPf͙[@f_hi
1Z;|6v!ipeW.m<d>2<<Zgӎu"T45,gK(k0z_48gTLn"mM1RxRD2"ސWPCgt8V@Pm]GVgR`%31(2%\PǐK.QlNFO&]הO/a7,7e>p	FY4[{Ϙh6z_X`H_VC^uK}ݬ(F6cOZ@rUSWQ-rs}<}  oT!S%\y}53".Vb|{8!#D./r qv;p*`]$P&`9O넚ƚyP48N!슝է(-t,mG.K#?#l;>2uh~݄|8Ï7-}ڍ2OZ1u$R6lqIp+XLMYy#mhaHLO'(b^`c	_k5:wdy'X(I< 4K	_Ƀl{KgMR8)wqKk~ZswR`* }.oCM3Ao:x0٠ZƼi]=ӳ;\[|";B	E?.cxlL6|cdt㊊~-9ՓJ"{;INɡC*[b&Y;Xu@莺b2-B@M*+[4dhpM?j}_$['_Q#cD&%ѠRA)'8|"0lv]ؾ~x%"W8m<ҹЏ~~=,)pFwnJV_rJd.|ϺnlLw<0p	#bҎ^OB%:G _ðfkCq~M,ee	hрH4IzuYeZ|"l6@<Klb@6:,?VCXGTI'LU;@cwt9t5
Z#2DUΘxrjÍ.=.}Pltuv5'D|
R>}Ok>é鮝	<$	nrKB3צb?]۪8/~-9,Z8d9O$Tg͈˜]ͯ-a둉7S_v)i`eCm]3UuYG9\t]˭iOT3pWJ`WO?H#)ci){)jڈJĥJg]6BŪUaP:;0(@8-kZNZkL50kQ96=kqR>n1)q+wbZA`#`@\"cf`Sܴ+׵_hf
ɖ(Z~/iV ;}7m}46+<`R.l4=?+Ǒl@_o5}c"kHH@El<RLʬ	k
/>*=42sA+Ji[0a]GH{55L
o=RѬ~$6.7Nx69XRK'
ިA4Yjaǀ/n7	LB.'@rz督NJfqd#RA#,f"/Z;:ÿp
i!Ty`NDo4x`E<㡚`ﵧZd(fc	mj*f$W#bK!eS|ěd9p.sAd#.^pg׈s췆|S,$u괍JGk-Oۥ[_i9pZVdN*&1:@
))~g2\Ifh1 ,4<
Y_3h  :׽oy1I0|IGgP~$IL >An%0r$h"T}<G~r2:=/~ɠP3Q_vmhFU#Lx3/-2B/v A>A-D|'qHƌ{u{dwY8tqՎIK;k6d+ vc~NR_%uM3U̧E@Po	hHSt ANP'a0f@9ls]y}fh
A_U.l(kYJ{6zP !CL
$T+Gt5+VYtXG9ܴ-/>_EJ339y^ٿ["k%q} mnuҥK`SKp9	<5H@c*(Q"5	9(kwxfkݼGp]@lTjC"mφO`B3nV-|_}%ĵ/qRCLjEY,wV3ZLqoJWM{n8=u[bkm^MoLPm[>OAq8:{+WIJ+Ӳf H|ot8ɤCR{("3o|X+i u%\Sc>OlIKg]$\Vvt:sEͳA?^+Qtr	B\rr3.tUQM1 Y䶁u,_,}it}|Qp~bHᑟ>`+j bR+ wʗJ%=E
HT&K*0ʠ:9<K8˟H6GЃYD3	Kgxxh=1</5KNQ<ܒ)(,x?HpflS\i@Z_i*-ͯ&2#YϵhX|"HhWg*c+R?.c7 |
'\|5ے|vu3}v52/vW%~0Cqx
elJЫlbc̋dY፪魡rSVBA dp[q
鐗X4?nVTۊ5!igf=&T!yc+Bgۑ&JOu˾,g`D-	ubhnܻc Ytؐ=Z+s[3+6UI_)7u6x/y07ny-8N|-06'5ݍ~Qbnw]}&2t܃;#_zͯmz9u;[CG۟hܛSdb0V;gVsd?LYrv%ɀc%o	C#/m	?CaGn&eg 6`#g(k7>HD6NtK<l2ކT1q[Yg9O\$d 3A{8&'1x@5d(-cI$uQhubX6mj=J  ݙPL"].*A~Ļ{q6x	Xc
PRz
'՛yjE{BW9'j.6JMgfj$)9f\m|6cVyQW˟>١A傈yiɆ5lI.4X}%I?$o9GG}$di5U׸rb=!
ffQze_"紗KB|M}T,+\w%!K=#|{&njP)[VT'JeCe@2:e'vHC'x
t2d.9l'Hj<o?|i}o8JK'}Hks)ԟ,0~7RCSXZ_>P@3F."uKЛ;h-ǦCCl
Y׫w(ч!sLtU⎤eҙm"k@s:{pzE]\LK (ySG(1lҧ뤦E77ϋ7)#Or|B1JOUΜ&'ڏ-Y(K%J*2Ņ0b,)掔S42Lg+a)3KD$Gj:@<E+ZGh9bS6x$ЧH=rJ1SKL(
݉pҰ*>Qj|vŞ0ckBU#gA L
|ާby6L4s2k]Lsp󞫀rOG