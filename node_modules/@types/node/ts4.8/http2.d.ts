/**
 * The `http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol. It
 * can be accessed using:
 *
 * ```js
 * const http2 = require('http2');
 * ```
 * @since v8.4.0
 * @see [source](https://github.com/nodejs/node/blob/v18.0.0/lib/http2.js)
 */
declare module 'http2' {
    import EventEmitter = require('node:events');
    import * as fs from 'node:fs';
    import * as net from 'node:net';
    import * as stream from 'node:stream';
    import * as tls from 'node:tls';
    import * as url from 'node:url';
    import { IncomingHttpHeaders as Http1IncomingHttpHeaders, OutgoingHttpHeaders, IncomingMessage, ServerResponse } from 'node:http';
    export { OutgoingHttpHeaders } from 'node:http';
    export interface IncomingHttpStatusHeader {
        ':status'?: number | undefined;
    }
    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {
        ':path'?: string | undefined;
        ':method'?: string | undefined;
        ':authority'?: string | undefined;
        ':scheme'?: string | undefined;
    }
    // Http2Stream
    export interface StreamPriorityOptions {
        exclusive?: boolean | undefined;
        parent?: number | undefined;
        weight?: number | undefined;
        silent?: boolean | undefined;
    }
    export interface StreamState {
        localWindowSize?: number | undefined;
        state?: number | undefined;
        localClose?: number | undefined;
        remoteClose?: number | undefined;
        sumDependencyWeight?: number | undefined;
        weight?: number | undefined;
    }
    export interface ServerStreamResponseOptions {
        endStream?: boolean | undefined;
        waitForTrailers?: boolean | undefined;
    }
    export interface StatOptions {
        offset: number;
        length: number;
    }
    export interface ServerStreamFileResponseOptions {
        statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): void | boolean;
        waitForTrailers?: boolean | undefined;
        offset?: number | undefined;
        length?: number | undefined;
    }
    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {
        onError?(err: NodeJS.ErrnoException): void;
    }
    export interface Http2Stream extends stream.Duplex {
        /**
         * Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,
         * the `'aborted'` event will have been emitted.
         * @since v8.4.0
         */
        readonly aborted: boolean;
        /**
         * This property shows the number of characters currently buffered to be written.
         * See `net.Socket.bufferSize` for details.
         * @since v11.2.0, v10.16.0
         */
        readonly bufferSize: number;
        /**
         * Set to `true` if the `Http2Stream` instance has been closed.
         * @since v9.4.0
         */
        readonly closed: boolean;
        /**
         * Set to `true` if the `Http2Stream` instance has been destroyed and is no longer
         * usable.
         * @since v8.4.0
         */
        readonly destroyed: boolean;
        /**
         * Set to `true` if the `END_STREAM` flag was set in the request or response
         * HEADERS frame received, indicating that no additional data should be received
         * and the readable side of the `Http2Stream` will be closed.
         * @since v10.11.0
         */
        readonly endAfterHeaders: boolean;
        /**
         * The numeric stream identifier of this `Http2Stream` instance. Set to `undefined`if the stream identifier has not yet been assigned.
         * @since v8.4.0
         */
        readonly id?: number | undefined;
        /**
         * Set to `true` if the `Http2Stream` instance has not yet been assigned a
         * numeric stream identifier.
         * @since v9.4.0
         */
        readonly pending: boolean;
        /**
         * Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is
         * destroyed after either receiving an `RST_STREAM` frame from the connected peer,
         * calling `http2stream.close()`, or `http2stream.destroy()`. Will be`undefined` if the `Http2Stream` has not been closed.
         * @since v8.4.0
         */
        readonly rstCode: number;
        /**
         * An object containing the outbound headers sent for this `Http2Stream`.
         * @since v9.5.0
         */
        readonly sentHeaders: OutgoingHttpHeaders;
        /**
         * An array of objects containing the outbound informational (additional) headers
         * sent for this `Http2Stream`.
         * @since v9.5.0
         */
        readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;
        /**
         * An object containing the outbound trailers sent for this `HttpStream`.
         * @since v9.5.0
         */
        readonly sentTrailers?: OutgoingHttpHeaders | undefined;
        /**
         * A reference to the `Http2Session` instance that owns this `Http2Stream`. The
         * value will be `undefined` after the `Http2Stream` instance is destroyed.
         * @since v8.4.0
         */
        readonly session: Http2Session;
        /**
         * Provides miscellaneous information about the current state of the`Http2Stream`.
         *
         * A current state of this `Http2Stream`.
         * @since v8.4.0
         */
        readonly state: StreamState;
        /**
         * Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the
         * connected HTTP/2 peer.
         * @since v8.4.0
         * @param [code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.
         * @param callback An optional function registered to listen for the `'close'` event.
         */
        close(code?: number, callback?: () => void): void;
        /**
         * Updates the priority for this `Http2Stream` instance.
         * @since v8.4.0
         */
        priority(options: StreamPriorityOptions): void;
        /**
         * ```js
         * const http2 = require('http2');
         * const client = http2.connect('http://example.org:8000');
         * const { NGHTTP2_CANCEL } = http2.constants;
         * const req = client.request({ ':path': '/' });
         *
         * // Cancel the stream if there's no activity after 5 seconds
         * req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));
         * ```
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method
         * will cause the `Http2Stream` to be immediately closed and must only be
         * called after the `'wantTrailers'` event has been emitted. When sending a
         * request or sending a response, the `options.waitForTrailers` option must be set
         * in order to keep the `Http2Stream` open after the final `DATA` frame so that
         * trailers can be sent.
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond(undefined, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ xyz: 'abc' });
         *   });
         *   stream.end('Hello World');
         * });
         * ```
         *
         * The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
         * fields (e.g. `':method'`, `':path'`, etc).
         * @since v10.0.0
         */
        sendTrailers(headers: OutgoingHttpHeaders): void;
        addListener(event: 'aborted', listener: () => void): this;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'data', listener: (chunk: Buffer | string) => void): this;
        addListener(event: 'drain', listener: () => void): this;
        addListener(event: 'end', listener: () => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: 'finish', listener: () => void): this;
        addListener(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        addListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        addListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        addListener(event: 'streamClosed', listener: (code: number) => void): this;
        addListener(event: 'timeout', listener: () => void): this;
        addListener(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: 'wantTrailers', listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'aborted'): boolean;
        emit(event: 'close'): boolean;
        emit(event: 'data', chunk: Buffer | string): boolean;
        emit(event: 'drain'): boolean;
        emit(event: 'end'): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: 'finish'): boolean;
        emit(event: 'frameError', frameType: number, errorCode: number): boolean;
        emit(event: 'pipe', src: stream.Readable): boolean;
        emit(event: 'unpipe', src: stream.Readable): boolean;
        emit(event: 'streamClosed', code: number): boolean;
        emit(event: 'timeout'): boolean;
        emit(event: 'trailers', trailers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: 'wantTrailers'): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'aborted', listener: () => void): this;
        on(event: 'close', listener: () => void): this;
        on(event: 'data', listener: (chunk: Buffer | string) => void): this;
        on(event: 'drain', listener: () => void): this;
        on(event: 'end', listener: () => void): this;
        on(event: 'error', listener: (err: Error) => void): this;
        on(event: 'finish', listener: () => void): this;
        on(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        on(event: 'pipe', listener: (src: stream.Readable) => void): this;
        on(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        on(event: 'streamClosed', listener: (code: number) => void): this;
        on(event: 'timeout', listener: () => void): this;
        on(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: 'wantTrailers', listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'aborted', listener: () => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'data', listener: (chunk: Buffer | string) => void): this;
        once(event: 'drain', listener: () => void): this;
        once(event: 'end', listener: () => void): this;
        once(event: 'error', listener: (err: Error) => void): this;
        once(event: 'finish', listener: () => void): this;
        once(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        once(event: 'pipe', listener: (src: stream.Readable) => void): this;
        once(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        once(event: 'streamClosed', listener: (code: number) => void): this;
        once(event: 'timeout', listener: () => void): this;
        once(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: 'wantTrailers', listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'aborted', listener: () => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'data', listener: (chunk: Buffer | string) => void): this;
        prependListener(event: 'drain', listener: () => void): this;
        prependListener(event: 'end', listener: () => void): this;
        prependListener(event: 'error', listener: (err: Error) => void): this;
        prependListener(event: 'finish', listener: () => void): this;
        prependListener(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        prependListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        prependListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        prependListener(event: 'streamClosed', listener: (code: number) => void): this;
        prependListener(event: 'timeout', listener: () => void): this;
        prependListener(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: 'wantTrailers', listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'aborted', listener: () => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'data', listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: 'drain', listener: () => void): this;
        prependOnceListener(event: 'end', listener: () => void): this;
        prependOnceListener(event: 'error', listener: (err: Error) => void): this;
        prependOnceListener(event: 'finish', listener: () => void): this;
        prependOnceListener(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        prependOnceListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: 'streamClosed', listener: (code: number) => void): this;
        prependOnceListener(event: 'timeout', listener: () => void): this;
        prependOnceListener(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: 'wantTrailers', listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Stream extends Http2Stream {
        addListener(event: 'continue', listener: () => {}): this;
        addListener(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        addListener(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'continue'): boolean;
        emit(event: 'headers', headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: 'push', headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: 'response', headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'continue', listener: () => {}): this;
        on(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        on(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'continue', listener: () => {}): this;
        once(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        once(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'continue', listener: () => {}): this;
        prependListener(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependListener(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'continue', listener: () => {}): this;
        prependOnceListener(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependOnceListener(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ServerHttp2Stream extends Http2Stream {
        /**
         * True if headers were sent, false otherwise (read-only).
         * @since v8.4.0
         */
        readonly headersSent: boolean;
        /**
         * Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote
         * client's most recent `SETTINGS` frame. Will be `true` if the remote peer
         * accepts push streams, `false` otherwise. Settings are the same for every`Http2Stream` in the same `Http2Session`.
         * @since v8.4.0
         */
        readonly pushAllowed: boolean;
        /**
         * Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.
         * @since v8.4.0
         */
        additionalHeaders(headers: OutgoingHttpHeaders): void;
        /**
         * Initiates a push stream. The callback is invoked with the new `Http2Stream`instance created for the push stream passed as the second argument, or an`Error` passed as the first argument.
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 });
         *   stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {
         *     if (err) throw err;
         *     pushStream.respond({ ':status': 200 });
         *     pushStream.end('some pushed data');
         *   });
         *   stream.end('some data');
         * });
         * ```
         *
         * Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass
         * a `weight` value to `http2stream.priority` with the `silent` option set to`true` to enable server-side bandwidth balancing between concurrent streams.
         *
         * Calling `http2stream.pushStream()` from within a pushed stream is not permitted
         * and will throw an error.
         * @since v8.4.0
         * @param callback Callback that is called once the push stream has been initiated.
         */
        pushStream(headers: OutgoingHttpHeaders, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;
        pushStream(headers: OutgoingHttpHeaders, options?: StreamPriorityOptions, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;
        /**
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 });
         *   stream.end('some data');
         * });
         * ```
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 }, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         *   stream.end('some data');
         * });
         * ```
         * @since v8.4.0
         */
        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;
        /**
         * Initiates a response whose data is read from the given file descriptor. No
         * validation is performed on the given file descriptor. If an error occurs while
         * attempting to read data using the file descriptor, the `Http2Stream` will be
         * closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
         *
         * When used, the `Http2Stream` object's `Duplex` interface will be closed
         * automatically.
         *
         * ```js
         * const http2 = require('http2');
         * const fs = require('fs');
         *
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   const fd = fs.openSync('/some/file', 'r');
         *
         *   const stat = fs.fstatSync(fd);
         *   const headers = {
         *     'content-length': stat.size,
         *     'last-modified': stat.mtime.toUTCString(),
         *     'content-type': 'text/plain; charset=utf-8'
         *   };
         *   stream.respondWithFD(fd, headers);
         *   stream.on('close', () => fs.closeSync(fd));
         * });
         * ```
         *
         * The optional `options.statCheck` function may be specified to give user code
         * an opportunity to set additional content headers based on the `fs.Stat` details
         * of the given fd. If the `statCheck` function is provided, the`http2stream.respondWithFD()` method will perform an `fs.fstat()` call to
         * collect details on the provided file descriptor.
         *
         * The `offset` and `length` options may be used to limit the response to a
         * specific range subset. This can be used, for instance, to support HTTP Range
         * requests.
         *
         * The file descriptor or `FileHandle` is not closed when the stream is closed,
         * so it will need to be closed manually once it is no longer needed.
         * Using the same file descriptor concurrently for multiple streams
         * is not supported and may result in data loss. Re-using a file descriptor
         * after a stream has finished is supported.
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code _must_ call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * ```js
         * const http2 = require('http2');
         * const fs = require('fs');
         *
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   const fd = fs.openSync('/some/file', 'r');
         *
         *   const stat = fs.fstatSync(fd);
         *   const headers = {
         *     'content-length': stat.size,
         *     'last-modified': stat.mtime.toUTCString(),
         *     'content-type': 'text/plain; charset=utf-8'
         *   };
         *   stream.respondWithFD(fd, headers, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         *
         *   stream.on('close', () => fs.closeSync(fd));
         * });
         * ```
         * @since v8.4.0
         * @param fd A readable file descriptor.
         */
        respondWithFD(fd: number | fs.promises.FileHandle, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptions): void;
        /**
         * Sends a regular file as the response. The `path` must specify a regular file
         * or an `'error'` event will be emitted on the `Http2Stream` object.
         *
         * When used, the `Http2Stream` object's `Duplex` interface will be closed
         * automatically.
         *
         * The optional `options.statCheck` function may be specified to give user code
         * an opportunity to set additional content headers based on the `fs.Stat` details
         * of the given file:
         *
         * If an error occurs while attempting to read the file data, the `Http2Stream`will be closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR`code. If the `onError` callback is
         * defined, then it will be called. Otherwise
         * the stream will be destroyed.
         *
         * Example using a file path:
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   function statCheck(stat, headers) {
         *     headers['last-modified'] = stat.mtime.toUTCString();
         *   }
         *
         *   function onError(err) {
         *     // stream.respond() can throw if the stream has been destroyed by
         *     // the other side.
         *     try {
         *       if (err.code === 'ENOENT') {
         *         stream.respond({ ':status': 404 });
         *       } else {
         *         stream.respond({ ':status': 500 });
         *       }
         *     } catch (err) {
         *       // Perform actual error handling.
         *       console.log(err);
         *     }
         *     stream.end();
         *   }
         *
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { statCheck, onError });
         * });
         * ```
         *
         * The `options.statCheck` function may also be used to cancel the send operation
         * by returning `false`. For instance, a conditional request may check the stat
         * results to determine if the file has been modified to return an appropriate`304` response:
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   function statCheck(stat, headers) {
         *     // Check the stat here...
         *     stream.respond({ ':status': 304 });
         *     return false; // Cancel the send operation
         *   }
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { statCheck });
         * });
         * ```
         *
         * The `content-length` header field will be automatically set.
         *
         * The `offset` and `length` options may be used to limit the response to a
         * specific range subset. This can be used, for instance, to support HTTP Range
         * requests.
         *
         * The `options.onError` function may also be used to handle all the errors
         * that could happen before the delivery of the file is initiated. The
         * default behavior is to destroy the stream.
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         * });
         * ```
         * @since v8.4.0
         */
        respondWithFile(path: string, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptionsWithError): void;
    }
    // Http2Session
    export interface Settings {
        headerTableSize?: number | undefined;
        enablePush?: boolean | undefined;
        initialWindowSize?: number | undefined;
        maxFrameSize?: number | undefined;
        maxConcurrentStreams?: number | undefined;
        maxHeaderListSize?: number | undefined;
        enableConnectProtocol?: boolean | undefined;
    }
    export interface ClientSessionRequestOptions {
        endStream?: boolean | undefined;
        exclusive?: boolean | undefined;
        parent?: number | undefined;
        weight?: number | undefined;
        waitForTrailers?: boolean | undefined;
        signal?: AbortSignal | undefined;
    }
    export interface SessionState {
        effectiveLocalWindowSize?: number | undefined;
        effectiveRecvDataLength?: number | undefined;
        nextStreamID?: number | undefined;
        localWindowSize?: number | undefined;
        lastProcStreamID?: number | undefined;
        remoteWindowSize?: number | undefined;
        outboundQueueSize?: number | undefined;
        deflateDynamicTableSize?: number | undefined;
        inflateDynamicTableSize?: number | undefined;
    }
    export interface Http2Session extends EventEmitter {
        /**
         * Value will be `undefined` if the `Http2Session` is not yet connected to a
         * socket, `h2c` if the `Http2Session` is not connected to a `TLSSocket`, or
         * will return the value of the connected `TLSSocket`'s own `alpnProtocol`property.
         * @since v9.4.0
         */
        readonly alpnProtocol?: string | undefined;
        /**
         * Will be `true` if this `Http2Session` instance has been closed, otherwise`false`.
         * @since v9.4.0
         */
        readonly closed: boolean;
        /**
         * Will be `true` if this `Http2Session` instance is still connecting, will be set
         * to `false` before emitting `connect` event and/or calling the `http2.connect`callback.
         * @since v10.0.0
         */
        readonly connecting: boolean;
        /**
         * Will be `true` if this `Http2Session` instance has been destroyed and must no
         * longer be used, otherwise `false`.
         * @since v8.4.0
         */
        readonly destroyed: boolean;
        /**
         * Value is `undefined` if the `Http2Session` session socket has not yet been
         * connected, `true` if the `Http2Session` is connected with a `TLSSocket`,
         * and `false` if the `Http2Session` is connected to any other kind of socket
         * or stream.
         * @since v9.4.0
         */
        readonly encrypted?: boolean | undefined;
        /**
         * A prototype-less object describing the current local settings of this`Http2Session`. The local settings are local to _this_`Http2Session` instance.
         * @since v8.4.0
         */
        readonly localSettings: Settings;
        /**
         * If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property
         * will return an `Array` of origins for which the `Http2Session` may be
         * considered authoritative.
         *
         * The `originSet` property is only available when using a secure TLS connection.
         * @since v9.4.0
         */
        readonly originSet?: string[] | undefined;
        /**
         * Indicates whether the `Http2Session` is currently waiting for acknowledgment of
         * a sent `SETTINGS` frame. Will be `true` after calling the`http2session.settings()` method. Will be `false` once all sent `SETTINGS`frames have been acknowledged.
         * @since v8.4.0
         */
        readonly pendingSettingsAck: boolean;
        /**
         * A prototype-less object describing the current remote settings of this`Http2Session`. The remote settings are set by the _connected_ HTTP/2 peer.
         * @since v8.4.0
         */
        readonly remoteSettings: Settings;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * limits available methods to ones safe to use with HTTP/2.
         *
         * `destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw
         * an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.
         *
         * `setTimeout` method will be called on this `Http2Session`.
         *
         * All other interactions will be routed directly to the socket.
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * Provides miscellaneous information about the current state of the`Http2Session`.
         *
         * An object describing the current status of this `Http2Session`.
         * @since v8.4.0
         */
        readonly state: SessionState;
        /**
         * The `http2session.type` will be equal to`http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a
         * server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a
         * client.
         * @since v8.4.0
         */
        readonly type: number;
        /**
         * Gracefully closes the `Http2Session`, allowing any existing streams to
         * complete on their own and preventing new `Http2Stream` instances from being
         * created. Once closed, `http2session.destroy()`_might_ be called if there
         * are no open `Http2Stream` instances.
         *
         * If specified, the `callback` function is registered as a handler for the`'close'` event.
         * @since v9.4.0
         */
        close(callback?: () => void): void;
        /**
         * Immediately terminates the `Http2Session` and the associated `net.Socket` or`tls.TLSSocket`.
         *
         * Once destroyed, the `Http2Session` will emit the `'close'` event. If `error`is not undefined, an `'error'` event will be emitted immediately before the`'close'` event.
         *
         * If there are any remaining open `Http2Streams` associated with the`Http2Session`, those will also be destroyed.
         * @since v8.4.0
         * @param error An `Error` object if the `Http2Session` is being destroyed due to an error.
         * @param code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.
         */
        destroy(error?: Error, code?: number): void;
        /**
         * Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.
         * @since v9.4.0
         * @param code An HTTP/2 error code
         * @param lastStreamID The numeric ID of the last processed `Http2Stream`
         * @param opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.
         */
        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;
        /**
         * Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must
         * be provided. The method will return `true` if the `PING` was sent, `false`otherwise.
         *
         * The maximum number of outstanding (unacknowledged) pings is determined by the`maxOutstandingPings` configuration option. The default maximum is 10.
         *
         * If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView`containing 8 bytes of data that will be transmitted with the `PING` and
         * returned with the ping acknowledgment.
         *
         * The callback will be invoked with three arguments: an error argument that will
         * be `null` if the `PING` was successfully acknowledged, a `duration` argument
         * that reports the number of milliseconds elapsed since the ping was sent and the
         * acknowledgment was received, and a `Buffer` containing the 8-byte `PING`payload.
         *
         * ```js
         * session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {
         *   if (!err) {
         *     console.log(`Ping acknowledged in ${duration} milliseconds`);
         *     console.log(`With payload '${payload.toString()}'`);
         *   }
         * });
         * ```
         *
         * If the `payload` argument is not specified, the default payload will be the
         * 64-bit timestamp (little endian) marking the start of the `PING` duration.
         * @since v8.9.3
         * @param payload Optional ping payload.
         */
        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
        ping(payload: NodeJS.ArrayBufferView, callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
        /**
         * Calls `ref()` on this `Http2Session`instance's underlying `net.Socket`.
         * @since v9.4.0
         */
        ref(): void;
        /**
         * Sets the local endpoint's window size.
         * The `windowSize` is the total window size to set, not
         * the delta.
         *
         * ```js
         * const http2 = require('http2');
         *
         * const server = http2.createServer();
         * const expectedWindowSize = 2 ** 20;
         * server.on('connect', (session) => {
         *
         *   // Set local window size to be 2 ** 20
         *   session.setLocalWindowSize(expectedWindowSize);
         * });
         * ```
         * @since v15.3.0, v14.18.0
         */
        setLocalWindowSize(windowSize: number): void;
        /**
         * Used to set a callback function that is called when there is no activity on
         * the `Http2Session` after `msecs` milliseconds. The given `callback` is
         * registered as a listener on the `'timeout'` event.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * Updates the current local settings for this `Http2Session` and sends a new`SETTINGS` frame to the connected HTTP/2 peer.
         *
         * Once called, the `http2session.pendingSettingsAck` property will be `true`while the session is waiting for the remote peer to acknowledge the new
         * settings.
         *
         * The new settings will not become effective until the `SETTINGS` acknowledgment
         * is received and the `'localSettings'` event is emitted. It is possible to send
         * multiple `SETTINGS` frames while acknowledgment is still pending.
         * @since v8.4.0
         * @param callback Callback that is called once the session is connected or right away if the session is already connected.
         */
        settings(settings: Settings, callback?: (err: Error | null, settings: Settings, duration: number) => void): void;
        /**
         * Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.
         * @since v9.4.0
         */
        unref(): void;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        addListener(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        addListener(event: 'localSettings', listener: (settings: Settings) => void): this;
        addListener(event: 'ping', listener: () => void): this;
        addListener(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        addListener(event: 'timeout', listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'close'): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: 'frameError', frameType: number, errorCode: number, streamID: number): boolean;
        emit(event: 'goaway', errorCode: number, lastStreamID: number, opaqueData: Buffer): boolean;
        emit(event: 'localSettings', settings: Settings): boolean;
        emit(event: 'ping'): boolean;
        emit(event: 'remoteSettings', settings: Settings): boolean;
        emit(event: 'timeout'): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'close', listener: () => void): this;
        on(event: 'error', listener: (err: Error) => void): this;
        on(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        on(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        on(event: 'localSettings', listener: (settings: Settings) => void): this;
        on(event: 'ping', listener: () => void): this;
        on(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        on(event: 'timeout', listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'error', listener: (err: Error) => void): this;
        once(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        once(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        once(event: 'localSettings', listener: (settings: Settings) => void): this;
        once(event: 'ping', listener: () => void): this;
        once(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        once(event: 'timeout', listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'error', listener: (err: Error) => void): this;
        prependListener(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        prependListener(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        prependListener(event: 'localSettings', listener: (settings: Settings) => void): this;
        prependListener(event: 'ping', listener: () => void): this;
        prependListener(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        prependListener(event: 'timeout', listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'error', listener: (err: Error) => void): this;
        prependOnceListener(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        prependOnceListener(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        prependOnceListener(event: 'localSettings', listener: (settings: Settings) => void): this;
        prependOnceListener(event: 'ping', listener: () => void): this;
        prependOnceListener(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        prependOnceListener(event: 'timeout', listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Session extends Http2Session {
        /**
         * For HTTP/2 Client `Http2Session` instances only, the `http2session.request()`creates and returns an `Http2Stream` instance that can be used to send an
         * HTTP/2 request to the connected server.
         *
         * When a `ClientHttp2Session` is first created, the socket may not yet be
         * connected. if `clienthttp2session.request()` is called during this time, the
         * actual request will be deferred until the socket is ready to go.
         * If the `session` is closed before the actual request be executed, an`ERR_HTTP2_GOAWAY_SESSION` is thrown.
         *
         * This method is only available if `http2session.type` is equal to`http2.constants.NGHTTP2_SESSION_CLIENT`.
         *
         * ```js
         * const http2 = require('http2');
         * const clientSession = http2.connect('https://localhost:1234');
         * const {
         *   HTTP2_HEADER_PATH,
         *   HTTP2_HEADER_STATUS
         * } = http2.constants;
         *
         * const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });
         * req.on('response', (headers) => {
         *   console.log(headers[HTTP2_HEADER_STATUS]);
         *   req.on('data', (chunk) => { // ..  });
         *   req.on('end', () => { // ..  });
         * });
         * ```
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * is emitted immediately after queuing the last chunk of payload data to be sent.
         * The `http2stream.sendTrailers()` method can then be called to send trailing
         * headers to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * When `options.signal` is set with an `AbortSignal` and then `abort` on the
         * corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.
         *
         * The `:method` and `:path` pseudo-headers are not specified within `headers`,
         * they respectively default to:
         *
         * * `:method` \= `'GET'`
         * * `:path` \= `/`
         * @since v8.4.0
         */
        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;
        addListener(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        addListener(event: 'origin', listener: (origins: string[]) => void): this;
        addListener(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        addListener(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'altsvc', alt: string, origin: string, stream: number): boolean;
        emit(event: 'origin', origins: ReadonlyArray<string>): boolean;
        emit(event: 'connect', session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
        emit(event: 'stream', stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        on(event: 'origin', listener: (origins: string[]) => void): this;
        on(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        on(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        once(event: 'origin', listener: (origins: string[]) => void): this;
        once(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        once(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        prependListener(event: 'origin', listener: (origins: string[]) => void): this;
        prependListener(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        prependListener(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        prependOnceListener(event: 'origin', listener: (origins: string[]) => void): this;
        prependOnceListener(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        prependOnceListener(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface AlternativeServiceOptions {
        origin: number | string | url.URL;
    }
    export interface ServerHttp2Session extends Http2Session {
        readonly server: Http2Server | Http2SecureServer;
        /**
         * Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.
         *
         * ```js
         * const http2 = require('http2');
         *
         * const server = http2.createServer();
         * server.on('session', (session) => {
         *   // Set altsvc for origin https://example.org:80
         *   session.altsvc('h2=":8000"', 'https://example.org:80');
         * });
         *
         * server.on('stream', (stream) => {
         *   // Set altsvc for a specific stream
         *   stream.session.altsvc('h2=":8000"', stream.id);
         * });
         * ```
         *
         * Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate
         * service is associated with the origin of the given `Http2Stream`.
         *
         * The `alt` and origin string _must_ contain only ASCII bytes and are
         * strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given
         * domain.
         *
         * When a string is passed for the `originOrStream` argument, it will be parsed as
         * a URL and the origin will be derived. For instance, the origin for the
         * HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string
         * cannot be parsed as a URL or if a valid origin cannot be derived.
         *
         * A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be
         * used. The value of the `origin` property _must_ be a properly serialized
         * ASCII origin.
         * @since v9.4.0
         * @param alt A description of the alternative service configuration as defined by `RFC 7838`.
         * @param originOrStrdiaQueryMergeResult_unrepresentable;p=g,$=a,h=r}else if(s||E.equalsIgnoreCase(n,f))$=(l||E.equalsIgnoreCase(B,f))&&_?y:u,s=E.List_List$of(S.conditions,!0,D.String),I.JSArray_methods.addAll$1(s,e.conditions),p=s,h=o;else{if(l||E.equalsIgnoreCase(B,f))s=E.List_List$of(S.conditions,!0,D.String),I.JSArray_methods.addAll$1(s,e.conditions),p=s,h=r;else{if(a!=u)return I._SingletonCssMediaQueryMergeResult_empty;h=null==r?o:r,s=E.List_List$of(S.conditions,!0,D.String),I.JSArray_methods.addAll$1(s,e.conditions),p=s}$=a}return n=$==a?n:B,new E.MediaQuerySuccessfulMergeResult(E.CssMediaQuery$type(n,p,h==r?t:i))},$eq(e,t){return null!=t&&(t instanceof E.CssMediaQuery&&t.modifier==this.modifier&&t.type==this.type&&I.C_ListEquality.equals$2(0,t.conditions,this.conditions))},get$hashCode(e){return A.get$hashCode$(this.modifier)^A.get$hashCode$(this.type)^I.C_ListEquality0.hash$1(this.conditions)},toString$0(e){var t,r=this,n=r.modifier;return n=null!=n?n+" ":"",null!=(t=r.type)&&(n+=t,0!==r.conditions.length&&(n+=" and ")),t=r.conjunction?" and ":" or ",(t=n+I.JSArray_methods.join$1(r.conditions,t)).charCodeAt(0),t}},E._SingletonCssMediaQueryMergeResult.prototype={toString$0(e){return this._media_query$_name}},E.MediaQuerySuccessfulMergeResult.prototype={toString$0(e){return this.query.toString$0(0)}},E.ModifiableCssAtRule.prototype={accept$1$1(e){return e.visitCssAtRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},copyWithoutChildren$0(){var e=this;return E.ModifiableCssAtRule$(e.name,e.span,e.isChildless,e.value)},addChild$1(e){this.super$ModifiableCssParentNode$addChild(e)},$isCssAtRule:1,get$isChildless(){return this.isChildless},get$span(e){return this.span}},E.ModifiableCssComment.prototype={accept$1$1(e){return e.visitCssComment$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},$isCssComment:1,get$span(e){return this.span}},E.ModifiableCssDeclaration.prototype={accept$1$1(e){return e.visitCssDeclaration$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return this.name.toString$0(0)+": "+this.value.toString$0(0)+";"},get$span(e){return this.span}},E.ModifiableCssImport.prototype={accept$1$1(e){return e.visitCssImport$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},$isCssImport:1,get$span(e){return this.span}},E.ModifiableCssKeyframeBlock.prototype={accept$1$1(e){return e.visitCssKeyframeBlock$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},copyWithoutChildren$0(){return E.ModifiableCssKeyframeBlock$(this.selector,this.span)},get$span(e){return this.span}},E.ModifiableCssMediaRule.prototype={accept$1$1(e){return e.visitCssMediaRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},copyWithoutChildren$0(){return E.ModifiableCssMediaRule$(this.queries,this.span)},$isCssMediaRule:1,get$span(e){return this.span}},E.ModifiableCssNode.prototype={get$hasFollowingSibling(){var e,t=this._parent;return null==t?t=null:(t=t.children,(e=this._indexInParent).toString,t=E.SubListIterable$(t,e+1,null,t.$ti._eval$1("ListMixin.E")).any$1(0,new E.ModifiableCssNode_hasFollowingSibling_closure)),!0===t},get$isGroupEnd(){return this.isGroupEnd}},E.ModifiableCssNode_hasFollowingSibling_closure.prototype={call$1:e=>!e.accept$1(I._IsInvisibleVisitor_true_false),$signature:121},E.ModifiableCssParentNode.prototype={get$isChildless:()=>!1,addChild$1(e){var t;e._parent=this,t=this._children,e._indexInParent=t.length,t.push(e)},$isCssParentNode:1,get$children(e){return this.children}},E.ModifiableCssStyleRule.prototype={accept$1$1(e){return e.visitCssStyleRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},copyWithoutChildren$0(){return E.ModifiableCssStyleRule$(this.selector,this.span,this.originalSelector)},$isCssStyleRule:1,get$span(e){return this.span}},E.ModifiableCssStylesheet.prototype={accept$1$1(e){return e.visitCssStylesheet$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},copyWithoutChildren$0(){return E.ModifiableCssStylesheet$(this.span)},$isCssStylesheet:1,get$span(e){return this.span}},E.ModifiableCssSupportsRule.prototype={accept$1$1(e){return e.visitCssSupportsRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},copyWithoutChildren$0(){return E.ModifiableCssSupportsRule$(this.condition,this.span)},$isCssSupportsRule:1,get$span(e){return this.span}},E.ModifiableCssValue.prototype={toString$0(e){return E.serializeSelector(this.value,!0)},$isCssValue:1,$isAstNode:1,get$value(e){return this.value},get$span(e){return this.span}},E.CssNode.prototype={toString$0(e){return E.serialize(this,!0,null,!0,null,!1,null,!0).css}},E.CssParentNode.prototype={},E._IsInvisibleVisitor.prototype={visitCssAtRule$1:e=>!1,visitCssComment$1(e){return this.includeComments&&33!==I.JSString_methods._codeUnitAt$1(e.text,2)},visitCssStyleRule$1(e){var t=e.selector.value;return(this.includeBogus?t.accept$1(I._IsInvisibleVisitor_true):t.accept$1(I._IsInvisibleVisitor_false))||this.super$EveryCssVisitor$visitCssStyleRule(e)}},E.__IsInvisibleVisitor_Object_EveryCssVisitor.prototype={},E.CssStylesheet.prototype={get$isGroupEnd:()=>!1,get$isChildless:()=>!1,accept$1$1(e){return e.visitCssStylesheet$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},get$children(e){return this.children},get$span(e){return this.span}},E.CssValue.prototype={toString$0(e){return A.toString$0$(this.value)},$isAstNode:1,get$value(e){return this.value},get$span(e){return this.span}},E.AstNode.prototype={},E._FakeAstNode.prototype={get$span(e){return this._callback.call$0()},$isAstNode:1},E.Argument.prototype={toString$0(e){var t=this.defaultValue,r=this.name;return null==t?r:r+": "+t.toString$0(0)},$isAstNode:1,get$span(e){return this.span}},E.ArgumentDeclaration.prototype={get$spanWithName(){for(var e,t,r=this.span,n=r.file,s=E.String_String$fromCharCodes(I.NativeUint32List_methods.sublist$2(n._decodedChars,0,null),0,null),a=E.FileLocation$_(n,r._file$_start).offset-1;e=a>0&&(32===(e=I.JSString_methods.codeUnitAt$1(s,a))||9===e||10===e||13===e||12===e);)--a;if(!(95===(e=I.JSString_methods.codeUnitAt$1(s,a))||E.isAlphabetic0(e)||e>=128||E.isDigit(e)||45===e))return r;for(--a;e=a>=0&&(!!(t=95===(e=I.JSString_methods.codeUnitAt$1(s,a))||((t=e>=97&&e<=122||e>=65&&e<=90)||e>=128))||(e>=48&&e<=57||45===e));)--a;return e=a+1,95===(t=I.JSString_methods.codeUnitAt$1(s,e))||E.isAlphabetic0(t)||t>=128?E.SpanExtensions_trimRight(E.SpanExtensions_trimLeft(n.span$2(0,e,E.FileLocation$_(n,r._end).offset))):r},verify$2(e,t){var r,n,s,a,i,o,B,l,u=this,_="invocation",c="argument";for(n=(r=u.$arguments).length,s=t._baseMap,a=0,i=0;i<n;++i)if(o=r[i],i<e){if(B=o.name,s.containsKey$1(B))throw E.wrapException(E.SassScriptException$("Argument "+u._originalArgumentName$1(B)+T.x20was_p,null))}else if(B=o.name,s.containsKey$1(B))++a;else if(null==o.defaultValue)throw E.wrapException(E.MultiSpanSassScriptException$("Missing argument "+u._originalArgumentName$1(B)+".",_,E.LinkedHashMap_LinkedHashMap$_literal([u.get$spanWithName(),"declaration"],D.FileSpan,D.String)));if(null==u.restArgument){if(e>n)throw r=t.get$isEmpty(t)?"":"positional ",E.wrapException(E.MultiSpanSassScriptException$("Only "+n+" "+r+E.pluralize(c,n,null)+" allowed, but "+e+" "+E.pluralize("was",e,"were")+" passed.",_,E.LinkedHashMap_LinkedHashMap$_literal([u.get$spanWithName(),"declaration"],D.FileSpan,D.String)));if(a<s.get$length(s))throw n=D.String,(l=E.LinkedHashSet_LinkedHashSet$of(t,n)).removeAll$1(new E.MappedListIterable(r,new E.ArgumentDeclaration_verify_closure,E._arrayInstanceType(r)._eval$1("MappedListIterable<1,Object?>"))),E.wrapException(E.MultiSpanSassScriptException$("No "+E.pluralize(c,l._collection$_length,null)+" named "+E.S(E.toSentence(l.map$1$1(0,new E.ArgumentDeclaration_verify_closure0,D.Object),"or"))+".",_,E.LinkedHashMap_LinkedHashMap$_literal([u.get$spanWithName(),"declaration"],D.FileSpan,n)))}},_originalArgumentName$1(e){var t,r,n,s,a,i,o,B,l=null;if(e===this.restArgument)return t=this.span,r=E.String_String$fromCharCodes(I.NativeUint32List_methods.sublist$2(t.file._decodedChars,t._file$_start,t._end),0,l),I.JSString_methods.substring$2(I.JSString_methods.substring$1(r,I.JSString_methods.lastIndexOf$1(r,"$")),0,I.JSString_methods.indexOf$1(r,"."));for(n=(t=this.$arguments).length,s=0;s<n;++s)if((a=t[s]).name===e)return t=a.defaultValue,i=(n=a.span).file,o=n._file$_start,n=n._end,null==t?(t=i._decodedChars,t=E.String_String$fromCharCodes(new Uint32Array(t.subarray(o,E._checkValidRange(o,n,t.length))),0,l)):(t=i._decodedChars,r=E.String_String$fromCharCodes(new Uint32Array(t.subarray(o,E._checkValidRange(o,n,t.length))),0,l),t=I.JSString_methods.substring$2(r,0,I.JSString_methods.indexOf$1(r,":")),t=null==(B=E._lastNonWhitespace(t,!1))?"":I.JSString_methods.substring$2(t,0,B+1)),t;throw E.wrapException(E.ArgumentError$(T.This_d+e+'".',l))},matches$2(e,t){var r,n,s,a,i,o;for(n=(r=this.$arguments).length,s=t._baseMap,a=0,i=0;i<n;++i)if(o=r[i],i<e){if(s.containsKey$1(o.name))return!1}else if(s.containsKey$1(o.name))++a;else if(null==o.defaultValue)return!1;return null!=this.restArgument||!(e>n)&&!(a<s.get$length(s))},toString$0(e){var t,r,n,s=E._setArrayType([],D.JSArray_String);for(r=(t=this.$arguments).length,n=0;n<r;++n)s.push("$"+E.S(t[n]));return null!=(t=this.restArgument)&&s.push("$"+t+"..."),I.JSArray_methods.join$1(s,", ")},$isAstNode:1,get$span(e){return this.span}},E.ArgumentDeclaration_verify_closure.prototype={call$1:e=>e.name,$signature:327},E.ArgumentDeclaration_verify_closure0.prototype={call$1:e=>"$"+e,$signature:5},E.ArgumentInvocation.prototype={get$isEmpty(e){var t;return t=0===this.positional.length&&((t=this.named).get$isEmpty(t)&&null==this.rest)},toString$0(e){var t,r,n,s=this,a=s.rest,i=s.keywordRest,o=E._setArrayType([],D.JSArray_String);for(r=(t=s.positional).length,n=0;n<r;++n)o.push(s._parenthesizeArgument$1(t[n]));for(t=(t=(t=s.named).get$entries(t)).get$iterator(t);t.moveNext$0();)r=t.get$current(t),o.push("$"+E.S(r.key)+": "+s._parenthesizeArgument$1(r.value));return null!=a&&o.push(s._parenthesizeArgument$1(a)+"..."),null!=i&&o.push(s._parenthesizeArgument$1(i)+"..."),"("+I.JSArray_methods.join$1(o,", ")+")"},_parenthesizeArgument$1:e=>e instanceof E.ListExpression&&e.separator===I.ListSeparator_rXA&&!e.hasBrackets&&e.contents.length>1?"("+e.toString$0(0)+")":e.toString$0(0),$isAstNode:1,get$span(e){return this.span}},E.AtRootQuery.prototype={excludes$1(e){var t,r=this;return r._all?!r.include:D.CssStyleRule._is(e)?r._at_root_query$_rule!==r.include:D.CssMediaRule._is(e)?r.excludesName$1("media"):D.CssSupportsRule._is(e)?r.excludesName$1("supports"):!!D.CssAtRule._is(e)&&(t=e.name,r.excludesName$1(t.get$value(t).toLowerCase()))},excludesName$1(e){return(this._all||this.names.contains$1(0,e))!==this.include}},E.ConfiguredVariable.prototype={toString$0(e){var t=this.expression.toString$0(0),r=this.isGuarded?" !default":"";return"$"+this.name+": "+t+r},$isAstNode:1,get$span(e){return this.span}},E.BinaryOperationExpression.prototype={get$span(e){for(var t,r=this.left;r instanceof E.BinaryOperationExpression;)r=r.left;for(t=this.right;t instanceof E.BinaryOperationExpression;)t=t.right;return r.get$span(r).expand$1(0,t.get$span(t))},accept$1$1(e){return e.visitBinaryOperationExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t,r,n,s,a,i,o=this,B=o.left;return r=(t=B instanceof E.BinaryOperationExpression&&B.operator.precedence<o.operator.precedence||B instanceof E.ListExpression&&!B.hasBrackets&&B.contents.length>1)?""+E.Primitives_stringFromCharCode(40):"",r+=B.toString$0(0),t&&(r+=E.Primitives_stringFromCharCode(41)),n=o.operator,r=r+E.Primitives_stringFromCharCode(32)+n.operator+E.Primitives_stringFromCharCode(32),(i=!!(n=(s=o.right)instanceof E.BinaryOperationExpression&&((a=s.operator).precedence<=n.precedence&&!(a===n&&n.isAssociative)))||s instanceof E.ListExpression&&!s.hasBrackets&&s.contents.length>1)&&(r+=E.Primitives_stringFromCharCode(40)),r+=s.toString$0(0),i&&(r+=E.Primitives_stringFromCharCode(41)),r.charCodeAt(0),r},$isAstNode:1,$isExpression:1},E.BinaryOperator.prototype={_enumToString$0(){return"BinaryOperator."+this._name},toString$0(e){return this.name}},E.BooleanExpression.prototype={accept$1$1(e){return e.visitBooleanExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return String(this.value)},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.CalculationExpression.prototype={accept$1$1(e){return e.visitCalculationExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return this.name+"("+I.JSArray_methods.join$1(this.$arguments,", ")+")"},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.CalculationExpression__verifyArguments_closure.prototype={call$1:e=>(E.CalculationExpression__verify(e),e),$signature:122},E.ColorExpression.prototype={accept$1$1(e){return e.visitColorExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return E.serializeValue(this.value,!0,!0)},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.FunctionExpression.prototype={accept$1$1(e){return e.visitFunctionExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.namespace;return t=null!=t?t+".":"",(t+=this.originalName+this.$arguments.toString$0(0)).charCodeAt(0),t},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.IfExpression.prototype={accept$1$1(e){return e.visitIfExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return"if"+this.$arguments.toString$0(0)},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.InterpolatedFunctionExpression.prototype={accept$1$1(e){return e.visitInterpolatedFunctionExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return this.name.toString$0(0)+this.$arguments.toString$0(0)},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.ListExpression.prototype={accept$1$1(e){return e.visitListExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t,r,n,s,a=this,i=a.hasBrackets;return t=i?""+E.Primitives_stringFromCharCode(91):(t=0===(t=a.contents.length)||1===t&&a.separator===I.ListSeparator_rXA)?""+E.Primitives_stringFromCharCode(40):"",r=a.contents,s=(n=a.separator===I.ListSeparator_rXA)?", ":" ",s=t+new E.MappedListIterable(r,new E.ListExpression_toString_closure(a),E._arrayInstanceType(r)._eval$1("MappedListIterable<1,String>")).join$1(0,s),(i=i?s+E.Primitives_stringFromCharCode(93):0===(i=r.length)?s+E.Primitives_stringFromCharCode(41):1===i&&n?s+",)":s).charCodeAt(0),i},_list0$_elementNeedsParens$1(e){var t;return e instanceof E.ListExpression?!(e.contents.length<2)&&(!e.hasBrackets&&(t=e.separator,this.separator===I.ListSeparator_rXA?t===I.ListSeparator_rXA:t!==I.ListSeparator_undecided_null_undecided)):this.separator===I.ListSeparator_EVt&&(e instanceof E.UnaryOperationExpression&&((t=e.operator)===I.UnaryOperator_gg4||t===I.UnaryOperator_TLI))},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.ListExpression_toString_closure.prototype={call$1(e){return this.$this._list0$_elementNeedsParens$1(e)?"("+e.toString$0(0)+")":e.toString$0(0)},$signature:130},E.MapExpression.prototype={accept$1$1(e){return e.visitMapExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.pairs;return"("+new E.MappedListIterable(t,new E.MapExpression_toString_closure,E._arrayInstanceType(t)._eval$1("MappedListIterable<1,String>")).join$1(0,", ")+")"},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.MapExpression_toString_closure.prototype={call$1:e=>E.S(e.item1)+": "+E.S(e.item2),$signature:341},E.NullExpression.prototype={accept$1$1(e){return e.visitNullExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0:e=>"null",$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.NumberExpression.prototype={accept$1$1(e){return e.visitNumberExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return E.serializeValue(E.SassNumber_SassNumber(this.value,this.unit),!0,!0)},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.ParenthesizedExpression.prototype={accept$1$1(e){return e.visitParenthesizedExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return"("+this.expression.toString$0(0)+")"},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.SelectorExpression.prototype={accept$1$1(e){return e.visitSelectorExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0:e=>"&",$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.StringExpression.prototype={get$span(e){return this.text.span},accept$1$1(e){return e.visitStringExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},asInterpolation$1$static(e){var t,r,n,s,a,i,o,B,l,u;if(!this.hasQuotes)return this.text;for(r=(t=this.text).contents,n=E.StringExpression__bestQuote(new E.WhereTypeIterable(r,D.WhereTypeIterable_String)),s=new E.StringBuffer(""),a=E._setArrayType([],D.JSArray_Object),i=new E.InterpolationBuffer(s,a),s._contents=""+E.Primitives_stringFromCharCode(n),o=r.length,B=D.Expression,l=0;l<o;++l)u=r[l],B._is(u)?(i._flushText$0(),a.push(u)):"string"==typeof u&&E.StringExpression__quoteInnerText(u,n,i,e);return s._contents+=E.Primitives_stringFromCharCode(n),i.interpolation$1(t.span)},asInterpolation$0(){return this.asInterpolation$1$static(!1)},toString$0(e){return this.asInterpolation$0().toString$0(0)},$isAstNode:1,$isExpression:1},E.SupportsExpression.prototype={get$span(e){var t=this.condition;return t.get$span(t)},accept$1$1(e){return e.visitSupportsExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return this.condition.toString$0(0)},$isAstNode:1,$isExpression:1},E.UnaryOperationExpression.prototype={accept$1$1(e){return e.visitUnaryOperationExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t,r,n=this.operator,s=n.operator;return n=n===I.UnaryOperator_not_not_not?s+E.Primitives_stringFromCharCode(32):s,(r=(t=this.operand)instanceof E.BinaryOperationExpression||(t instanceof E.UnaryOperationExpression||(s=t instanceof E.ListExpression&&!t.hasBrackets&&t.contents.length>1)))&&(n+="40"),n+=t.toString$0(0),r&&(n+="41"),n.charCodeAt(0),n},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.UnaryOperator.prototype={_enumToString$0(){return"UnaryOperator."+this._name},toString$0(e){return this.name}},E.ValueExpression.prototype={accept$1$1(e){return e.visitValueExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return E.serializeValue(this.value,!0,!0)},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.VariableExpression.prototype={accept$1$1(e){return e.visitVariableExpression$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.namespace,r=this.name;return null==t?"$"+r:t+".$"+r},$isAstNode:1,$isExpression:1,get$span(e){return this.span}},E.DynamicImport.prototype={toString$0(e){return E.StringExpression_quoteText(this.urlString)},$isAstNode:1,$isImport:1,get$span(e){return this.span}},E.StaticImport.prototype={toString$0(e){var t=this.url.toString$0(0),r=this.modifiers;return t+(null==r?"":" "+r.toString$0(0))},$isAstNode:1,$isImport:1,get$span(e){return this.span}},E.Interpolation.prototype={get$asPlain(){var e,t=this.contents,r=t.length;return 0===r?"":r>1?null:"string"==typeof(e=I.JSArray_methods.get$first(t))?e:null},get$initialPlain(){var e=I.JSArray_methods.get$first(this.contents);return"string"==typeof e?e:""},Interpolation$2(e,t){var r,n,s,a,i,o,B="contents";for(n=(r=this.contents).length,s=D.Expression,a=0;a<n;++a){if(!(o="string"==typeof(i=r[a]))&&!s._is(i))throw E.wrapException(E.ArgumentError$value(r,B,T.May_on));if(0!==a&&"string"==typeof r[a-1]&&o)throw E.wrapException(E.ArgumentError$value(r,B,"May not contain adjacent Strings."))}},toString$0(e){var t=this.contents;return new E.MappedListIterable(t,new E.Interpolation_toString_closure,E._arrayInstanceType(t)._eval$1("MappedListIterable<1,String>")).join$0(0)},$isAstNode:1,get$span(e){return this.span}},E.Interpolation_toString_closure.prototype={call$1:e=>"string"==typeof e?e:"#{"+E.S(e)+"}",$signature:48},E.AtRootRule.prototype={accept$1$1(e){return e.visitAtRootRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=new E.StringBuffer("@at-root "),r=this.query;return null!=r&&(t._contents="@at-root "+r.toString$0(0)+" "),r=this.children,t.toString$0(0)+" {"+(r&&I.JSArray_methods).join$1(r," ")+"}"},get$span(e){return this.span}},E.AtRule.prototype={accept$1$1(e){return e.visitAtRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t,r="@"+this.name.toString$0(0),n=new E.StringBuffer(r),s=this.value;return null!=s&&(n._contents=r+" "+s.toString$0(0)),null==(t=this.children)?n.toString$0(0)+";":n.toString$0(0)+" {"+I.JSArray_methods.join$1(t," ")+"}"},get$span(e){return this.span}},E.CallableDeclaration.prototype={get$span(e){return this.span}},E.ContentBlock.prototype={accept$1$1(e){return e.visitContentBlock$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t,r=this.$arguments;return(r=0===r.$arguments.length&&null==r.restArgument?"":" using ("+r.toString$0(0)+")")+" {"+((t=this.children)&&I.JSArray_methods).join$1(t," ")+"}"}},E.ContentRule.prototype={accept$1$1(e){return e.visitContentRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.$arguments;return t.get$isEmpty(t)?"@content;":"@content("+t.toString$0(0)+");"},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.DebugRule.prototype={accept$1$1(e){return e.visitDebugRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return"@debug "+this.expression.toString$0(0)+";"},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.Declaration.prototype={accept$1$1(e){return e.visitDeclaration$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t,r,n=new E.StringBuffer(""),s=this.name,a=""+s.toString$0(0);return n._contents=a,a=n._contents=a+E.Primitives_stringFromCharCode(58),null!=(t=this.value)&&(s=I.JSString_methods.startsWith$1(s.get$initialPlain(),"--")?a:n._contents=a+E.Primitives_stringFromCharCode(32),n._contents=s+t.toString$0(0)),null==(r=this.children)?n.toString$0(0)+";":n.toString$0(0)+" {"+I.JSArray_methods.join$1(r," ")+"}"},get$span(e){return this.span}},E.EachRule.prototype={accept$1$1(e){return e.visitEachRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.variables,r=this.children;return"@each "+new E.MappedListIterable(t,new E.EachRule_toString_closure,E._arrayInstanceType(t)._eval$1("MappedListIterable<1,String>")).join$1(0,", ")+" in "+this.list.toString$0(0)+" {"+(r&&I.JSArray_methods).join$1(r," ")+"}"},get$span(e){return this.span}},E.EachRule_toString_closure.prototype={call$1:e=>"$"+e,$signature:5},E.ErrorRule.prototype={accept$1$1(e){return e.visitErrorRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return"@error "+this.expression.toString$0(0)+";"},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.ExtendRule.prototype={accept$1$1(e){return e.visitExtendRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return"@extend "+this.selector.toString$0(0)+(this.isOptional?" !optional":"")+";"},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.ForRule.prototype={accept$1$1(e){return e.visitForRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this,r=t.from.toString$0(0),n=t.isExclusive?"to":"through",s=t.children;return"@for $"+t.variable+" from "+r+" "+n+" "+t.to.toString$0(0)+" {"+(s&&I.JSArray_methods).join$1(s," ")+"}"},get$span(e){return this.span}},E.ForwardRule.prototype={accept$1$1(e){return e.visitForwardRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t,r,n=this,s="@forward "+E.StringExpression_quoteText(n.url.toString$0(0)),a=n.shownMixinsAndFunctions,i=n.hiddenMixinsAndFunctions;return null!=a?((t=n.shownVariables).toString,s=t=s+" show "+n._forward_rule$_memberList$2(a,t)):(t=null!=i&&(t=i._base).get$isNotEmpty(t))&&((t=n.hiddenVariables).toString,s=t=s+" hide "+n._forward_rule$_memberList$2(i,t)),null!=(r=n.prefix)&&(s+=" as "+r+"*"),(s=(0!==(t=n.configuration).length?s+" with ("+I.JSArray_methods.join$1(t,", ")+")":s)+";").charCodeAt(0),s},_forward_rule$_memberList$2(e,t){var r,n=E.List_List$of(e,!0,D.String);for(r=(r=t._base).get$iterator(r);r.moveNext$0();)n.push("$"+r.get$current(r));return I.JSArray_methods.join$1(n,", ")},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.FunctionRule.prototype={accept$1$1(e){return e.visitFunctionRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.children;return"@function "+this.name+"("+this.$arguments.toString$0(0)+") {"+(t&&I.JSArray_methods).join$1(t," ")+"}"}},E.IfRule.prototype={accept$1$1(e){return e.visitIfRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=E.ListExtensions_mapIndexed(this.clauses,new E.IfRule_toString_closure,D.IfClause,D.String).join$1(0," "),r=this.lastClause;return null!=r?t+" "+r.toString$0(0):t},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.IfRule_toString_closure.prototype={call$2:(e,t)=>"@"+(0===e?"if":"else if")+" "+t.expression.toString$0(0)+" {"+I.JSArray_methods.join$1(t.children," ")+"}",$signature:345},E.IfRuleClause.prototype={},E.IfRuleClause$__closure.prototype={call$1:e=>e instanceof E.VariableDeclaration||(e instanceof E.FunctionRule||(e instanceof E.MixinRule||e instanceof E.ImportRule&&I.JSArray_methods.any$1(e.imports,new E.IfRuleClause$___closure))),$signature:157},E.IfRuleClause$___closure.prototype={call$1:e=>e instanceof E.DynamicImport,$signature:152},E.IfClause.prototype={toString$0(e){return"@if "+this.expression.toString$0(0)+" {"+I.JSArray_methods.join$1(this.children," ")+"}"}},E.ElseClause.prototype={toString$0(e){return"@else {"+I.JSArray_methods.join$1(this.children," ")+"}"}},E.ImportRule.prototype={accept$1$1(e){return e.visitImportRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return"@import "+I.JSArray_methods.join$1(this.imports,", ")+";"},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.IncludeRule.prototype={get$spanWithoutContent(){var e,t,r=this.span;return null!=this.content&&(e=r.file,t=this.$arguments.span,r=t=E.SpanExtensions_trimRight(E.SpanExtensions_trimLeft(e.span$2(0,E.FileLocation$_(e,r._file$_start).offset,t.get$end(t).offset)))),r},accept$1$1(e){return e.visitIncludeRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t,r=this,n=r.namespace;return n=null!=n?"@include "+n+".":"@include ",n+=r.name,(t=r.$arguments).get$isEmpty(t)||(n+="("+t.toString$0(0)+")"),(n+=null==(t=r.content)?";":" "+t.toString$0(0)).charCodeAt(0),n},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.LoudComment.prototype={get$span(e){return this.text.span},accept$1$1(e){return e.visitLoudComment$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return this.text.toString$0(0)},$isAstNode:1,$isStatement:1},E.MediaRule.prototype={accept$1$1(e){return e.visitMediaRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.children;return"@media "+this.query.toString$0(0)+" {"+(t&&I.JSArray_methods).join$1(t," ")+"}"},get$span(e){return this.span}},E.MixinRule.prototype={get$hasContent(){var e,t=this,r=t.__MixinRule_hasContent_FI;return r===L&&(e=A.$eq$(I.C__HasContentVisitor.visitChildren$1(t.children),!0),t.__MixinRule_hasContent_FI!==L&&E.throwUnnamedLateFieldADI(),t.__MixinRule_hasContent_FI=e,r=e),r},accept$1$1(e){return e.visitMixinRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t="@mixin "+this.name,r=this.$arguments;return 0===r.$arguments.length&&null==r.restArgument||(t+="("+r.toString$0(0)+")"),(r=t+" {"+((r=this.children)&&I.JSArray_methods).join$1(r," ")+"}").charCodeAt(0),r}},E._HasContentVisitor.prototype={visitContentRule$1:e=>!0},E.__HasContentVisitor_Object_StatementSearchVisitor.prototype={},E.ParentStatement.prototype={$isAstNode:1,$isStatement:1},E.ParentStatement_closure.prototype={call$1:e=>e instanceof E.VariableDeclaration||(e instanceof E.FunctionRule||(e instanceof E.MixinRule||e instanceof E.ImportRule&&I.JSArray_methods.any$1(e.imports,new E.ParentStatement__closure))),$signature:157},E.ParentStatement__closure.prototype={call$1:e=>e instanceof E.DynamicImport,$signature:152},E.ReturnRule.prototype={accept$1$1(e){return e.visitReturnRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return"@return "+this.expression.toString$0(0)+";"},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.SilentComment.prototype={accept$1$1(e){return e.visitSilentComment$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return this.text},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.StyleRule.prototype={accept$1$1(e){return e.visitStyleRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.children;return this.selector.toString$0(0)+" {"+(t&&I.JSArray_methods).join$1(t," ")+"}"},get$span(e){return this.span}},E.Stylesheet.prototype={Stylesheet$internal$3$plainCss(e,t,r){var n,s,a,i,o,B;for(s=(n=this.children).length,a=this._forwards,i=this._uses,o=0;o<s;++o)if((B=n[o])instanceof E.UseRule)i.push(B);else if(B instanceof E.ForwardRule)a.push(B);else if(!(B instanceof E.SilentComment||B instanceof E.LoudComment||B instanceof E.VariableDeclaration))break},accept$1$1(e){return e.visitStylesheet$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.children;return(t&&I.JSArray_methods).join$1(t," ")},get$span(e){return this.span}},E.SupportsRule.prototype={accept$1$1(e){return e.visitSupportsRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.children;return"@supports "+this.condition.toString$0(0)+" {"+(t&&I.JSArray_methods).join$1(t," ")+"}"},get$span(e){return this.span}},E.UseRule.prototype={UseRule$4$configuration(e,t,r,n){var s,a,i,o;for(a=(s=this.configuration).length,i=0;i<a;++i)if((o=s[i]).isGuarded)throw E.wrapException(E.ArgumentError$value(o,"configured variable","can't be guarded in a @use rule."))},accept$1$1(e){return e.visitUseRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.url,r="@use "+E.StringExpression_quoteText(t.toString$0(0)),n=0===t.get$pathSegments().length?"":I.JSArray_methods.get$last(t.get$pathSegments()),s=I.JSString_methods.indexOf$1(n,".");return t=(t=this.namespace)!==I.JSString_methods.substring$2(n,0,-1===s?n.length:s)?r+" as "+(null==t?"*":t):r,(t=(0!==(r=this.configuration).length?t+" with ("+I.JSArray_methods.join$1(r,", ")+")":t)+";").charCodeAt(0),t},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.VariableDeclaration.prototype={accept$1$1(e){return e.visitVariableDeclaration$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.namespace;return t=null!=t?t+".":"",(t+="$"+this.name+": "+this.expression.toString$0(0)+";").charCodeAt(0),t},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.WarnRule.prototype={accept$1$1(e){return e.visitWarnRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){return"@warn "+this.expression.toString$0(0)+";"},$isAstNode:1,$isStatement:1,get$span(e){return this.span}},E.WhileRule.prototype={accept$1$1(e){return e.visitWhileRule$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},toString$0(e){var t=this.children;return"@while "+this.condition.toString$0(0)+" {"+(t&&I.JSArray_methods).join$1(t," ")+"}"},get$span(e){return this.span}},E.SupportsAnything.prototype={toString$0(e){return"("+this.contents.toString$0(0)+")"},$isAstNode:1,get$span(e){return this.span}},E.SupportsDeclaration.prototype={get$isCustomProperty(){var e=this.name;return e instanceof E.StringExpression&&!e.hasQuotes&&I.JSString_methods.startsWith$1(e.text.get$initialPlain(),"--")},toString$0(e){return"("+this.name.toString$0(0)+": "+this.value.toString$0(0)+")"},$isAstNode:1,get$span(e){return this.span}},E.SupportsFunction.prototype={toString$0(e){return this.name.toString$0(0)+"("+this.$arguments.toString$0(0)+")"},$isAstNode:1,get$span(e){return this.span}},E.SupportsInterpolation.prototype={toString$0(e){return"#{"+this.expression.toString$0(0)+"}"},$isAstNode:1,get$span(e){return this.span}},E.SupportsNegation. null!=t&&(t instanceof E.IDSelector&&t.name===this.name)},get$hashCode(e){return I.JSString_methods.get$hashCode(this.name)}},E.IDSelector_unify_closure.prototype={call$1(e){var t;return e instanceof E.IDSelector?(t=e.name,t=this.$this.name!==t):t=!1,t},$signature:14},E.SelectorList.prototype={get$asSassList(){var e=this.components;return E.SassList$(new E.MappedListIterable(e,new E.SelectorList_asSassList_closure,E._arrayInstanceType(e)._eval$1("MappedListIterable<1,Value>")),I.ListSeparator_rXA,!1)},accept$1$1(e){return e.visitSelectorList$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},unify$1(e){var t,r,n,s,a,i,o,B,l=D.JSArray_ComplexSelector,u=E._setArrayType([],l);for(r=(t=this.components).length,s=(n=e.components).length,a=0;a<r;++a)for(i=t[a],o=0;o<s;++o)null!=(B=E.unifyComplex(E._setArrayType([i,n[o]],l)))&&I.JSArray_methods.addAll$1(u,B);return 0===u.length?null:E.SelectorList$(u)},resolveParentSelectors$2$implicitParent(e,t){var r,n=this;if(null==e){if(!I.JSArray_methods.any$1(n.components,n.get$_complexContainsParentSelector()))return n;throw E.wrapException(E.SassScriptException$(T.Top_le,null))}return r=n.components,E.SelectorList$(E.flattenVertically(new E.MappedListIterable(r,new E.SelectorList_resolveParentSelectors_closure(n,t,e),E._arrayInstanceType(r)._eval$1("MappedListIterable<1,Iterable<ComplexSelector>>")),D.ComplexSelector))},resolveParentSelectors$1(e){return this.resolveParentSelectors$2$implicitParent(e,!0)},_complexContainsParentSelector$1:e=>I.JSArray_methods.any$1(e.components,new E.SelectorList__complexContainsParentSelector_closure),_resolveParentSelectorsCompound$2(e,t){var r,n,s,a=e.selector.components,i=I.JSArray_methods.any$1(a,new E.SelectorList__resolveParentSelectorsCompound_closure);return i||I.JSArray_methods.get$first(a)instanceof E.ParentSelector?(r=i?new E.MappedListIterable(a,new E.SelectorList__resolveParentSelectorsCompound_closure0(t),E._arrayInstanceType(a)._eval$1("MappedListIterable<1,SimpleSelector>")):a,(n=I.JSArray_methods.get$first(a))instanceof E.ParentSelector?1===a.length&&null==n.suffix?t.withAdditionalCombinators$1(e.combinators).components:(s=t.components,new E.MappedListIterable(s,new E.SelectorList__resolveParentSelectorsCompound_closure1(n,r,e),E._arrayInstanceType(s)._eval$1("MappedListIterable<1,ComplexSelector>"))):E._setArrayType([E.ComplexSelector$(I.List_empty1,E._setArrayType([new E.ComplexSelectorComponent(E.CompoundSelector$(r),E.List_List$unmodifiable(e.combinators,D.Combinator))],D.JSArray_ComplexSelectorComponent),!1)],D.JSArray_ComplexSelector)):null},isSuperselector$1(e){return E.listIsSuperselector(this.components,e.components)},withAdditionalCombinators$1(e){var t;return 0===e.length?t=this:(t=this.components,t=E.SelectorList$(new E.MappedListIterable(t,new E.SelectorList_withAdditionalCombinators_closure(e),E._arrayInstanceType(t)._eval$1("MappedListIterable<1,ComplexSelector>")))),t},get$hashCode(e){return I.C_ListEquality0.hash$1(this.components)},$eq(e,t){return null!=t&&(t instanceof E.SelectorList&&I.C_ListEquality.equals$2(0,this.components,t.components))}},E.SelectorList_asSassList_closure.prototype={call$1(e){var t,r,n,s,a,i,o,B,l,u=D.JSArray_Value,_=E._setArrayType([],u);for(r=(t=e.leadingCombinators).length,n=0;n<r;++n)_.push(new E.SassString(t[n]._combinator$_text,!1));for(r=(t=e.components).length,n=0;n<r;++n){for(a=(s=t[n]).selector,i=E._SerializeVisitor$(null,!0,null,!0,!1,null,!0),a.accept$1(i),a=E._setArrayType([new E.SassString(i._serialize$_buffer.toString$0(0),!1)],u),B=(o=s.combinators).length,l=0;l<B;++l)a.push(new E.SassString(o[l]._combinator$_text,!1));I.JSArray_methods.addAll$1(_,a)}return E.SassList$(_,I.ListSeparator_EVt,!1)},$signature:592},E.SelectorList_resolveParentSelectors_closure.prototype={call$1(e){var t,r,n,s,a,i,o,B,l,u,_,c,C,p,$,h,d,m,g,S,y=this,f=T.leadin,v=y.$this;if(!v._complexContainsParentSelector$1(e))return y.implicitParent?(v=y.parent.components,new E.MappedListIterable(v,new E.SelectorList_resolveParentSelectors__closure(e),E._arrayInstanceType(v)._eval$1("MappedListIterable<1,ComplexSelector>"))):E._setArrayType([e],D.JSArray_ComplexSelector);for(t=D.JSArray_ComplexSelector,r=E._setArrayType([],t),s=(n=e.components).length,a=y.parent,i=D.Combinator,o=D.ComplexSelectorComponent,B=e.leadingCombinators,l=D.JSArray_ComplexSelectorComponent,u=0;u<s;++u)if(_=n[u],null==(c=v._resolveParentSelectorsCompound$2(_,a)))if(0===r.length)C=E._setArrayType([_],l),(p=E.List_List$from(B,!1,i)).fixed$length=Array,p.immutable$list=Array,$=p,(p=E.List_List$from(C,!1,o)).fixed$length=Array,p.immutable$list=Array,C=p,0===$.length&&0===C.length&&E.throwExpression(E.ArgumentError$(f,null)),r.push(new E.ComplexSelector($,C,!1));else for(h=0;h<r.length;++h)$=(C=r[h]).leadingCombinators,(d=E.List_List$of(C.components,!0,o)).push(_),C=C.lineBreak||!1,(p=E.List_List$from($,!1,i)).fixed$length=Array,p.immutable$list=Array,$=p,(p=E.List_List$from(d,!1,o)).fixed$length=Array,p.immutable$list=Array,d=p,0===$.length&&0===d.length&&E.throwExpression(E.ArgumentError$(f,null)),r[h]=new E.ComplexSelector($,d,C);else if(0===r.length)I.JSArray_methods.addAll$1(r,c);else{for(C=E._setArrayType([],t),$=r.length,d=A.getInterceptor$ax(c),m=0;m<r.length;r.length===$||(0,E.throwConcurrentModificationError)(r),++m)for(g=r[m],S=d.get$iterator(c);S.moveNext$0();)C.push(g.concatenate$1(S.get$current(S)));r=C}return r},$signature:577},E.SelectorList_resolveParentSelectors__closure.prototype={call$1(e){return e.concatenate$1(this.complex)},$signature:63},E.SelectorList__complexContainsParentSelector_closure.prototype={call$1:e=>I.JSArray_methods.any$1(e.selector.components,new E.SelectorList__complexContainsParentSelector__closure),$signature:44},E.SelectorList__complexContainsParentSelector__closure.prototype={call$1(e){var t;return e instanceof E.ParentSelector||e instanceof E.PseudoSelector&&(null!=(t=e.selector)&&I.JSArray_methods.any$1(t.components,t.get$_complexContainsParentSelector()))},$signature:14},E.SelectorList__resolveParentSelectorsCompound_closure.prototype={call$1(e){var t;return e instanceof E.PseudoSelector&&(null!=(t=e.selector)&&I.JSArray_methods.any$1(t.components,t.get$_complexContainsParentSelector()))},$signature:14},E.SelectorList__resolveParentSelectorsCompound_closure0.prototype={call$1(e){var t,r,n,s;return e instanceof E.PseudoSelector?null==(t=e.selector)?e:I.JSArray_methods.any$1(t.components,t.get$_complexContainsParentSelector())?(r=t.resolveParentSelectors$2$implicitParent(this.parent,!1),n=e.name,s=e.isClass,E.PseudoSelector$(n,e.argument,!s,r)):e:e},$signature:576},E.SelectorList__resolveParentSelectorsCompound_closure1.prototype={call$1(e){var t,r,n,s,a,i,o=e.components,B=I.JSArray_methods.get$last(o);if(0!==B.combinators.length)throw E.wrapException(E.SassScriptException$('Parent "'+e.toString$0(0)+'" is incompatible with this selector.',null));return t=this.parentSelector.suffix,r=B.selector.components,n=D.SimpleSelector,s=this.resolvedSimples,a=A.getInterceptor$ax(s),null==t?(n=E.List_List$of(r,!0,n),I.JSArray_methods.addAll$1(n,a.skip$1(s,1))):((n=E.List_List$of(E.IterableExtension_get_exceptLast(r),!0,n)).push(I.JSArray_methods.get$last(r).addSuffix$1(t)),I.JSArray_methods.addAll$1(n,a.skip$1(s,1))),i=E.CompoundSelector$(n),n=e.leadingCombinators,(o=E.List_List$of(E.IterableExtension_get_exceptLast(o),!0,D.ComplexSelectorComponent)).push(new E.ComplexSelectorComponent(i,E.List_List$unmodifiable(this.component.combinators,D.Combinator))),E.ComplexSelector$(n,o,e.lineBreak)},$signature:63},E.SelectorList_withAdditionalCombinators_closure.prototype={call$1(e){return e.withAdditionalCombinators$1(this.combinators)},$signature:63},E.ParentSelector.prototype={accept$1$1(e){return e.visitParentSelector$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},unify$1:e=>E.throwExpression(E.UnsupportedError$("& doesn't support unification."))},E.PlaceholderSelector.prototype={accept$1$1(e){return e.visitPlaceholderSelector$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},addSuffix$1(e){return new E.PlaceholderSelector(this.name+e)},$eq(e,t){return null!=t&&(t instanceof E.PlaceholderSelector&&t.name===this.name)},get$hashCode(e){return I.JSString_methods.get$hashCode(this.name)}},E.PseudoSelector.prototype={get$isHostContext(){return this.isClass&&"host-context"===this.name&&null!=this.selector},get$specificity(){var e,t=this,r=t.__PseudoSelector_specificity_FI;return r===L&&(e=new E.PseudoSelector_specificity_closure(t).call$0(),t.__PseudoSelector_specificity_FI!==L&&E.throwUnnamedLateFieldADI(),t.__PseudoSelector_specificity_FI=e,r=e),r},addSuffix$1(e){var t=this;return null==t.argument&&null==t.selector||t.super$SimpleSelector$addSuffix(e),E.PseudoSelector$(t.name+e,null,!t.isClass,null)},unify$1(e){var t,r,n,s,a,i,o=this,B=o.name;if("host"===B||"host-context"===B){if(!I.JSArray_methods.every$1(e,new E.PseudoSelector_unify_closure))return null}else if(1===e.length&&(B=(t=I.JSArray_methods.get$first(e))instanceof E.UniversalSelector||t instanceof E.PseudoSelector&&(t.isClass&&"host"===t.name||t.get$isHostContext())))return t.unify$1(E._setArrayType([o],D.JSArray_SimpleSelector));if(I.JSArray_methods.contains$1(e,o))return e;for(r=E._setArrayType([],D.JSArray_SimpleSelector),B=e.length,n=!o.isClass,s=!1,a=0;a<e.length;e.length===B||(0,E.throwConcurrentModificationError)(e),++a){if((i=e[a])instanceof E.PseudoSelector&&!i.isClass){if(n)return null;r.push(o),s=!0}r.push(i)}return s||r.push(o),r},isSuperselector$1(e){var t,r,n=this;return!!n.super$SimpleSelector$isSuperselector(e)||(null==(t=n.selector)?n.$eq(0,e):e instanceof E.PseudoSelector&&!n.isClass&&!e.isClass&&"slotted"===n.normalizedName&&e.name===n.name?null!=(r=E.NullableExtension_andThen(e.selector,t.get$isSuperselector()))&&r:(r=D.JSArray_SimpleSelector,E.compoundIsSuperselector(E.CompoundSelector$(E._setArrayType([n],r)),E.CompoundSelector$(E._setArrayType([e],r)),null)))},accept$1$1(e){return e.visitPseudoSelector$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},$eq(e,t){var r=this;return null!=t&&(t instanceof E.PseudoSelector&&t.name===r.name&&t.isClass===r.isClass&&t.argument==r.argument&&A.$eq$(t.selector,r.selector))},get$hashCode(e){var t=this;return(I.JSString_methods.get$hashCode(t.name)^(t.isClass?218159:519018)^A.get$hashCode$(t.argument)^A.get$hashCode$(t.selector))>>>0}},E.PseudoSelector_specificity_closure.prototype={call$0(){var e,t,r=this.$this;if(!r.isClass)return 1;if(null==(e=r.selector))return E.SimpleSelector.prototype.get$specificity.call(r);switch(r.normalizedName){case"where":return 0;case"is":case"not":case"has":case"matches":return r=e.components,E.IterableIntegerExtension_get_max(new E.MappedListIterable(r,new E.PseudoSelector_specificity__closure,E._arrayInstanceType(r)._eval$1("MappedListIterable<1,int>")));case"nth-child":case"nth-last-child":return r=E.SimpleSelector.prototype.get$specificity.call(r),t=e.components,r+E.IterableIntegerExtension_get_max(new E.MappedListIterable(t,new E.PseudoSelector_specificity__closure0,E._arrayInstanceType(t)._eval$1("MappedListIterable<1,int>")));default:return E.SimpleSelector.prototype.get$specificity.call(r)}},$signature:12},E.PseudoSelector_specificity__closure.prototype={call$1:e=>e.get$specificity(),$signature:239},E.PseudoSelector_specificity__closure0.prototype={call$1:e=>e.get$specificity(),$signature:239},E.PseudoSelector_unify_closure.prototype={call$1:e=>e instanceof E.PseudoSelector&&(e.isClass&&"host"===e.name||null!=e.selector),$signature:14},E.QualifiedName.prototype={$eq(e,t){return null!=t&&(t instanceof E.QualifiedName&&t.name===this.name&&t.namespace==this.namespace)},get$hashCode(e){return I.JSString_methods.get$hashCode(this.name)^A.get$hashCode$(this.namespace)},toString$0(e){var t=this.namespace,r=this.name;return null==t?r:t+"|"+r}},E.SimpleSelector.prototype={get$specificity:()=>1e3,addSuffix$1(e){return E.throwExpression(E.SassScriptException$('Invalid parent selector "'+this.toString$0(0)+'"',null))},unify$1(e){var t,r,n,s,a,i,o=this;if(1===e.length&&(r=(t=I.JSArray_methods.get$first(e))instanceof E.UniversalSelector||t instanceof E.PseudoSelector&&(t.isClass&&"host"===t.name||t.get$isHostContext())))return t.unify$1(E._setArrayType([o],D.JSArray_SimpleSelector));if(I.JSArray_methods.contains$1(e,o))return e;for(n=E._setArrayType([],D.JSArray_SimpleSelector),r=e.length,s=!1,a=0;a<e.length;e.length===r||(0,E.throwConcurrentModificationError)(e),++a)i=e[a],!s&&i instanceof E.PseudoSelector&&(n.push(o),s=!0),n.push(i);return s||n.push(o),n},isSuperselector$1(e){var t;return!!this.$eq(0,e)||!!(e instanceof E.PseudoSelector&&e.isClass&&null!=(t=e.selector)&&L._subselectorPseudos.contains$1(0,e.normalizedName))&&I.JSArray_methods.every$1(t.components,new E.SimpleSelector_isSuperselector_closure(this))}},E.SimpleSelector_isSuperselector_closure.prototype={call$1(e){var t=e.components;return 0!==t.length&&I.JSArray_methods.any$1(I.JSArray_methods.get$last(t).selector.components,new E.SimpleSelector_isSuperselector__closure(this.$this))},$signature:16},E.SimpleSelector_isSuperselector__closure.prototype={call$1(e){return this.$this.isSuperselector$1(e)},$signature:14},E.TypeSelector.prototype={get$specificity:()=>1,accept$1$1(e){return e.visitTypeSelector$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},addSuffix$1(e){var t=this.name;return new E.TypeSelector(new E.QualifiedName(t.name+e,t.namespace))},unify$1(e){var t,r;return I.JSArray_methods.get$first(e)instanceof E.UniversalSelector||I.JSArray_methods.get$first(e)instanceof E.TypeSelector?null==(t=E.unifyUniversalAndElement(this,I.JSArray_methods.get$first(e)))?null:(r=E._setArrayType([t],D.JSArray_SimpleSelector),I.JSArray_methods.addAll$1(r,E.SubListIterable$(e,1,null,E._arrayInstanceType(e)._precomputed1)),r):(r=E._setArrayType([this],D.JSArray_SimpleSelector),I.JSArray_methods.addAll$1(r,e),r)},isSuperselector$1(e){var t,r;return this.super$SimpleSelector$isSuperselector(e)?t=!0:e instanceof E.TypeSelector?(t=this.name,r=e.name,t=t.name===r.name&&("*"===(t=t.namespace)||t==r.namespace)):t=!1,t},$eq(e,t){return null!=t&&(t instanceof E.TypeSelector&&t.name.$eq(0,this.name))},get$hashCode(e){var t=this.name;return I.JSString_methods.get$hashCode(t.name)^A.get$hashCode$(t.namespace)}},E.UniversalSelector.prototype={get$specificity:()=>0,accept$1$1(e){return e.visitUniversalSelector$1(this)},accept$1(e){return this.accept$1$1(e,D.dynamic)},unify$1(e){var t,r,n=this,s=I.JSArray_methods.get$first(e);return s instanceof E.UniversalSelector||s instanceof E.TypeSelector?null==(t=E.unifyUniversalAndElement(n,s))?null:(r=E._setArrayType([t],D.JSArray_SimpleSelector),I.JSArray_methods.addAll$1(r,E.SubListIterable$(e,1,null,E._arrayInstanceType(e)._precomputed1)),r):(r=1===e.length&&(s instanceof E.PseudoSelector&&(s.isClass&&"host"===s.name||s.get$isHostContext())))?null:null!=(r=n.namespace)&&"*"!==r?(r=E._setArrayType([n],D.JSArray_SimpleSelector),I.JSArray_methods.addAll$1(r,e),r):0!==e.length?e:E._setArrayType([n],D.JSArray_SimpleSelector)},isSuperselector$1(e){var t=this.namespace;return"*"===t||(e instanceof E.TypeSelector?t==e.name.namespace:e instanceof E.UniversalSelector?t==e.namespace:null==t||this.super$SimpleSelector$isSuperselector(e))},$eq(e,t){return null!=t&&(t instanceof E.UniversalSelector&&t.namespace==this.namespace)},get$hashCode(e){return A.get$hashCode$(this.namespace)}},E._compileStylesheet_closure0.prototype={call$1(e){var t;return""===e?(t=this.stylesheet.span,t=E.Uri_Uri$dataFromString(E.String_String$fromCharCodes(I.NativeUint32List_methods.sublist$2(t.get$file(t)._decodedChars,0,null),0,null),I.C_Utf8Codec,null).get$_text()):t=this.importCache.sourceMapUrl$1(0,E.Uri_parse(e)).toString$0(0),t},$signature:5},E.AsyncEnvironment.prototype={closure$0(){var e,t,r,n=this,s=n._async_environment$_forwardedModules,a=n._async_environment$_nestedForwardedModules,i=n._async_environment$_variables;return i=E._setArrayType(i.slice(0),E._arrayInstanceType(i)),e=n._async_environment$_variableNodes,e=E._setArrayType(e.slice(0),E._arrayInstanceType(e)),t=n._async_environment$_functions,t=E._setArrayType(t.slice(0),E._arrayInstanceType(t)),r=n._async_environment$_mixins,r=E._setArrayType(r.slice(0),E._arrayInstanceType(r)),E.AsyncEnvironment$_(n._async_environment$_modules,n._async_environment$_namespaceNodes,n._async__HEADER_HOST: string;
        const HTTP2_HEADER_IF_MATCH: string;
        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;
        const HTTP2_HEADER_IF_NONE_MATCH: string;
        const HTTP2_HEADER_IF_RANGE: string;
        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;
        const HTTP2_HEADER_LAST_MODIFIED: string;
        const HTTP2_HEADER_LINK: string;
        const HTTP2_HEADER_LOCATION: string;
        const HTTP2_HEADER_MAX_FORWARDS: string;
        const HTTP2_HEADER_PREFER: string;
        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;
        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;
        const HTTP2_HEADER_RANGE: string;
        const HTTP2_HEADER_REFERER: string;
        const HTTP2_HEADER_REFRESH: string;
        const HTTP2_HEADER_RETRY_AFTER: string;
        const HTTP2_HEADER_SERVER: string;
        const HTTP2_HEADER_SET_COOKIE: string;
        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;
        const HTTP2_HEADER_TRANSFER_ENCODING: string;
        const HTTP2_HEADER_TE: string;
        const HTTP2_HEADER_UPGRADE: string;
        const HTTP2_HEADER_USER_AGENT: string;
        const HTTP2_HEADER_VARY: string;
        const HTTP2_HEADER_VIA: string;
        const HTTP2_HEADER_WWW_AUTHENTICATE: string;
        const HTTP2_HEADER_HTTP2_SETTINGS: string;
        const HTTP2_HEADER_KEEP_ALIVE: string;
        const HTTP2_HEADER_PROXY_CONNECTION: string;
        const HTTP2_METHOD_ACL: string;
        const HTTP2_METHOD_BASELINE_CONTROL: string;
        const HTTP2_METHOD_BIND: string;
        const HTTP2_METHOD_CHECKIN: string;
        const HTTP2_METHOD_CHECKOUT: string;
        const HTTP2_METHOD_CONNECT: string;
        const HTTP2_METHOD_COPY: string;
        const HTTP2_METHOD_DELETE: string;
        const HTTP2_METHOD_GET: string;
        const HTTP2_METHOD_HEAD: string;
        const HTTP2_METHOD_LABEL: string;
        const HTTP2_METHOD_LINK: string;
        const HTTP2_METHOD_LOCK: string;
        const HTTP2_METHOD_MERGE: string;
        const HTTP2_METHOD_MKACTIVITY: string;
        const HTTP2_METHOD_MKCALENDAR: string;
        const HTTP2_METHOD_MKCOL: string;
        const HTTP2_METHOD_MKREDIRECTREF: string;
        const HTTP2_METHOD_MKWORKSPACE: string;
        const HTTP2_METHOD_MOVE: string;
        const HTTP2_METHOD_OPTIONS: string;
        const HTTP2_METHOD_ORDERPATCH: string;
        const HTTP2_METHOD_PATCH: string;
        const HTTP2_METHOD_POST: string;
        const HTTP2_METHOD_PRI: string;
        const HTTP2_METHOD_PROPFIND: string;
        const HTTP2_METHOD_PROPPATCH: string;
        const HTTP2_METHOD_PUT: string;
        const HTTP2_METHOD_REBIND: string;
        const HTTP2_METHOD_REPORT: string;
        const HTTP2_METHOD_SEARCH: string;
        const HTTP2_METHOD_TRACE: string;
        const HTTP2_METHOD_UNBIND: string;
        const HTTP2_METHOD_UNCHECKOUT: string;
        const HTTP2_METHOD_UNLINK: string;
        const HTTP2_METHOD_UNLOCK: string;
        const HTTP2_METHOD_UPDATE: string;
        const HTTP2_METHOD_UPDATEREDIRECTREF: string;
        const HTTP2_METHOD_VERSION_CONTROL: string;
        const HTTP_STATUS_CONTINUE: number;
        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;
        const HTTP_STATUS_PROCESSING: number;
        const HTTP_STATUS_OK: number;
        const HTTP_STATUS_CREATED: number;
        const HTTP_STATUS_ACCEPTED: number;
        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;
        const HTTP_STATUS_NO_CONTENT: number;
        const HTTP_STATUS_RESET_CONTENT: number;
        const HTTP_STATUS_PARTIAL_CONTENT: number;
        const HTTP_STATUS_MULTI_STATUS: number;
        const HTTP_STATUS_ALREADY_REPORTED: number;
        const HTTP_STATUS_IM_USED: number;
        const HTTP_STATUS_MULTIPLE_CHOICES: number;
        const HTTP_STATUS_MOVED_PERMANENTLY: number;
        const HTTP_STATUS_FOUND: number;
        const HTTP_STATUS_SEE_OTHER: number;
        const HTTP_STATUS_NOT_MODIFIED: number;
        const HTTP_STATUS_USE_PROXY: number;
        const HTTP_STATUS_TEMPORARY_REDIRECT: number;
        const HTTP_STATUS_PERMANENT_REDIRECT: number;
        const HTTP_STATUS_BAD_REQUEST: number;
        const HTTP_STATUS_UNAUTHORIZED: number;
        const HTTP_STATUS_PAYMENT_REQUIRED: number;
        const HTTP_STATUS_FORBIDDEN: number;
        const HTTP_STATUS_NOT_FOUND: number;
        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;
        const HTTP_STATUS_NOT_ACCEPTABLE: number;
        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;
        const HTTP_STATUS_REQUEST_TIMEOUT: number;
        const HTTP_STATUS_CONFLICT: number;
        const HTTP_STATUS_GONE: number;
        const HTTP_STATUS_LENGTH_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_FAILED: number;
        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;
        const HTTP_STATUS_URI_TOO_LONG: number;
        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;
        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;
        const HTTP_STATUS_EXPECTATION_FAILED: number;
        const HTTP_STATUS_TEAPOT: number;
        const HTTP_STATUS_MISDIRECTED_REQUEST: number;
        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;
        const HTTP_STATUS_LOCKED: number;
        const HTTP_STATUS_FAILED_DEPENDENCY: number;
        const HTTP_STATUS_UNORDERED_COLLECTION: number;
        const HTTP_STATUS_UPGRADE_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_REQUIRED: number;
        const HTTP_STATUS_TOO_MANY_REQUESTS: number;
        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;
        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;
        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;
        const HTTP_STATUS_NOT_IMPLEMENTED: number;
        const HTTP_STATUS_BAD_GATEWAY: number;
        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;
        const HTTP_STATUS_GATEWAY_TIMEOUT: number;
        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;
        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;
        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;
        const HTTP_STATUS_LOOP_DETECTED: number;
        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;
        const HTTP_STATUS_NOT_EXTENDED: number;
        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;
    }
    /**
     * This symbol can be set as a property on the HTTP/2 headers object with
     * an array value in order to provide a list of headers considered sensitive.
     */
    export const sensitiveHeaders: symbol;
    /**
     * Returns an object containing the default settings for an `Http2Session`instance. This method returns a new object instance every time it is called
     * so instances returned may be safely modified for use.
     * @since v8.4.0
     */
    export function getDefaultSettings(): Settings;
    /**
     * Returns a `Buffer` instance containing serialized representation of the given
     * HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended
     * for use with the `HTTP2-Settings` header field.
     *
     * ```js
     * const http2 = require('http2');
     *
     * const packed = http2.getPackedSettings({ enablePush: false });
     *
     * console.log(packed.toString('base64'));
     * // Prints: AAIAAAAA
     * ```
     * @since v8.4.0
     */
    export function getPackedSettings(settings: Settings): Buffer;
    /**
     * Returns a `HTTP/2 Settings Object` containing the deserialized settings from
     * the given `Buffer` as generated by `http2.getPackedSettings()`.
     * @since v8.4.0
     * @param buf The packed settings.
     */
    export function getUnpackedSettings(buf: Uint8Array): Settings;
    /**
     * Returns a `net.Server` instance that creates and manages `Http2Session`instances.
     *
     * Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {@link createSecureServer} is necessary when
     * communicating
     * with browser clients.
     *
     * ```js
     * const http2 = require('http2');
     *
     * // Create an unencrypted HTTP/2 server.
     * // Since there are no browsers known that support
     * // unencrypted HTTP/2, the use of `http2.createSecureServer()`
     * // is necessary when communicating with browser clients.
     * const server = http2.createServer();
     *
     * server.on('stream', (stream, headers) => {
     *   stream.respond({
     *     'content-type': 'text/html; charset=utf-8',
     *     ':status': 200
     *   });
     *   stream.end('<h1>Hello World</h1>');
     * });
     *
     * server.listen(80);
     * ```
     * @since v8.4.0
     * @param onRequestHandler See `Compatibility API`
     */
    export function createServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;
    export function createServer(options: ServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;
    /**
     * Returns a `tls.Server` instance that creates and manages `Http2Session`instances.
     *
     * ```js
     * const http2 = require('http2');
     * const fs = require('fs');
     *
     * const options = {
     *   key: fs.readFileSync('server-key.pem'),
     *   cert: fs.readFileSync('server-cert.pem')
     * };
     *
     * // Create a secure HTTP/2 server
     * const server = http2.createSecureServer(options);
     *
     * server.on('stream', (stream, headers) => {
     *   stream.respond({
     *     'content-type': 'text/html; charset=utf-8',
     *     ':status': 200
     *   });
     *   stream.end('<h1>Hello World</h1>');
     * });
     *
     * server.listen(80);
     * ```
     * @since v8.4.0
     * @param onRequestHandler See `Compatibility API`
     */
    export function createSecureServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;
    export function createSecureServer(options: SecureServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;
    /**
     * Returns a `ClientHttp2Session` instance.
     *
     * ```js
     * const http2 = require('http2');
     * const client = http2.connect('https://localhost:1234');
     *
     * // Use the client
     *
     * client.close();
     * ```
     * @since v8.4.0
     * @param authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port
     * is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.
     * @param listener Will be registered as a one-time listener of the {@link 'connect'} event.
     */
    export function connect(authority: string | url.URL, listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): ClientHttp2Session;
    export function connect(
        authority: string | url.URL,
        options?: ClientSessionOptions | SecureClientSessionOptions,
        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void
    ): ClientHttp2Session;
}
declare module 'node:http2' {
    export * from 'http2';
}
